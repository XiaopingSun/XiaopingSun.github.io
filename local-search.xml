<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《认知觉醒》读书笔记</title>
    <link href="/2024/02/14/%E3%80%8A%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/02/14/%E3%80%8A%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>年前一直在看认知心理学，包括网上比较畅销的《刻意练习》、《认知天性》，封面倒是很好看，但书的内容很差。作者举了大量/重复/没法求证真伪的事例来佐证观点，占了书籍三分之二的内容，这些例子也没有可复制性，干货几句话就可以总结出来，读起来完全是在浪费时间。抱着这样的心态我打开了这本《认知觉醒》，读完发现竟与其他几本完全不同，作者周岭之前有过一段混沌的经历，每天浑浑噩噩，时光在不经意间溜走却好像什么也没留下，这与我目前的状态很像。他通过阅读脑科学和认知心理学相关的书籍，给这种混沌状态找一个科学的解释，并总结出自己的一套行之有效的“认知觉醒”方法论，读过之后让我醍醐灌顶。但也由于这本书集各家之所长，章节之间的联系不是很紧密，整体章节架构也有点混乱，很难从一个底层逻辑展开梳理它的内容框架，这一点作者在后记中也有提到，所以这篇读书笔记将以章节为单位来总结梳理。</p><h1>内容概述</h1><h2 id="上篇——内观自己，摆脱焦虑">上篇——内观自己，摆脱焦虑</h2><h3 id="一、大脑——一切问题的起源">一、大脑——一切问题的起源</h3><p>这一章中首先介绍了人类“三重大脑”和其进化过程：</p><p><img src="/resources/image/v2-912486e9ab3ffa8e41c1b9f8b2e98561_r.jpg" alt="三重大脑的进化过程"></p><p>数十亿年前海洋中出现了单细胞生物，随后演化为动物、植物、微生物等，之后动物这条分支进化成原始鱼类。约 3.6 亿年前，它们开始向陆地进军，地球进入爬行动物的时代。为了适应陆地生活，爬行动物演化出了最初的“本能脑”。到了大约 2 亿年前，哺乳动物开始登场，它们为了更好地适应环境，不仅让体温保持恒定，还进化出了情绪，大脑里也发展出一个独特的情感区域（边缘系统），脑科学家称之为“情绪脑”。直到距今约 250 万年前，人类才从哺乳动物中脱颖而出，在大脑的前额区域进化出了“新皮层”，这个新皮层直到 7 万 ~ 20 万年前才真正成型，这个新的脑区称为“理智脑”。</p><p><img src="/resources/image/v2-8d4d73deceb39b584d8cbd1cc5ea1cc0_r.jpg" alt="三重大脑"></p><ul><li>本能脑（约 3.6 亿年）：结构简单，只有一个原始的反射模块，可以让爬行动物对环境快速做出本能反应。</li><li>情绪脑（约 2 亿年）：情绪可以使哺乳动物在恶劣的环境中趋利避害，大大提升其生存优势。</li><li>理智脑（约 250 万年）：很年轻，富有远见、善于均衡，能立足未来获得延迟满足。</li></ul><p>根据这个理论，“农夫与蛇”的故事结局就是注定的了，蛇属于爬行动物，它只有本能脑而没有情绪脑，只能依靠其本能行事，农夫以为蛇和人类一样有善恶之心，会知恩图报，结果为自己的无知付出生命的代价，也同样刷新了我们“世界上所有动物都只有一个大脑，人类仅仅比它们聪明一点”的错误认知。</p><p>理智脑虽然高级，但比起本能脑和情绪脑，它的力量实在是太弱小了，原因至少有以下四个方面：</p><ul><li>进化时间较晚，与本能脑和情绪脑相比，是一个不满一岁的宝宝。</li><li>三重大脑发育成熟的时间不同，理智脑最晚，大约要到 22 岁才能发育成熟。</li><li>大脑中约有 860 亿个活跃的神经元细胞，而本能脑和情绪脑拥有近八成，对大脑掌控力更强。</li><li>本能脑和情绪脑掌管潜意识和生理系统，运行速度极快，至少可达 11 000 000 次/秒，而理智脑最快运行速度仅为 40 次/秒，且非常耗能。</li></ul><p>种种迹象表明，理智脑对大脑的控制能力很弱，我们在生活中做的大部分决策往往源于本能和情绪，而非理智。本能脑和情绪脑的基因一直被生存压力塑造着，所以它们的天性自然成了目光短浅、即时满足，又因它们主导着大脑的决策，所以这些天性也就成了人类的默认天性。</p><p>人，生来混沌，根本原因在于出生时我们的理智脑太过薄弱，无力摆脱本能脑和情绪脑的压制与掌控，而觉醒和成长就是让理智脑尽快变强，以克服天性。而让理智脑变强大并不意味着要抹杀本能脑和情绪脑，事实上也抹杀不了，它们三位一体，缺一不可。换一个角度看也没必要抹杀，因为本能脑强大的运算能力和情绪脑强大的行动能力，都是不可多得的宝贵资源，只要去深入了解，循循善诱，就能为己所用，甚至这些力量还是成就我们的关键。</p><p>理智脑不是直接干活的，干活的是本能脑和情绪脑的事情，因为它们的“力气大”；上天赋予理智脑智慧，是让它驱动本能和情绪，而不是直接取代它们。</p><p>接着，作者介绍了焦虑的几种形式：</p><ul><li>完成焦虑：日程安排太满导致无法优质完成。</li><li>定位焦虑：找不准自己的定位。</li><li>选择焦虑：选择太多犹豫不决。</li><li>环境焦虑：外部环境因素导致低效和无力。</li></ul><p>焦虑的根源：</p><ul><li>急于求成，想同时做很多事。</li><li>避难趋易，想不怎么努力就立即看到效果。</li></ul><p>避免焦虑的方法：</p><ul><li>克制欲望，不要让自己同时做很多事。</li><li>面对现实，看清自己真实的能力水平。</li><li>要事优先，想办法只做最重要的事情。</li><li>接受环境，在局限中做力所能及的事。</li><li>直面核心，狠狠逼自己一把去突破它。</li></ul><p>作者认为焦虑的根源是人的天性导致的，是人类的默认设置，克服焦虑的方法就是克服天性的束缚。但我认为这里提到的焦虑只是因想做而做不到引起的焦虑，是焦虑的一个子集，但就我本身来说，这个子集的占比是很大的，所以在读这本书时才会有共鸣。</p><p>本章的最后，作者给出了克服焦虑的一个解决方案：耐心。<br>首先作者为“耐心”正名，那些依靠意志力去对抗，倾向于忍受无趣、承受痛苦、咬牙坚持、硬抗到底的，不能称之为耐心，耐心不是毅力带来的结果，而是具有长远目标的结果。21天养成一个好习惯、读几本书就能博闻强识、打卡训练营这些都是曾经走过的弯路。</p><p>接着作者指出缺乏耐心是人类的天性，又从宏观和微观上介绍了几个认知规律：</p><ul><li>复利曲线：一个被爱因斯坦称作“世界第八大奇迹”的价值积累规律，突破拐点后会迅速增长。</li></ul><p><img src="/resources/image/u%3D325538338%2C3688424867%26fm%3D253%26fmt%3Dauto%26app%3D138%26f%3DJPEG.webp" alt="复利曲线"></p><ul><li>舒适区边缘：要想让自己高效成长，必须让自己始终处于舒适区的边缘，贸然跨到困难去会让自己受挫，始终停留在舒适区会让自己停滞。而天性的急于求成会把自己引向困难区，避难趋易又会使自己沉浸在舒适区。</li></ul><p><img src="/resources/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240224120143.jpg" alt="舒适区边缘"></p><ul><li>成长权重比：改变量 &gt; 行动量 &gt; 思考量 &gt; 学习量</li></ul><p><img src="/resources/image/641.webp" alt="成长权重比"></p><ul><li>学习平台期：学习进展和时间的关系并不是我们想象中的那种线性关系，而是一种波浪式上升关系。</li></ul><p><img src="/resources/image/b2de9c82d158ccbf6e79efc01ccf8f32b0354121.webp" alt="学习平台期"></p><p>怎样拥有耐心：</p><ul><li>面对天性，放下心里包袱，坦然接纳自己。</li><li>面对诱惑，学会延迟满足，变对抗为沟通。</li><li>面对困难，主动改变视角，赋予行动意义。</li></ul><p>小结一下，这一章的第一小节我觉得是全书的亮点之一，这部分通过脑科学的知识解释了日常生活中存在的混沌状态的原因，不是个人主观上的懒惰，而是天性本就如此，读到这里突然就跟自己和解了，释然了。同时，这部分也揭示了成长的底层逻辑：成长就是克服天性的过程。接着作者抛出问题，介绍了因人类天性导致焦虑的几种形式和避免焦虑的方法，并指出解决这类焦虑问题的一个好方法是耐心。作者认为耐心应该是具有长远眼光并着手于当下，而不是靠意志力死磕，通过几个认知规律作者想说明，磨练耐心就是一个克服天性的过程。</p><h3 id="二、潜意识——生命留给我们的彩蛋">二、潜意识——生命留给我们的彩蛋</h3><p>首先作者通过机器人和人类的对比引出本章的第一个主题：模糊。</p><p>机器人和人类最大的区别是，机器人没有潜意识。机器人一旦断电就会停止工作，而人若是昏厥，失去了意识，虽然会瘫倒在地，但心跳、呼吸、消化等功能并不会立即停止，因为它们受潜意识控制，除非物理死亡，否则潜意识永远不会消失。人类为了更好的生存，避免大量计算耗能，进化之后巧妙地采用了意识分层的手段。让潜意识负责生理系统，意识负责社会系统。然而进化是一把双刃剑，意识分层在给人类带来巨大好处的同时也带来了副作用——模糊。因为处理各种信息的速度不对等，意识很难介入潜意识，而潜意识却能轻易左右意识，由于潜意识对大脑的强烈操控能力，往往会做出与预想偏差很大的行为决策，让人进入一种模糊的状态。</p><p>消除模糊的三种方法：认知清晰，情绪平和，行动坚定。</p><ul><li>学习知识，消除认知模糊：书上这部分的描述我不太看的出作者想表达的意图，我理解的是通过不断学习知识，提升认知能力来训练本能脑/情绪脑控制的潜意识部分，让潜意识能够代替意识做出相对正确的行为决策，进而消除模糊。</li><li>拆解烦恼，消除情绪模糊：任何痛苦事件都不会自动消失，哪怕再小的事情也是如此。要想不受其困扰，唯一的办法就是正视它、看清它、拆解它、化解它，不给它进入潜意识的机会，不给它变模糊的机会。即使已经进入潜意识，也要想办法将它挖出来。</li><li>里清外明，消除行动模糊：行动力不足的真正原因是选择模糊，我们要把目标和过程细化、具体化，在诸多可能性中建立一条单行通道，让自己始终处于“没得选”的状态。</li></ul><p>看起来未经磨练的潜意识会给我们的生活带来很多困扰，接下来作者要为潜意识正名了。</p><p>关于潜意识，学术界的看法不一：</p><ul><li>弗洛伊德认为潜意识是“危险地带”，里面蕴藏着邪恶，它会让人遵从原始欲望回到野蛮状态。</li><li>荣格认为潜意识是智慧的，它包含了很多理性无法涉及的东西。甚至包含了人类的集体智慧。</li></ul><p>现代科学研究认为二者各对了一半。潜意识没有思维，只关心眼前的事物，喜欢即刻、确定、简单、舒适，这是属于天性的部分。同时，它处理信息的速度又极快，至少可达 11 000 000 次/秒，能极其敏锐地感知很多不易察觉的信息，这是属于感性的部分。感性的力量很强大，如果不善加利用，实在是太可惜了，尤其是在学习和成长的过程中，如果有它的助力，或许会有意想不到的收获。</p><ul><li>凭感觉学习：先用感性能力帮助自己选择，再用理性能力帮助自己思考，这就是高手学习的方法。作者举了一个“熔断不读书”法的例子，我觉得论据有点牵强，读书本身就有理智脑的参与，捕获触动点是出于感性的觉知还是理性的思考，这个有点难判断。</li><li>凭感觉寻找人生目标：作者主张用感知力代替思考力来选择人生目标，利用感性去感知内心的真正需求。作者列举了《美好人生运营指南》和《坚毅》中的几个供感知力感知人生目标的问题（比如你在做什么事情时最让自己感动），我试着回答一下，答案都是电吉他。</li></ul><p>如何捕捉感性：</p><ul><li>“最”字法：关注那些最触动自己的点，让你眼前一亮，心中泛起波澜的人和事，脑中灵光乍现的想法，遭遇的痛苦。</li><li>“总”字法：平时脑子里总是不自觉地跳出来的某些重复念头，或是心里总是挥之不去的事。</li><li>无意识的第一反应：关注自己第一次见到某个人，第一次走进某个房间，第一次做某件事时，心中出现的瞬间反应或第一个念头。</li><li>梦境：梦境是潜意识传递信息的一种方式，它可能是内心真实想法的展示，也可能是灵感的启发。</li><li>身体：无论生理还是心理上的不适，都会通过身体如实地反映出来，记得多关注这些反馈。</li><li>直觉：给一些来路不明、无法解释的信息开绿灯。</li></ul><p>小结一下，这一章介绍了潜意识和意识，它们分别是本能脑/情绪脑和理智脑的产物，它们之间处理信息速度的不对等造成了模糊的存在，如何消除模糊呢？我理解认知上的模糊可以通过不断学习提升认知，训练潜意识做出相对正确的决策。情绪模糊的消除，我觉得可以用春节上映的《飞驰人生2》中一句台词来解释：克服恐惧的方法是直面恐惧。行动力模糊则是将目标和过程细化分解，权衡利弊后就不能再犹豫。感性是潜意识的一部分，感性可以帮助我们寻找人生目标，如果能够善于捕捉感性，会使人生有意想不到的收获。</p><h3 id="三、元认知——人类的终极能力">三、元认知——人类的终极能力</h3><p>元，在汉语中有“头、首、始、大”的意思，即最高级别。元认知，就是最高级别的认知，它能对自身的“思考过程”进行认知和理解。</p><p><img src="/resources/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240224120154.jpg" alt="元认知"></p><p>听起来和看起来都很高大上，但其实元认知能力就是反思能力，分为被动元认知和主动元认知。从被动到主动，是一个转折点，当一个人能主动开启第三视角、开始持续反思自己的思维和行为时，就意味着他真正开始觉醒了，他有了快速成长的可能。</p><p>事后反思的能力相信大家多少都会有，但作者提出的更高级别的元认知，是想象出一个睿智的“灵魂伴侣”实时动态监控自己的行为和决策，主打就是一个陪伴。</p><p><img src="/resources/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240224120202.jpg" alt="元认知的维度"></p><p>如何获取元认知的能力：</p><ul><li>从上图可以看出，提升元认知能力的工具需要从“过去”端获取，包括学习前人的智慧和反思自身的经历。</li><li>自身的经历更是一种独特的财富。</li><li>启用“灵魂伴侣”。</li><li>冥想。</li></ul><p>元认知可以被重新定义为觉察力和自控力的组合，自我审视，主动控制，防止被潜意识左右的能力。每当遇到需要选择的情况时，我们要是能先停留几秒思考一下，就有可能激活自己的理智脑，启用元认知来审视当前的思维，做出不一样的选择。</p><p>锻炼元认知不是一件容易的事情，要持续练习，还需要方法的指导。好的方法并不难，那就是：一定要在选择节点上多花“元时间”。</p><p>元时间通常分布在“选择的节点”上，比如一件事情，一个阶段或一天开始或结束时。善用这些时间会极大程度地优化后续时间的质量。所有面临选择的时间节点，都可以被称作“元时间”。我们不能在这个时候丧失主动权，任由本能左右自己进入下一个阶段。在“元时间”内我们要做什么，很简单，就做一件事：想清楚。</p><ul><li>在选择的节点审视自己的第一反应</li><li>产生清晰明确的主张。</li><li>对模糊零容忍。</li></ul><p>焦虑的人很少有“元时间”的意识，他们习惯不动脑子，直接行动，喜欢用饱和的行动来感动自己，想与做的时间配比差距悬殊，他们甚至连一丁点儿深入思考的时间都不愿意花，任由本能欲望让自己迷失在自我满足的行动里。</p><p>元认知能力强的人就是这样：无论是当下的注意力、当天的日程安排，还是长期的人生目标，他们都力求想清楚意义、进行自我审视和主动控制，而不是随波逐流。</p><h2 id="下篇-外观世界，借力而行">下篇-外观世界，借力而行</h2><h3 id="四、专注力——情绪和智慧的交叉地带">四、专注力——情绪和智慧的交叉地带</h3><p>作者将注意力拆解为“集中在行动上的”和“集中在感受上的”两部分。起初，行动和感受二者是统一的，我们会在做一件事情时全身心地感受这件事情，将注意力全部放在和当前事物相关的事情上。随着行动越来越熟练，我们在行动上集中的注意力越来越少，分散在其他地方的注意力越来越多，于是我们不再去耐心感受行动。从此，分心代替专注，身心开始分离。</p><p>宏观上分心走神的原因无非两个：</p><ul><li>觉得当下太无聊，所以追求更有意思的事情。</li><li>觉得当下太痛苦，于是追求更舒适的事情。</li></ul><p>微观上分心走神是我们的天性，这背后的原因与大脑的记忆机制有关。人类的大脑使用背景关联记忆的方法，即借助事情的背景或线索等提示信息来让我们想起特定内容。背景关联记忆的方式可以极大地降低大脑耗能，弥补大脑神经元处理速度的不足。然而进化是把双刃剑，背景关联记忆的一个副作用就是：我们感官所听到、看到、摸到、尝到、嗅到的任何信息，都会引出一些其他记忆内容，又因为感观受潜意识控制，而潜意识永不消逝，所以只要我们醒着，这种分心走神随时都可能发生。这也是我们需要锻炼元认知的原因，因为成长就是克服天性的过程，我们必须用觉知力和自控力去约束天性，否则就会被潜意识左右而不自知。</p><p>让感受回归行动：身体感受永远是进入当下状态的最好媒介，而感受事物消失的过程更是一种很好的专注力训练。身心合一的要领不仅是专注于当下，更是享受当下。</p><p>作者举了一个小故事，感触颇深：</p><ul><li>一位行者问老和尚：“您得道前在做什么？”</li><li>老和尚说：“砍柴、担水、做饭。”</li><li>行者问：“那得到后呢？”</li><li>老和尚说：“砍柴、担水、做饭。”</li><li>行者又问：“那何谓得道？”</li><li>老和尚说：“得到前，砍柴时惦记着挑水，挑水时惦记着做饭；得到后，砍柴即砍柴，担水即担水，做饭即做饭。”</li></ul><p>深度沉浸的方法：</p><ul><li>有定义明确的目标，如果目标太大，那就将它拆解成小目标。</li><li>练习时极度专注。大脑在学习时有两种模式，“意识的专注模式（深入）”和“潜意识的发散模式（灵感）”，变聪明的秘诀就是，先保持极度专注，想不出答案时再将注意力转换到另一件与此毫不相干的事情上。即事前聚精会神，让意识极度投入；事后完全忘记，让意识彻底撒手。这样，灵感和答案就会大概率地出现。</li><li>能获得有效的反馈。</li><li>始终在拉伸区练习。</li></ul><h3 id="五、学习力——学习不是一味地努力">五、学习力——学习不是一味地努力</h3><p>这一章刚开始作者又一次介绍了舒适区边缘的方法论，没记错这已经是本书第三次提及了，而这次用了整整一节，我觉得这部分没有太多可以提炼的东西。</p><p>接着作者提到了深度学习，与前面的深度沉浸不同，深度沉浸是状态，深度学习指的是内容。作者举了胡适的英文老师王云五先生的例子，王云五先生是这样自学英语写作的：找一篇英文的名家佳作，熟读几次以后，把它翻译成中文；一星期之后，再将中文反过来翻译成英文，翻译期间绝不查阅英语原文；翻译好后再与原文比对，找出自己翻译的错误、失误和不够精良之处。如此反复练习，王云五先生积累了扎实的英文功底，为日后从事英语教学和出版事业打下了坚实的基础。</p><p>人的学习可以分成被动学习和主动学习两个层次：</p><ul><li>被动学习：如听讲、阅读、视听、演示，留存率低。</li><li>主动学习：如讨论、实践、教授，留存率高。</li></ul><p>如何深度学习：</p><ul><li>获取高质量的知识</li><li>深度缝接新知识</li><li>输出成果去教授</li></ul><p>深度学习的好处：</p><ul><li>深度学习出了能让我们不再浮躁，能磨练理智，还能带来诸多好处，比如跨界能力的提升。</li><li>深度学习还能让人产生更多灵感，只有在自己的领域探索得足够深入时，灵感才可能在潜意识的帮助下显现。</li><li>深度学习还能让我们看到不同事物之间更多的关联，产生洞见。</li></ul><p>同时，作者也为浅学习正名，在深度学习的基础上要对浅学习保持开放，深度之下的广度才是有效的。</p><p>接着作者对深度学习的第二个要素“缝接”做了具体的阐释，并换了个词——关联。无论是学习动作，还是背记公式，从本质上来说都是大脑中神经细胞建立连接的过程。通过大量的重复动作，大脑中两个或者多个原本并不关联的神经元经过反复刺激产生了强关联。</p><p>如何获取关联能力：</p><ul><li>首先，手中有锤子。对某件事情有足够的热爱和投入，和极致的专注和思考。</li><li>其次，输入足够多。不管是阅读获取，还是现实经历，知识和阅历越丰富，成功关联的概率就越大。</li><li>再次，保持好奇心。好奇是发现新知识、新灵感的原动力。</li><li>最后，常说一句话。“这个道理还能用在什么地方？”</li></ul><p>借助这种强大的关联能力，我们可以建立自己的个人认知体系。在个人成长领域，没有最优、最稳定、最权威的认知体系，只有最适合我们当前状态的认知体系。正如万维钢所言，真正的知识不是你知道了它，而是能运用它帮助自己做出正确的判断和选择，解决实际问题。体系的本质就是用独特的视角将一些零散的、独立的知识、概念或观点整合为应对这个世界的方法和技巧。因此搭建个人认知体系的真相就是，打碎各家的认知体系，只取其中最触动自己的点或块，然后将其拼接成自己的认知网络。</p><p>接着作者分析了打卡这种学习方式的几个弊端：</p><ul><li>动机转移，动力扭曲。</li><li>认知闭合，效能降低。</li><li>任务心态，身心分裂。</li></ul><p>又介绍了两个规避打卡弊端的策略：</p><ul><li>用记录代替打卡：每次学习后只做行动记录，不做打卡展示。把学习过程记录下来，既可以看到自己的学习轨迹，也便于每周复盘。</li><li>设下限，不设上限：这样做的好处是使完成目标毫无负担，且此时刚好进入学习状态，精力旺盛，就愿意顺着惯性继续学下去，这种策略的智慧之处在于规避了任务闭合需求。</li></ul><p>接着作者提到学习的过程中是否有及时、持续的正向反馈，是产生学习效果差异的关键，持续的正向反馈才能真正激发本能脑和情绪脑的强大行动力。所以科学的学习策略是产出作品、获取反馈，驱动本能脑和情绪脑去“玩玩玩”，而不是一味的努力坚持，让理智脑苦苦地去“学学学”。</p><p>最后作者提出在保持极度专注后要注意适当休息，更科学的模式应该是 极度专注 + 主动休息，如此反复。</p><p>番茄工作法：先极其专注地工作 25 分钟，然后休息 5 分钟，如此循环往复，如果目标太大，就将目标拆分成小目标分配到每个番茄时间。这种工作法有点类似与高强度间歇性训练。</p><p>小结一下，这一章作者提到学习并不是一味地努力就可以，还需要掌握科学方法，章节中提到的方法有些类似费曼学习法，几个点都让我很有共鸣。之前我一直自诩是一个很勤奋很努力的人，可以制定很多目标计划并花费大量的时间去学习和练习，但最后的结果常常不尽如人意，原因有很多。参照这一章的内容来说，首先我的有些学习大部分停留在表层，以为用些碎片时间看看文章、看看视频就是学习了，但其实学到的东西留存率很低，甚至不记得自己学过。有些知识的获取途径也有问题，没有查阅原始资料的习惯，都是按照人家整理好的知识框架去学习，没有建立自己的认知体系。而且还有严重的任务闭合心态，觉得今天我花了一个小时在这项学习上，我就完成了任务，关注的是学习时间而非学习内容本身。番茄工作法确实是个不错的方法，最近我也在实践中，发现确实对提升工作效率有很大帮助，长时间、间歇性的极度专注，让我明显感觉大脑“在线”了，不再像以前一样浑浑噩噩，番茄工作法值得推荐！</p><h3 id="六、行动力——没有行动，世界只是个概念">六、行动力——没有行动，世界只是个概念</h3><p>本章作者介绍了一些可以提升行动力的方法：</p><ul><li>首先，在每个关键选择的时间节点，强迫自己先做重要的事情，一旦进入正向的增强回路，便能拥有强大的行动力。</li><li>其次，还需要把目标细化、具体化。行动力只有在清晰力的支撑下才能得到重构。</li><li>当较劲脑汁也想不清楚的时候，不妨先根据前人的假设先行动起来，暂且相信他们说的是对的。</li><li>有自己热爱的事，比行动力本身要重要的多。</li></ul><p>关于第二点清晰力的构建，作者提供了一个方法，就是将第二天要做的事情写下来：</p><ul><li>第一步：找一本普通的 A5 卡面抄，将纸页对折。</li><li>第二步：在上方写下当前所有要做的事，然后清空大脑，按权重将列出的事项标上序号，这样，目标就变得清晰可见。</li><li>第三步：收集一切可用信息，在页面左侧预测性地写下在某一时间段做什么，然后在底部统计“计划学习时间”和“可用学习时间”，这样，时间也变得清晰了。</li><li>第四步：在页面右侧记录当天的实施情况，一天过后对学习时间和成果进行统计，时间利用效率便一目了然。</li></ul><p>即整个页面分为 4 个部分，呈现“工”字形：</p><ul><li>待办事项</li><li>计划完成</li><li>实际完成</li><li>备注</li></ul><p>最后作者提到“道理都懂，就是不做”的情况要怎么破解，但读下来发现并没有提供实际有效的方法，这部分更像是鸡汤，讲了一些大家都懂的道理，其他答案在一开始作者已经提到了，就是直接去做。对我来说提升执行力的一个方法是在生活中多接触自己的目标领域，可以是讲座、论坛，亦或是演唱会、livehouse，那种让我沉浸其中肾上腺素飙升的情境，更能激发我的潜在执行力。</p><p>本章触动我的点是提升清晰力部分提出的将目标提前规划并写下来，这的确是个好方法，我把这个步骤整合到每天的总结中，写完日记之后会把第二天的目标安排写到背面，这样会使自己第二天的目标计划更清晰，执行力更高，这个习惯会一直坚持下去。</p><h3 id="七、情绪里——情绪是多角度看问题的智慧">七、情绪里——情绪是多角度看问题的智慧</h3><p>首先作者借稀缺心态会导致变笨的一个例子引出了心智带宽的概念：所谓心智带宽，就是心智的容量，它支撑着人的认知力、行动力和自控力。心智带宽一旦降低，人很容易丧失判断力，做出不明智的选择。</p><p>提升心智带宽的方法：</p><ul><li>保持环境觉知，理智选择。</li><li>保持目标觉知，少即是多。</li><li>保持欲望觉知，审视决策。</li><li>保持情绪觉知，谨慎选择。</li><li>保持闲余觉知，自我设限。</li></ul><p>接着作者提到你的坏情绪，可能源于视角单一，要学会多视角看问题，成为一台更好的“相机”，时刻做好向上升级、向下兼容的准备。</p><ul><li>勤移动。顾名思义，就是多移动你的“相机”机位，尝试用不同的视角看问题。</li><li>善学习。有时候看不到一些角度，是因为自身学识不够。</li><li>要开放。很多人情绪不好，是因为把自己做的假设当了事实，在不确定对方真实想法的情况下，直接把情绪发泄了出来。</li><li>寻帮助。主动寻求外部帮助，借助他人的多维视角来克服自己单一视角的局限。</li><li>多运动。适当有氧运动会提升体内多巴胺的水平，而多巴胺对于创造力和多角度思考能力来说都很重要。</li><li>常反思。无论什么时候，你的笔或键盘都能帮你跳出单一视角，看到更多维度。</li></ul><p>最后作者提到事情都有它的两面性，不要总盯着消极的一面，让其束缚了情绪和注意力，要多看到积极的部分。这个世界的模样取决于我们看待它的角度，毕竟人是一种自我解释的动物，世界的意义是人类赋予的。</p><p>这一章的内容对我帮助不大，而且有些部分偏离了主题，可能书写到最后难免有点摸鱼吧。</p><h3 id="八、早冥读写跑，人生五件套">八、早冥读写跑，人生五件套</h3><p>首先是早起。作者引用了日本作家中岛孝志的《4点起床：最养生和高效的时间管理》中的四个观点，并表示正是这四个观点，让作者无痛踏上了早起之旅。</p><ul><li>每天 4 点起床，把全天分成三段，{4，12}，{12，20}，{20，4}，第一个八小时用于完成过去的工作，第二个八小时用来铺垫未来的工作，第三个八小时用于休息，据说这本书的作者称这相当于多了一个工作日，并且睡眠时间没有减少，我绞尽脑汁掰脚趾也想不明白，这和 7 点起 12 点睡有什么区别。。。</li><li>有关睡眠的脑科学理论。健康的成年人睡觉时大多是 1.5 小时快速眼动睡眠、1.5 小时非快速眼动睡眠，两种模式不断切换，并且在最初的两个单位时间内，也就是睡着之后的前 3 小时中，会进行高质量的睡眠，之后则是浅层非快速眼动睡眠与快速眼动睡眠的组合。根据这一规律，人在睡眠后的 3 小时、4.5 小时、6 小时、7.5 小时这几个节点醒来，就会觉得神清气爽，精力充沛。</li><li>放弃闹钟。用这种粗暴的方式强迫自己早起是一种摧残，会带来痛苦的体验。</li><li>抓住大脑工作的高峰期。人体从黎明开始分泌肾上腺素和肾上腺皮质类脂醇这两种可以让人保持精力充沛的荷尔蒙，分泌高峰期正好是早上 7 点左右，这时人的工作效率非常高。人体进食后，能量也会在 1 小时后转变为葡萄糖，输送到大脑，人的记忆力、理解力就会提高，大脑的运转速度会迎来峰值，直至 4 小时后才降到谷底。所以人们要顺应规律，抓住效率高峰期，把最困难的工作放在这个时间段完成，就能达到事半功倍的效果。</li></ul><p>真正对我有的是第二条睡眠周期的理论，第一条的 4 点起床和第四条的 7 点工作对我来说不现实，也跟现代人的生活习惯格格不入，作者认为有道理可能是受职业影响。</p><p>早期的一些注意事项：</p><ul><li>初期会有一个相对痛苦的适应期。</li><li>循序渐进，难度匹配。</li><li>按状态起床。</li><li>中午需要午休一次。</li><li>不打扰他人。</li><li>提前准备。</li><li>明确遇到哪些情况时可以不早起。</li></ul><p>接着作者提到了冥想这一隐藏赛道，介绍了冥想的一系列好处，但并没有介绍方法，也不知效果如何，有时间我也试试。</p><p>再接着是阅读。想要快速成为一个行业的高手，最好的方法就是和行业专家交流，直接向他们请教，对于大多数普通人来说，这个捷径就是阅读。读书就是用最低廉的成本获取最高级的成长策略，这是所有人提升自己的最好途径。脚步不能丈量的地方，文字可以，眼睛无法看到的地方，文字可以。</p><p>阅读是一个技术活：</p><ul><li>读书要先学会选书。他人推荐的书单可以参考，但不要视其为唯一的选择标准。另外，还要选那些阅读难度刚好让自己处在舒适区边缘的书，一定要让兴趣、难度、需求三者尽可能匹配。</li><li>阅读是为了改变。真正读好一本书，往往需要花费数倍于阅读的时间去思考和实践，并输出自己的东西，可能是一篇文章，也可能是养成一个习惯，这个过程比阅读本身要费力得多。</li><li>高阶读书法。要特别注意自己在阅读时产生的关联，如果一个知识点让你想起了其他的知识，引发了关联，一定要留意，并把它记下来。另外，读写不分家，如果你在阅读后还能把所学知识用自己的语言重新阐释，甚至将它们教授给他人，那这个知识将在你脑中变得非常牢固。</li></ul><p>上述的高阶阅读法也引出了下一个主题，就是写作。作者提到了费曼学习法，核心是用自己的语言将学到的知识表述出来，而写作刚好是一个不错的输出媒介。除此之外本节没有其他亮点。</p><p>最后作者介绍了适当运动的必要性。时常运动的人，体内生态系统犹如一汪清泉，而久坐不动的人，体内生态系统则更像是一潭死水。运动能够使大脑长出更多的新的神经元，这意味着运动可以在物理上让人变得更聪明。</p><p>这一章没有太多的理论，作者纯纯的提供了几个方法来帮助读者改变。早、读、写是目前我在坚持的，冥想这个赛道略微有点高端，之后闲来无事可以试试。运动嘛，之前几乎每天都在做，健身、跑步、篮球，但是最近脚受伤了，需要养养。有点想重启健身了。</p><h2 id="结语">结语</h2><p>最后的结语部分作者介绍了自己先前的经历和写这本书的起因。作者保持记录日程的习惯长达十年，这个习惯对他来说也仅仅多了一个“记忆外挂”，提高了对时间的敏感度，但对生活的觉知并没有特别的与众不同。直到他读到成甲的《好好学习》一书，决定开始“每日反思”，对当前最触动自己的事情或感悟进行复盘，这个习惯让作者打开了一个全新的世界。</p><p>作者的方法很简单，就是留意每天生活中最触动自己的点。不管这个点是令人欣喜的感悟，还是令人难受的困惑，只要它在心头燃气火花，就把它摘取下来，记录到文档里复盘。而复盘的方式也极为简单，通常只需 3 点：</p><ul><li>描述经过。以便日后回顾时能想起当时的场景。</li><li>分析原因。多问几个为什么，直到有深度的启发。</li><li>改进措施。尽可能提炼出一个认知点或行动点。</li></ul><p>“每日反思”注意事项：</p><ul><li>不要被形式所缚。反思的最终目的是改变，而不是形式的完美，所以哪怕只有一句话，且这句话让自己发生了改变，那么反思的目的也就达到了。</li><li>尽量提炼认知点或行动点。不要沉溺于情绪释放或碎碎念，反思的最终目的是改变，所以要尽可能提炼出具体可操作的认知点和行动点，以指导未来的生活。</li><li>列行动清单。把最重要的行动点单列出来，时不时地看一眼，可以保证我们能持续地行动下去。</li><li>对自己极度坦诚。反思是给自己看的，所以不用在意别人的目光。尤其是在反思痛苦的时候，一定要对自己极度坦诚，把心底最真实的想法挖出来，承认它，并接纳它。</li><li>要多阅读。好的书籍充满高密度的思考，与智者交流，总会获得触动你的观点和信息。</li><li>选择合适的记录载体。作者不推荐纸质记录，觉得搜索不方便，我倒觉得纸质记录好一些，便于保存，而且还能练练字。</li></ul><h1>划重点</h1><div class="note note-primary">            <p>我们对自己的无知使自己看起来就像一个“醒着的睡着的人”。</p>          </div><div class="note note-secondary">            <p>人与人之间的根本差异是认知能力上的差异，认知影响选择，而选择改变命运，所以成长的本质就是让大脑的认知变得更加清晰。</p>          </div><div class="note note-success">            <p>理智脑对大脑的控制能力很弱，所以我们生活中做的大部分决策往往源于本能和情绪，而非理智。</p>          </div><div class="note note-danger">            <p>大多数时候我们以为自己在思考，其实都是在对自身的行为和欲望进行合理化，这正是人类被称作“自我解释的动物”的原因。</p>          </div><div class="note note-warning">            <p>成长就是克服天性的过程。</p>          </div><div class="note note-info">            <p>要想从既有的习惯中跳出来，最好的办法不是依靠自制力，而是依靠知识。</p>          </div><div class="note note-light">            <p>无论个体还是群体。人类的安全感都源于自己在某一方面拥有的独特优势，或能力，或财富，或权力，或影响力。</p>          </div><div class="note note-primary">            <p>王小波说：“人的一切痛苦，本质上都是对自己无能的愤怒。”</p>          </div><div class="note note-secondary">            <p>受苦比解决问题来的容易，承受不幸比享受幸福来的简单。</p>          </div><div class="note note-success">            <p>多数人为了逃避真正的思考，愿意做任何事情。</p>          </div><div class="note note-danger">            <p>心理催眠师在治疗时使用的一切手段其实都只为做成一件事：唤醒潜意识里的痛苦事件，让患者重新面对它，看清它，从而将其彻底化解。</p>          </div><div class="note note-warning">            <p>教育的意义就是教你在遇到一件事的时候如何看待它。当你对这件事进行反应的时候，总是有你自己的天性在里面。比如有人骂你，你就想骂回去，但是你在这个反应当中会有一个哪怕是零点几秒的间隔去思考或者审视，这个间隔就是你获得的教育或者经历的意义。</p>          </div><div class="note note-info">            <p>如果你想要的东西还不存在，那就亲自动手将它创造出来。</p>          </div><div class="note note-light">            <p>正确的行动往往是反天性的，让你觉得舒服和容易的事往往得不到好结果。</p>          </div><div class="note note-primary">            <p>人的能力分为知识、技能和才干三个层次：知识是最不具备迁移能力的，你成为医学博士，也照样有可能不会做麻婆豆腐；技能通常由 70% 的通用技能和 30% 的专业技能组成，迁移性要好一些；而到了才干层面，职业之间的界限就完全被打破了。</p>          </div><div class="note note-secondary">            <p>个人成长的目的已经不是“知道和理解”了，而是“判断与选择”。</p>          </div><div class="note note-success">            <p>如果给我一小时解答一道决定我生死的问题，我会在 55 分钟弄清楚这道题到底在问什么。一旦清楚它到底在问什么，剩下的 5 分钟足够回答这个问题。</p>          </div><h1>后记</h1><p>这本《认知觉醒》是我目前读过的最好的一本认知心理学的书，好的书籍可以让人陷入思考、引发触动、产生关联、最后发生改变。这本书中提到的几个认知规律和实践方法对我有很大的触动，也确确实实让我的生活发生了些许改变。</p><ul><li>首先是更觉知了。在了解了人类三重大脑的理论之后，对人类较动物的区别有了认识，时刻提醒自己是进化出了前额皮质的高等动物，要经常思考，不要让本能和情绪驱使自己做出错误决策，退化是万万不能接受的。</li><li>其次，我重新拾起了写日记的习惯，用写日记记录自己反思的结果。其实在 22 年初写日记的习惯我是一直在坚持，之后工作忙就给断了，虽然时间不长，但也带给我很多。写日记可以让我沉下心来思考生活、反思经历，而不是每天只在写代码上面消耗脑细胞。这次我在每天记日记的同时，会安排第二天的日程，写在日记背面，这样做的一个好处是可以提前一晚思考和规划第二天的详细日程，而不至于过的毫无计划，另一个好处就是，它间接监督了我的早起，因为总要为前一天晚上吹出去的牛逼收场。由于有了早起习惯的加持，我在电吉他上的学习时间也多了起来，长时间不练琴的负罪感曾经折磨我很久，现在也烟消云散了。在练习的内容上，我遵循了作者的“舒适区边缘”的原则，在学习乐理知识方面要求自己多做笔记，以未来要教授的心态学习知识。放弃看六线谱，甚至不看谱子，只听音频来扒乐句，唱下来，再用五线谱记录下来与原谱比较，这也是我从好多电吉他大师的视频里总结出的终极必杀技。</li><li>最后是更专注。在工作中我使用了番茄工作法，将每天的目标拆分，平均分配到上午和下午的每个番茄时钟里，每个番茄时钟只做这一件事情，只向着这一个目标，工作效率大大提升。在平时生活中，也时刻提醒自己多思考，多专注，两眼时不时的往里看向自己的前额，这是自己区别于动物的大脑区域，可得好好利用。还记得和尚得道后的那句话吗：砍柴即砍柴，担水即担水，做饭即做饭。</li></ul><p>克服天性，成长的底层逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>认知心理学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 实现简单的异常捕获和堆栈解析</title>
    <link href="/2022/08/07/iOS-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%92%8C%E5%A0%86%E6%A0%88%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/08/07/iOS-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%92%8C%E5%A0%86%E6%A0%88%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>这两周的一个需求，给引擎添加 crash 捕获和上传功能。如果正常一个 iOS App 需要添加 crash 捕获，一般会接入 Bugly 这种一体化 crash 分析平台，或者如果有自己的后台来搜集 crash 日志，也可以使用 KSCrash 或 PLCrashReporter 来实现崩溃日志的捕获。但本身作为一个引擎 SDK 来说，还是要尽可能少的接入三方库，即使是开源的。好在需求仅要求记录崩溃的大体堆栈信息，地址可解析即可，不需要太复杂的逻辑。</p><h1>Crash 的分类和处理顺序</h1><p>根据 Crash 的不同来源，一般分为 Mach 异常、Unix 信号 和 NSException。Mach 异常也称内核级异常，可以通过创建监控线程的方式监听 Mach 异常并处理异常信息，如果开发者没有捕获 Mach 异常，则异常将被转换为对应的 Unix 信号投递到出错线程。NSException 也称为应用级异常，可以通过 try catch 来捕获，也可以通过 NSSetUncaughtExceptionHandler 机制来捕获，最终未被处理的 NSException 会向自身程序发送 SIGABRT 信号使程序崩溃。三种异常处理的顺序可以参考这张图：</p><p><img src="/resources/image/5219632-04e43775dfba56f8.webp" alt="异常处理的顺序"></p><h1>实现方式</h1><p>Mach 异常 和 Unix 信号由于来源都是底层内核级异常，只是回调方式不同，因此在项目中选择监听 Unix 信号。应用级异常 NSException 是需要监听的，捕获的 exception 中有对排查问题很有帮助的 reason 信息，需要将这部分信息保存起来，再将 crash 信息传递给 Mach 和 Unix 层来捕获。</p><h1>代码</h1><h2 id="捕获-NSException">捕获 NSException</h2><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-type">void</span> IPhoneCrashHandler::initNSExceptionHandler() &#123;<br>    <span class="hljs-keyword">if</span> (sPreviousUncaughtExceptionHandler == nullptr) &#123;<br>        <span class="hljs-comment">// hold origin handler</span><br>        sPreviousUncaughtExceptionHandler = <span class="hljs-built_in">NSGetUncaughtExceptionHandler</span>();<br>    &#125;<br>    <span class="hljs-comment">// setup new handler</span><br>    <span class="hljs-built_in">NSSetUncaughtExceptionHandler</span>(&amp;uncaughtNSExceptionHandler);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化监听只需要调用 <code>NSSetUncaughtExceptionHandler</code> 传入回调函数指针即可，函数签名是 <code>typedef void NSUncaughtExceptionHandler(NSException *exception);</code> ，需要注意的是这个回调函数在 App 生命周期是唯一的，也就是说如果 App 有其他 crash 捕获模块，可能会有冲突。为了避免多个 crash 捕获失效的问题，需要先调用 <code>NSGetUncaughtExceptionHandler</code> 函数保存前任的函数指针，并在处理完 exception 之后主动调用这个函数传递 exception。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> uncaughtNSExceptionHandler(<span class="hljs-built_in">NSException</span> *exception) &#123;<br>    <span class="hljs-comment">// Handle current exception</span><br>    sUncaughtException = exception;<br>    <br>    <span class="hljs-comment">// Handle previous</span><br>    <span class="hljs-keyword">if</span> (sPreviousUncaughtExceptionHandler != nullptr) &#123;<br>        sPreviousUncaughtExceptionHandler(exception);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在回调函数里只需要保存保存 exception 指针，调用前任回调函数指针即可。NSException 如果没有被 try catch 或 NSSetUncaughtExceptionHandler 捕获处理，则会调用 c 的 abort()，kernal 针对 app 发出 _pthread_kill 的信号，转为 Mach 异常，如果 Mach 异常没有被捕获，则会转换成 Unix 信号。</p><h2 id="捕获-Unix-信号">捕获 Unix 信号</h2><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">const</span> uint8_t handledBSDSignals[] = &#123;<br>    SIGSEGV, <span class="hljs-comment">// signal   11  segmentation violation</span><br>    SIGABRT, <span class="hljs-comment">// signal   6   abort</span><br>    SIGFPE,     <span class="hljs-comment">// signal   8   floating-point exception</span><br>    SIGILL,     <span class="hljs-comment">// signal   4   illegal instruction</span><br>    SIGBUS,     <span class="hljs-comment">// signal   7   BUS</span><br>    SIGALRM     <span class="hljs-comment">// signal   14  alarm</span><br>&#125;;<br><br><span class="hljs-type">void</span> IPhoneCrashHandler::initBSDSignalHandler() &#123;<br>    <span class="hljs-keyword">struct</span> sigaction act;<br>    act.sa_flags = SA_SIGINFO;<br>    act.sa_sigaction = BSDSignalHandler;<br>    sigemptyset(&amp;act.sa_mask);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; handledBSDSignalsNum; ++i) &#123;<br>        sigaction(handledBSDSignals[i], &amp;act, &amp;sPreviousBSDSignalHandler[i]);<br>        sPreviousBSDSignalHandlerMap.insert( &#123; handledBSDSignals[i], &amp;sPreviousBSDSignalHandler[i] &#125; );<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>handledBSDSignals 数组是监听的 signal 列表，调用 sigaction 函数给 signal 设置监听函数 BSDSignalHandler，并将之前设置过的前任监听函数指针保存到 sPreviousBSDSignalHandler，在处理完 Unix 信号后要调用前任函数指针。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> BSDSignalHandler(<span class="hljs-type">int</span> sig, siginfo_t* siginfo, <span class="hljs-type">void</span>* ctx) &#123;<br>    <span class="hljs-comment">// Handle current signal</span><br>  <span class="hljs-comment">// 获取 Unix 信号描述</span><br>    <span class="hljs-built_in">NSString</span> *signal = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%d (%s)&quot;</span>, sig, getBSDSignalDescription(sig).data()];<br>  <span class="hljs-comment">// 如果 sUncaughtException 不为 nil，说明是 NSException 抛出的异常</span><br>    <span class="hljs-built_in">NSString</span> *exception = sUncaughtException ? [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@ (%@)&quot;</span>, [sUncaughtException name], [sUncaughtException reason]] : <span class="hljs-literal">nil</span>;<br>  <span class="hljs-comment">// 获取系统时间</span><br>    <span class="hljs-built_in">NSString</span> *timestamp = [<span class="hljs-built_in">NSString</span> stringWithCString:GetSystemTimeFormatString().data() encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>  <span class="hljs-comment">// 如果是 NSException 异常，则从 sUncaughtException 指针获取堆栈信息，否则从 NSThread 获取，并将堆栈信息格式化处理</span><br>    <span class="hljs-built_in">NSArray</span> *stackArray = formatCallbackSymbols(sUncaughtException ? sUncaughtException.callStackSymbols : <span class="hljs-built_in">NSThread</span>.callStackSymbols);<br>    <br>    <span class="hljs-built_in">NSMutableString</span> *content = [<span class="hljs-built_in">NSMutableString</span> string];<br>    [content appendFormat:<span class="hljs-string">@&quot;Pid: %d\n&quot;</span>, getpid()];<br>    [content appendFormat:<span class="hljs-string">@&quot;Signal: %@\n&quot;</span>, signal];<br>    <span class="hljs-keyword">if</span> (exception) [content appendFormat:<span class="hljs-string">@&quot;Exception: %@\n&quot;</span>, exception];<br>    [content appendFormat:<span class="hljs-string">@&quot;Timestamp: %@\n&quot;</span>, timestamp];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSString</span> *stack <span class="hljs-keyword">in</span> stackArray) &#123;<br>        [content appendFormat:<span class="hljs-string">@&quot;%@\n&quot;</span>, stack];<br>    &#125;<br>    <br>    <span class="hljs-built_in">NSString</span> *saveDir = [<span class="hljs-built_in">NSString</span> stringWithCString:IPhoneCrashHandler::GetInstance()-&gt;GetCrashLogFileSaveDir().data() encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>    <span class="hljs-built_in">NSString</span> *fileName = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@.crash&quot;</span>, timestamp];<br>    <span class="hljs-built_in">NSString</span> *filePath = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@%@&quot;</span>, saveDir, fileName];<br>    [content writeToFile:filePath atomically:<span class="hljs-literal">YES</span> encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span> error:<span class="hljs-literal">nil</span>];<br>    <br>    <span class="hljs-comment">// Handle previous</span><br>    <span class="hljs-keyword">struct</span> sigaction* previousSigaction = sPreviousBSDSignalHandlerMap[sig];<br>    <span class="hljs-keyword">if</span> (previousSigaction != nullptr &amp;&amp; previousSigaction-&gt;sa_sigaction != nullptr) &#123;<br>        previousSigaction-&gt;sa_sigaction(sig, siginfo, ctx);<br>    &#125;<br>    <br>    <span class="hljs-comment">// Kill with signal SIGKILL</span><br>    kill(getpid(), SIGKILL);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在 Unix 信号的监听函数中，首先可以拿到信号类型，并判断是否是 NSException 抛出的异常，将堆栈信息格式化后写入本地文件，最后调用前任回调函数指针，给程序发送 SIGKILL 信号终止程序。</p><h2 id="C-堆栈信息优化">C++ 堆栈信息优化</h2><p>调试过程中发现记录的 c++ 堆栈是经过 <a href="https://zhuanlan.zhihu.com/p/359466948">name mangling</a> 机制处理过的，写入到日志里可读性比较差，需要做 demangle 处理：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cxxabi.h&gt;</span></span><br>...<br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span>* getDemangledSymbol(<span class="hljs-built_in">NSString</span> *symbol) &#123;<br>    size_t maxLength = <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">int</span> demangleStatus;<br>    <span class="hljs-type">char</span>* demangledSymbol = (<span class="hljs-type">char</span>*)malloc(maxLength);<br>    <br>    <span class="hljs-keyword">if</span> ((demangledSymbol = abi::__cxa_demangle([symbol UTF8String],<br>                                               demangledSymbol,<br>                                               &amp;maxLength,<br>                                             &amp;demangleStatus))<br>        &amp;&amp; demangleStatus == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSString</span> stringWithCString:demangledSymbol encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="函数堆栈地址优化">函数堆栈地址优化</h2><p>通常在 crash 堆栈信息中会有一列是崩溃函数在虚拟内存空间的地址，如果是线上 Release 版本的 crash，日志里一般不会有详细的堆栈函数信息，需要通过程序打包时的符号表 dSYM 文件协助解析崩溃堆栈的地址。dSYM 中记录了程序中函数符号的内存地址，原理上来说 crash 堆栈里的崩溃函数地址应该与 dSYM 里的符号表是一一对应的，但由于苹果的 ASLR 机制的存在，程序在加载时会在前面插入一段随机的 offset，导致 crash 中的堆栈地址和 dSYM 的符号地址会有一个随机的差值。这个 offset 可以在程序运行时获取到，在捕获到 crash 后将堆栈地址减去 offset 保存到文件中，这样就可以直接使用 dSYM 解析出具体的符号。</p><blockquote><p>ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。据研究表明ASLR可以有效的降低缓冲区溢出攻击的成功率，如今Linux、FreeBSD、Windows等主流操作系统都已采用了该技术。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mach-o/dyld.h&gt;</span></span><br>...<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span> <span class="hljs-title">getOffsetOfASLR</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">uint64_t</span> offset = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; _dyld_image_count(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (_dyld_get_image_header(i)-&gt;filetype == MH_EXECUTE) &#123;<br>                offset = _dyld_get_image_vmaddr_slide(i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> offset;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以这条堆栈信息为例：</p><p><code>CrashStack[5]:&lt;0x0000000106487418&gt;  xxx (-[IPhoneBridgeObjc showWebView:]+10) </code></p><p>虽然已经知道它对应的符号，但还只是通过 dSYM 解析看下计算的地址是否正确，需要借助命令行工具 atos：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">atos -o xxx.app.dSYM/Contents/Resources/DWARF/xxx 0x0000000106487418<br>-[IPhoneBridgeObjc showWebView:] (in xxx) (IPhoneBridge.mm:313)<br></code></pre></div></td></tr></table></figure><h1>参考资料</h1><blockquote><p>iOS Crash/崩溃/异常 捕获 <a href="https://www.jianshu.com/p/3f6775c02257">https://www.jianshu.com/p/3f6775c02257</a></p><p>iOS Crash收集,符号化分析看我就够了 <a href="https://bucengyongyou.github.io/2016/08/03/iOS-Crash%E6%94%B6%E9%9B%86-%E7%AC%A6%E5%8F%B7%E5%8C%96%E5%88%86%E6%9E%90%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%E4%BA%86/">https://bucengyongyou.github.io/2016/08/03/iOS-Crash收集-符号化分析看我就够了/</a></p><p>C++函数重载的实现机制之name mangling <a href="https://zhuanlan.zhihu.com/p/359466948">https://zhuanlan.zhihu.com/p/359466948</a></p></blockquote><h1>后记</h1><p>最近状态有点差，周末在家就只想睡觉了，想学的东西很多，但时间少效率低，要好好调整下了。</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异常捕获</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 使用 AVAssetWriter 实时写入视频流</title>
    <link href="/2022/08/06/iOS-%E4%BD%BF%E7%94%A8-AVAssetWriter-%E5%AE%9E%E6%97%B6%E5%86%99%E5%85%A5%E8%A7%86%E9%A2%91%E6%B5%81/"/>
    <url>/2022/08/06/iOS-%E4%BD%BF%E7%94%A8-AVAssetWriter-%E5%AE%9E%E6%97%B6%E5%86%99%E5%85%A5%E8%A7%86%E9%A2%91%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>好久没写博客了，这段时间几乎所有的精力都用在适应新工作上了，今天难得有些时间可以把这段时间做的需求整理一下，记一记写一写，加深下记忆吧。这个需求是在渲染引擎里加入录屏功能，将引擎渲染的纹理和麦克风采集的声音写入到本地 mp4 文件。</p><h1>实现方法</h1><p>可以将视频、音频分开录制，AVAssetWriter 将底层引擎回调的 RGB 数据写成 mp4 文件，使用 VideoToolBox 录制一路音频 m4a 保存本地，然后使用 AVAssetExportSession 将音频视频合成。这种方式实现是肯定没问题的，但过程有些繁琐，并且音频视频被多次编解码，效率很低。</p><p>AVAssetWriter 是支持实时写入音频和视频的，唯一要费点心思的是音视频同步。音频的采集使用 AVCaptureSession，比较简单，接口回调的音频数据类型是 CMSampleBufferRef，其中包含了时间戳信息，这个时间戳并不是从 0 开始的，所以收到音频首帧时需要记录下时间戳作为视频帧时间戳的 base time，此后的视频帧在此 base time 基础上叠加系统时间差值即可。</p><h1>代码</h1><p>首先是 AVAssetWriter 的初始化，这里分成两种情况，如果用户没有授权麦克风权限，则只录制引擎的视频纹理，如果授权，则录制纹理和声音：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">BOOL</span>)setupAssetWriter:(RecorderSourceType)sourceType &#123;<br>    _sourceType = sourceType;<br>    <span class="hljs-built_in">NSError</span> *error;<br><br>  <span class="hljs-comment">// 如果录制文件已存在，先移除</span><br>    <span class="hljs-keyword">if</span> ([[<span class="hljs-built_in">NSFileManager</span> defaultManager] fileExistsAtPath:_outputFilePath]) &#123;<br>        [[<span class="hljs-built_in">NSFileManager</span> defaultManager] removeItemAtPath:_outputFilePath error:&amp;error];<br>        <span class="hljs-keyword">if</span> (error) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Remove item at outputFilePath failed: %@&quot;</span>, error.localizedDescription);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>        &#125;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 初始化 AVAssetWriter，指定封装格式为 AVFileTypeMPEG4</span><br>    _assetWriter = [[<span class="hljs-built_in">AVAssetWriter</span> alloc] initWithURL:[<span class="hljs-built_in">NSURL</span> fileURLWithPath:_outputFilePath] fileType:<span class="hljs-built_in">AVFileTypeMPEG4</span> error:&amp;error];<br>    <span class="hljs-keyword">if</span> (error) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;AVAssetWriter create failed: %@&quot;</span>, error.localizedDescription);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 初始化视频写入相关</span><br>    <span class="hljs-keyword">if</span> (sourceType &amp; RecorderSourceType_Video) &#123;<br>      <span class="hljs-comment">// 分辨率</span><br>        <span class="hljs-built_in">CGSize</span> outputSize = <span class="hljs-built_in">CGSizeMake</span>(GetWidth(), GetHeight());<br>      <span class="hljs-comment">// 单帧像素点个数</span><br>        <span class="hljs-built_in">NSInteger</span> numPixels = outputSize.width * outputSize.height;<br>      <span class="hljs-comment">// 码率因子</span><br>        <span class="hljs-built_in">CGFloat</span> bitrateFactorPerPixel = <span class="hljs-number">3.0</span>;<br>      <span class="hljs-comment">// 估算一个码率</span><br>        <span class="hljs-built_in">NSInteger</span> bitrate = numPixels * bitrateFactorPerPixel;<br>      <span class="hljs-comment">// 帧率</span><br>        <span class="hljs-built_in">NSInteger</span> fps = <span class="hljs-number">30</span>;<br>      <span class="hljs-comment">// 关键帧间隔</span><br>        <span class="hljs-built_in">NSInteger</span> keyFrameInterval = fps * <span class="hljs-number">3</span>;<br>        <br>        <span class="hljs-built_in">NSDictionary</span> *videoCompressionProperties = @&#123;<span class="hljs-built_in">AVVideoAverageBitRateKey</span> : @(bitrate),<br>                                                     <span class="hljs-built_in">AVVideoExpectedSourceFrameRateKey</span> : @(fps),<br>                                                     <span class="hljs-built_in">AVVideoMaxKeyFrameIntervalKey</span> : @(keyFrameInterval),<br>                                                     <span class="hljs-built_in">AVVideoProfileLevelKey</span> : <span class="hljs-built_in">AVVideoProfileLevelH264BaselineAutoLevel</span>&#125;;<br>        <br>        <span class="hljs-built_in">NSDictionary</span> *videoCompressionSettings = @&#123;<span class="hljs-built_in">AVVideoCodecKey</span> : <span class="hljs-built_in">AVVideoCodecTypeH264</span>,<br>                                                   <span class="hljs-built_in">AVVideoScalingModeKey</span> : <span class="hljs-built_in">AVVideoScalingModeResizeAspectFill</span>,<br>                                                   <span class="hljs-built_in">AVVideoWidthKey</span>  : @(outputSize.width),<br>                                                   <span class="hljs-built_in">AVVideoHeightKey</span> : @(outputSize.height),<br>                                                   <span class="hljs-built_in">AVVideoCompressionPropertiesKey</span> : videoCompressionProperties&#125;;<br>        <br>        <span class="hljs-keyword">if</span> ([_assetWriter canApplyOutputSettings:videoCompressionSettings forMediaType:<span class="hljs-built_in">AVMediaTypeVideo</span>]) &#123;、<br>          <span class="hljs-comment">// 创建 AVAssetWriterInput</span><br>            _videoInput = [<span class="hljs-built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="hljs-built_in">AVMediaTypeVideo</span> outputSettings:videoCompressionSettings];<br>            _videoInput.expectsMediaDataInRealTime = <span class="hljs-literal">YES</span>;<br>            <br>            <span class="hljs-built_in">NSDictionary</span> *sourcePixelBufferAttributes = @&#123;(<span class="hljs-built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_32BGRA),<br>                                                          (<span class="hljs-built_in">NSString</span> *)kCVPixelBufferWidthKey: @(outputSize.width),<br>                                                          (<span class="hljs-built_in">NSString</span> *)kCVPixelBufferHeightKey: @(outputSize.height)&#125;;<br>            <span class="hljs-comment">// 创建 AVAssetWriterInputPixelBufferAdaptor</span><br>            _videoAdaptor = [<span class="hljs-built_in">AVAssetWriterInputPixelBufferAdaptor</span> assetWriterInputPixelBufferAdaptorWithAssetWriterInput:_videoInput sourcePixelBufferAttributes:sourcePixelBufferAttributes];<br>       <br>            <span class="hljs-comment">// AVAssetWriter 添加视频输入                                                                                               </span><br>            <span class="hljs-keyword">if</span> ([_assetWriter canAddInput:_videoInput]) &#123;<br>                [_assetWriter addInput:_videoInput];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 初始化音频写入相关</span><br>    <span class="hljs-keyword">if</span> (sourceType &amp; RecorderSourceType_Audio) &#123;<br>      <span class="hljs-comment">// 采样率</span><br>        <span class="hljs-built_in">NSInteger</span> sampleRate = <span class="hljs-number">48000</span>;<br>      <span class="hljs-comment">// 通道数</span><br>        <span class="hljs-built_in">NSInteger</span> channelCount = <span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 码率</span><br>        <span class="hljs-built_in">NSInteger</span> bitrate = <span class="hljs-number">64000</span>;<br>      <span class="hljs-comment">// 位深</span><br>        <span class="hljs-built_in">NSInteger</span> bitDepth = <span class="hljs-number">16</span>;<br>        <br>        <span class="hljs-built_in">NSDictionary</span> *audioCompressionSettings = @&#123;<span class="hljs-built_in">AVFormatIDKey</span> : @(kAudioFormatMPEG4AAC),<br>                                                   <span class="hljs-built_in">AVEncoderBitRatePerChannelKey</span> : @(bitrate),<br>                                                   <span class="hljs-built_in">AVSampleRateKey</span> : @(sampleRate),<br>                                                   <span class="hljs-built_in">AVNumberOfChannelsKey</span> : @(channelCount)&#125;;<br>        <br>        <span class="hljs-keyword">if</span> ([_assetWriter canApplyOutputSettings:audioCompressionSettings forMediaType:<span class="hljs-built_in">AVMediaTypeAudio</span>]) &#123;<br>          <span class="hljs-comment">// 创建 AVAssetWriterInput</span><br>            _audioInput = [<span class="hljs-built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="hljs-built_in">AVMediaTypeAudio</span> outputSettings:audioCompressionSettings];<br>            _audioInput.expectsMediaDataInRealTime = <span class="hljs-literal">YES</span>;<br>            <br>          <span class="hljs-comment">// AVAssetWriter 添加音频输入</span><br>            <span class="hljs-keyword">if</span> ([_assetWriter canAddInput:_audioInput]) &#123;<br>                [_assetWriter addInput:_audioInput];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以上代码初始化 AVAssetWriter 并根据不同场景配置了音频和视频的输入，如果是授权了麦克风权限，还需要初始化 AVCaptureSession：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">BOOL</span>)setupAudioRecorder &#123;<br>    <span class="hljs-built_in">NSError</span> *error;<br>    [[<span class="hljs-built_in">AVAudioSession</span> sharedInstance] setCategory:<span class="hljs-built_in">AVAudioSessionCategoryPlayAndRecord</span> error:&amp;error];<br>    [[<span class="hljs-built_in">AVAudioSession</span> sharedInstance] setActive:<span class="hljs-literal">YES</span> error:&amp;error];<br>    <span class="hljs-keyword">if</span> (error) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;AVAudioSession set category &amp; action error: %@&quot;</span>, error.localizedDescription);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>    _audioBufferQueue = dispatch_queue_create(<span class="hljs-string">&quot;com.audioBuffer.IPhoneScreenRecorder&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    _captureSession = [[<span class="hljs-built_in">AVCaptureSession</span> alloc] init];<br>    <span class="hljs-built_in">AVCaptureDevice</span> *audioDevice = [<span class="hljs-built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="hljs-built_in">AVMediaTypeAudio</span>];<br>    _audioDeviceInput = [<span class="hljs-built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:audioDevice error:&amp;error];<br>    <span class="hljs-keyword">if</span> (error) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;AVCaptureDeviceInput create failed: %@&quot;</span>, error.localizedDescription);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    _audioDataOutput = [[<span class="hljs-built_in">AVCaptureAudioDataOutput</span> alloc] init];<br>    [_audioDataOutput setSampleBufferDelegate:<span class="hljs-keyword">self</span> queue:_audioBufferQueue];<br>    <br>    <span class="hljs-keyword">if</span> ([_captureSession canAddInput:_audioDeviceInput]) &#123;<br>        [_captureSession addInput:_audioDeviceInput];<br>    &#125;<br>    <span class="hljs-keyword">if</span> ([_captureSession canAddOutput:_audioDataOutput]) &#123;<br>        [_captureSession addOutput:_audioDataOutput];<br>    &#125;<br>    <br>    [_captureSession startRunning];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化完成后，需要处理开始写入的时机和音视频时间戳的同步，processVideoBuffer 方法是引擎回调纹理数据的接口，这里同样也分两种场景来处理：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)processVideoBuffer:(<span class="hljs-type">void</span> *)data width:(<span class="hljs-type">int</span>)width height:(<span class="hljs-type">int</span>)height &#123;<br>    <span class="hljs-keyword">if</span> (!_isRecording) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (!_canWrite) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dispatch_async</span>(_operationQueue, ^&#123;<br>        <span class="hljs-keyword">if</span> (_sourceType &amp; RecorderSourceType_Audio) &#123;<br>            <span class="hljs-keyword">if</span> (_timeBase == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// Need to wait for the audio buffer callback to update the timebase</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <br>            TimeFormat currentTimeStamp = GetTimeStampOffset(_timeBase) + _timeBase;<br>            <span class="hljs-built_in">CMTime</span> pts = <span class="hljs-built_in">CMTimeMake</span>(currentTimeStamp, <span class="hljs-number">1000</span>);<br>            CVPixelBufferRef pixelBuffer = CreatePixelBuffer(data, width, height);<br>            <span class="hljs-keyword">if</span> (pixelBuffer == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br><br>            [<span class="hljs-keyword">self</span> appendVideoPixelBuffer:pixelBuffer pts:pts];<br>            <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (_timeBase == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// Update timebase（ms）</span><br>                _timeBase = GetTimeStampInMS();<br>                <span class="hljs-comment">// Start asset writer</span><br>                [_assetWriter startWriting];<br>              <span class="hljs-comment">// 视频帧的时间戳基数是从 0 开始的，所以这里是 kCMTimeZero</span><br>                [_assetWriter startSessionAtSourceTime:kCMTimeZero];<br>            &#125;<br>            <br>            TimeFormat currentTimeStamp = GetTimeStampOffset(_timeBase);<br>            <span class="hljs-built_in">CMTime</span> pts = <span class="hljs-built_in">CMTimeMake</span>(currentTimeStamp, <span class="hljs-number">1000</span>);<br>            CVPixelBufferRef pixelBuffer = CreatePixelBuffer(data, width, height);<br>            <span class="hljs-keyword">if</span> (pixelBuffer == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br><br>            [<span class="hljs-keyword">self</span> appendVideoPixelBuffer:pixelBuffer pts:pts];<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果只录制视频，就不需要考虑时间戳对齐，在 AVAssetWriter 初始化完成后的第一帧即可记录时间基并开始写入。如果需要写入音频，就要保证音视频的时间基是相同的。既然音频回调的 CMSampleBufferRef 里有时间戳信息，那不如就用第一帧音频的时间戳作为视频的时间基，此后依次叠加系统时间的差值即可，所以这里 _timeBase 如果是 0，需要等待第一帧音频帧的到来，再看下音频帧回调里的处理：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - <span class="hljs-string">&lt;AVCaptureAudioDataOutputSampleBufferDelegate&gt;</span></span><br>- (<span class="hljs-type">void</span>)captureOutput:(<span class="hljs-built_in">AVCaptureOutput</span> *)output didOutputSampleBuffer:(<span class="hljs-built_in">CMSampleBufferRef</span>)sampleBuffer fromConnection:(<span class="hljs-built_in">AVCaptureConnection</span> *)connection &#123;<br>    <span class="hljs-keyword">if</span> (!_canWrite) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dispatch_sync</span>(_operationQueue, ^&#123;<br>        <span class="hljs-keyword">if</span> (_timeBase == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">CMTime</span> pts = <span class="hljs-built_in">CMSampleBufferGetPresentationTimeStamp</span>(sampleBuffer);<br>            <span class="hljs-comment">// Update time base</span><br>            _timeBase = (TimeFormat)(<span class="hljs-built_in">CMTimeGetSeconds</span>(pts) * <span class="hljs-number">1000</span>);<br>            <span class="hljs-comment">// Start asset writer</span><br>            [_assetWriter startWriting];<br>            [_assetWriter startSessionAtSourceTime:<span class="hljs-built_in">CMSampleBufferGetPresentationTimeStamp</span>(sampleBuffer)];<br>        &#125;<br>        [<span class="hljs-keyword">self</span> appendAudioSampleBuffer:sampleBuffer];<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在 AVAssetWriter 初始化完成后，收到的音频首帧里包含的时间戳会作为时间基赋值给 _timeBase，并开始 AVAssetWriter 的写入任务，startSessionAtSourceTime 要传入第一帧音频的时间戳信息。processVideoBuffer 方法中视频帧也会基于音频首帧的时间戳来写入，这样就实现了一个简单的，比较粗略的时间戳同步。</p><p>最后是音频和视频 buffer 的写入：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)appendVideoPixelBuffer:(CVPixelBufferRef)pixelBuffer pts:(<span class="hljs-built_in">CMTime</span>)pts &#123;<br>    <span class="hljs-keyword">if</span> (!_isRecording || _assetWriter.status != <span class="hljs-built_in">AVAssetWriterStatusWriting</span>) &#123;<br>        <span class="hljs-built_in">CFRelease</span>(pixelBuffer);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(_writingQueue, ^&#123;<br>        <span class="hljs-built_in">AVAssetWriterInput</span> *input = _videoInput;<br>        <span class="hljs-keyword">if</span> (input.readyForMoreMediaData) &#123;<br>            <span class="hljs-type">BOOL</span> success = [_videoAdaptor appendPixelBuffer:pixelBuffer withPresentationTime:pts];<br>            <span class="hljs-keyword">if</span> (!success) &#123;<br>                [<span class="hljs-keyword">self</span> stopRecordingWithCompletion:<span class="hljs-literal">nil</span>];<br>                <span class="hljs-built_in">NSError</span> *error = _assetWriter.error;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;AVAssetWriterInputPixelBufferAdaptor appendPixelBuffer failed with error: %@&quot;</span>, error.localizedDescription);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">NSLog</span>( <span class="hljs-string">@&quot;Video input not ready for more media data, dropping buffer&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">CFRelease</span>(pixelBuffer);<br>    &#125;);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)appendAudioSampleBuffer:(<span class="hljs-built_in">CMSampleBufferRef</span>)sampleBuffer &#123;<br>    <span class="hljs-keyword">if</span> (!_isRecording || _assetWriter.status != <span class="hljs-built_in">AVAssetWriterStatusWriting</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">CFRetain</span>(sampleBuffer);<br>    <span class="hljs-built_in">dispatch_async</span>(_writingQueue, ^&#123;<br>        <span class="hljs-keyword">if</span> (_audioInput.readyForMoreMediaData) &#123;<br>            <span class="hljs-type">BOOL</span> success = [_audioInput appendSampleBuffer:sampleBuffer];<br>            <span class="hljs-keyword">if</span> (!success) &#123;<br>                [<span class="hljs-keyword">self</span> stopRecordingWithCompletion:<span class="hljs-literal">nil</span>];<br>                <span class="hljs-built_in">NSError</span> *error = _assetWriter.error;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;AVAssetWriterInput appendSampleBuffer failed with error: %@&quot;</span>, error.localizedDescription);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">NSLog</span>( <span class="hljs-string">@&quot;Audio input not ready for more media data, dropping buffer&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">CFRelease</span>(sampleBuffer);<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在写入视频帧时，起初跟音频一样，也是使用 AVAssetWriterInput 的 appendSampleBuffer 来写入，但发现一直写入失败，苹果的报错只是说 unknown error，没有给出具体原因，之后在 Stack Overflow 上看有人遇到同样的问题，改用 AVAssetWriterInputPixelBufferAdaptor 写入 CVPixelBufferRef 可以解决，亲测是有效的，但具体原因就没有深究了。</p><h1>参考资料</h1><p>主要是苹果的接口文档了，还有一个网上找的 AVFoundation 的使用 Demo 用来参考：<a href="https://github.com/geniusZhangXu/AVFoundation">Demo</a></p><h1>后记</h1><p>现在是 23:26 分，本来想着再写一篇关于 crash 处理的，好像时间有点晚了，还有日记要写，就留到明天吧。</p>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVFoundation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmake 基础使用</title>
    <link href="/2022/07/09/cmake-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/09/cmake-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>本文是一篇学习 cmake 的笔记，主要内容来自 cmake 官网的 <a href="https://cmake.org/cmake/help/latest/guide/tutorial/">教程</a>。</p><h1>环境配置</h1><p>Mac 环境下推荐使用 brew 安装 cmake：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">brew install cmake<br></code></pre></div></td></tr></table></figure><h1>cmake 使用</h1><h2 id="step-1-一个基础的入门小例子">step 1 一个基础的入门小例子</h2><h3 id="编译和运行">编译和运行</h3><p>首先创建一个项目文件夹 tutorial：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">mkdir tutorial &amp;&amp; cd tutorial<br></code></pre></div></td></tr></table></figure><p>在当前目前目录创建源代码文件 tutorial.cxx，提供 main 函数调用系统 sqrt 函数计算平方根，具体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// A simple program that computes the square root of a number</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; number&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// convert input to double</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">double</span> inputValue = atof(argv[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-comment">// calculate square root</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">double</span> outputValue = <span class="hljs-built_in">sqrt</span>(inputValue);<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The square root of &quot;</span> &lt;&lt; inputValue &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; outputValue<br>            &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用 cmake 的核心是要编写 CMakeLists.txt 文件，所以在当前目录创建 CMakeLists.txt，输入以下三行内容：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cmake_minimum_required(VERSION 3.10)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">set</span> the project name</span><br>project(Tutorial)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">add the executable</span><br>add_executable(Tutorial tutorial.cxx)<br></code></pre></div></td></tr></table></figure><p>这三行代码使用的是小写风格，大写、小写和大小写混合对 cmake 来说都是支持的。</p><ul><li><p>cmake_minimum_required() 指定使用 cmake 的最小版本。</p></li><li><p>project() 设置项目名称。</p></li><li><p>add_executable() 将资源编译成可执行文件。</p></li></ul><p>为了将 cmake 编译产生的临时文件和源代码文件分开，在当前目录下创建一个 build 文件夹存放编译结果：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">mkdir build &amp;&amp; cd build<br></code></pre></div></td></tr></table></figure><p>在 build 目录下执行 cmake，这一步是 cmake 根据当前环境生成 Makefile：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cmake ..<br></code></pre></div></td></tr></table></figure><p>执行后的目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">.<br>├── CMakeLists.txt<br>├── build<br>│   ├── CMakeCache.txt<br>│   ├── CMakeFiles<br>│   ├── Makefile<br>│   └── cmake_install.cmake<br>└── tutorial.cxx<br></code></pre></div></td></tr></table></figure><p>有了 Makefile，接下来可以执行编译和链接了：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cmake --build .<br></code></pre></div></td></tr></table></figure><p>或者直接使用 make：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">make<br></code></pre></div></td></tr></table></figure><p>执行完成后，当前 build 目录下生成了可执行文件 Tutorial，运行 Tutorial 并传入参数，控制台输出了预期的结果：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./Tutorial 16<br>The square root of 16 is 4<br></code></pre></div></td></tr></table></figure><h3 id="添加版本号和配置头文件">添加版本号和配置头文件</h3><p>项目的版本号一般可以定义在源代码中，但使用 CMakeLists.txt 会更灵活一些，首先修改 CMakeLists.txt 文件使用 project() 命令设置项目名称和版本号：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cmake_minimum_required(VERSION 3.10)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">set</span> the project name and version</span><br>project(Tutorial VERSION 1.0)<br></code></pre></div></td></tr></table></figure><p>然后使用 configure_file 命令将 cmake 配置转换成 .h 文件：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">configure_file(TutorialConfig.h.in TutorialConfig.h)<br></code></pre></div></td></tr></table></figure><p>转换后的 .h 文件会被保存到可执行文件所在目录，为了使用它，需要将路径添加到索引目录中：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">target_include_directories(Tutorial PUBLIC<br>                           &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;<br>                           )<br></code></pre></div></td></tr></table></figure><p>关键字 PUBLIC 的作用参考 <a href="https://zhuanlan.zhihu.com/p/82244559">这里</a>。PROJECT_BINARY_DIR 是 cmake 内置的一个宏定义，一般常用的有两个 PROJECT_SOURCE_DIR 和 PROJECT_BINARY_DIR。PROJECT_SOURCE_DIR 表示项目源文件所在目录，即根目录，PROJECT_BINARY_DIR 表示编译输出的二进制文件所在目录，即当前项目的 build 目录。</p><p>接下来需要提供 cmake 用于转换 .h 的模板文件，在项目的根目录下创建 <a href="http://TutorialConfig.h.in">TutorialConfig.h.in</a>，并输入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">// the configured options and settings for Tutorial<br><span class="hljs-meta prompt_">#</span><span class="language-bash">define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span><br></code></pre></div></td></tr></table></figure><p>最后一步，在 tutorial.cxx 中添加这两个宏的打印，查看是否生效：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">...<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// report version</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; Version &quot;</span> &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; <span class="hljs-string">&quot;.&quot;</span><br>              &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; number&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>...<br></code></pre></div></td></tr></table></figure><p>重新回到 build 文件夹执行 cmake 命令，可以看到控制台输出了在 CMakeLists.txt 中配置的版本信息：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./Tutorial<br>./Tutorial Version 1.0<br>Usage: ./Tutorial number<br></code></pre></div></td></tr></table></figure><p>我们对这个过程做下分析：</p><p>首先在 CMakeLists.txt 配置 VERSION 1.0 后，cmake 会以版本号的小数点为边界生成两个宏定义，即 Tutorial_VERSION_MAJOR = 1、Tutorial_VERSION_MINOR = 0，在执行 configure 时，cmake 将 <a href="http://TutorialConfig.h.in">TutorialConfig.h.in</a> 中的 @Tutorial_VERSION_MAJOR@ 和 @Tutorial_VERSION_MINOR@ 替换成具体的值并生成 TutorialConfig.h 保存在 build 目录下，我们的源文件中引入 TutorialConfig.h，在预编译时 Tutorial_VERSION_MAJOR 和 Tutorial_VERSION_MINOR 被替换成具体的数值，在运行时被打印出来。</p><h3 id="定义-C-标准">定义 C++ 标准</h3><p>现在让我们给源代码添加一些 C++11 的特性，使用 <code>std::stod</code> 替换 ‘atof’，同时，需要移除 <code>#include &lt;cstdlib&gt;</code>：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">double</span> inputValue = <span class="hljs-built_in">std</span>::stod(argv[<span class="hljs-number">1</span>]);<br></code></pre></div></td></tr></table></figure><p>接着在 CMakeLists.txt 中定义 C++ 标准：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">specify the C++ standard</span><br>set(CMAKE_CXX_STANDARD 11)<br>set(CMAKE_CXX_STANDARD_REQUIRED True)<br></code></pre></div></td></tr></table></figure><div class="note note-warning">            <p>注意：需要保证 CMAKE_CXX_STANDARD 的声明在 add_executable()  执行之前。</p>          </div><p>重新执行 cmake 并运行可执行程序，控制台输出预期结果：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./Tutorial 16<br>The square root of 16 is 4<br></code></pre></div></td></tr></table></figure><h2 id="step-2-尝试链接一个库">step 2 尝试链接一个库</h2><p>现在尝试给程序链接一个库，这个库包含我们自定义的计算平方根的函数，可执行程序用这个自定义函数替换系统函数。</p><p>首先在根目录下创建 MathFunctions 存放库的头文件 MathFunctions.h 和源文件 mysqrt.cxx，源文件中有一个函数 mysqrt 提供计算平方根的功能。</p><p>MathFunctions.h：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">mysqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br></code></pre></div></td></tr></table></figure><p>mysqrt.cxx:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MathFunctions.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// a hack square root calculation using simple operations</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">mysqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-type">double</span> result;<br>  <span class="hljs-type">double</span> delta;<br>  result = x;<br><br>  <span class="hljs-comment">// do ten iterations</span><br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (result &lt;= <span class="hljs-number">0</span>) &#123;<br>      result = <span class="hljs-number">0.1</span>;<br>    &#125;<br>    delta = x - (result * result);<br>    result = result + <span class="hljs-number">0.5</span> * delta / result;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;Computing sqrt of %g to be %g\n&quot;</span>, x, result);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在 MathFunctions 目录创建 CMakeLists.txt，并输入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">add_library(MathFunctions mysqrt.cxx)<br></code></pre></div></td></tr></table></figure><p>add_library() 命令用于将源文件编译成库文件，此例中是将 mysqrt.cxx 编译成 libMathFunctions.a 文件。</p><p>接下来需要在根目录的 CMakeLists.txt 添加 MathFunctions 的子目录，并添加库函数头文件的索引：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">add the MathFunctions library</span><br>add_subdirectory(MathFunctions)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">add the executable</span><br>add_executable(Tutorial tutorial.cxx)<br><br>target_link_libraries(Tutorial PUBLIC MathFunctions)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">add the binary tree to the search path <span class="hljs-keyword">for</span> include files</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">so that we will find TutorialConfig.h</span><br>target_include_directories(Tutorial PUBLIC<br>                          &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;<br>                          &quot;$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions&quot;<br>                          )<br></code></pre></div></td></tr></table></figure><ul><li>add_subdirectory() 用于执行子目录的 CMakeLists.txt</li><li>target_link_libraries() 用于链接库文件</li><li>target_include_directories() 将库文件的头文件索引添加进来</li></ul><p>最后在 tutorial.cxx 中引入 MathFunctions.h 的头文件，并将系统函数 sqrt() 替换成自定义的 mysqrt()：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// A simple program that computes the square root of a number</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-comment">// #include &lt;cstdlib&gt;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TutorialConfig.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MathFunctions.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// report version</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; Version &quot;</span> &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; <span class="hljs-string">&quot;.&quot;</span><br>              &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; number&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// convert input to double</span><br>  <span class="hljs-comment">// const double inputValue = atof(argv[1]);</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">double</span> inputValue = <span class="hljs-built_in">std</span>::stod(argv[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-comment">// calculate square root</span><br>  <span class="hljs-comment">// const double outputValue = sqrt(inputValue);</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">double</span> outputValue = mysqrt(inputValue);<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The square root of &quot;</span> &lt;&lt; inputValue &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; outputValue<br>            &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>cmake 重新编译后执行 Tutorial 程序，控制台输出显示成功调用了自定义的库函数：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./Tutorial 16<br>Computing sqrt of 16 to be 8.5<br>Computing sqrt of 16 to be 5.19118<br>Computing sqrt of 16 to be 4.13666<br>Computing sqrt of 16 to be 4.00226<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>The square root of 16 is 4<br></code></pre></div></td></tr></table></figure><p>现在我们通过 cmake 的一个 option 配置来决定是否编译链接 MathFunctions 库，首先在根目录的 CMakeLists.txt 中添加 option 命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">option(USE_MYMATH &quot;Use tutorial provided math implementation&quot; ON)<br></code></pre></div></td></tr></table></figure><p>接下来使用 if 判断 USE_MYMATH 如果是打开状态，则编译并链接 MathFunctions：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">if(USE_MYMATH)<br>  add_subdirectory(MathFunctions)<br>  list(APPEND EXTRA_LIBS MathFunctions)<br>  list(APPEND EXTRA_INCLUDES &quot;$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions&quot;)<br>endif()<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">add the executable</span><br>add_executable(Tutorial tutorial.cxx)<br><br>target_link_libraries(Tutorial PUBLIC $&#123;EXTRA_LIBS&#125;)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">add the binary tree to the search path <span class="hljs-keyword">for</span> include files</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">so that we will find TutorialConfig.h</span><br>target_include_directories(Tutorial PUBLIC<br>                           &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;<br>                           $&#123;EXTRA_INCLUDES&#125;<br>                           )<br></code></pre></div></td></tr></table></figure><p>list(APPEND …) 命令用于将新的 element 添加到 list 中，我们定义两个 list 变量 EXTRA_LIBS 和 EXTRA_INCLUDES 分别用于存放链接库和库的头文件索引路径，之后使用 target_link_libraries() 和 target_include_directories() 传入这两个变量即可链接库文件和库的头文件。</p><p>OK目前到这里，我们已经在 cmake 中使用一个变量的开关来决定是否编译链接 MathFunctions 库，那如何在源代码中判断是否编译了 MathFunctions 呢？可以借助 step 1 中使用的 configure_file() 命令，在根目录下的 <a href="http://TutorialConfig.h.in">TutorialConfig.h.in</a> 文件中添加如下代码：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">cmakedefine USE_MYMATH</span><br></code></pre></div></td></tr></table></figure><p>借助 configure_file() 生成的 Tutorial.h 文件中会出现这样一行代码：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> USE_MYMATH</span><br></code></pre></div></td></tr></table></figure><p>因此我们就可以在源文件中引用 Tutorial.h 并使用 USE_MYMATH 这个宏定义了，在 tutorial.cxx 中引入头文件的位置和计算平方根的位置通过宏来判断使用自定义函数还是系统函数：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">...<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_MYMATH</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MathFunctions.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>...<br><br>...<br><span class="hljs-comment">// calculate square root</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_MYMATH</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">double</span> outputValue = mysqrt(inputValue);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">const</span> <span class="hljs-type">double</span> outputValue = <span class="hljs-built_in">sqrt</span>(inputValue);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>...<br></code></pre></div></td></tr></table></figure><p>cmake 重新生成编译，执行 Tutorial 发现结果符合预期：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./Tutorial 16<br>Computing sqrt of 16 to be 8.5<br>Computing sqrt of 16 to be 5.19118<br>Computing sqrt of 16 to be 4.13666<br>Computing sqrt of 16 to be 4.00226<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>The square root of 16 is 4<br></code></pre></div></td></tr></table></figure><p>如果不想编译链接 MathFunctions，只需将 CMakeLists.txt 中 USE_MYMATH 的 option 设置为 OFF，重新 cmake 生成编译即可，或者在执行 cmake 生成时添加参数将 option 关闭：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cmake .. -DUSE_MYMATH=OFF<br></code></pre></div></td></tr></table></figure><p>此时查看生成的 Tutorial.h 文件，发现 USE_MYMATH 并没有被定义：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cat TutorialConfig.h<br><span class="hljs-comment">// the configured options and settings for Tutorial</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Tutorial_VERSION_MAJOR 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Tutorial_VERSION_MINOR 0</span><br><br><span class="hljs-comment">/* #undef USE_MYMATH */</span><br></code></pre></div></td></tr></table></figure><h2 id="step-3-给链接库添加使用要求">step 3 给链接库添加使用要求</h2><p>使用要求（Usage Requirements）可以更好地控制库或可执行文件的链接和头文件索引，也可以更好地控制 CMake 中目标的属性传递。利用“使用要求”的主要命令有：</p><ul><li><a href="https://cmake.org/cmake/help/latest/command/target_compile_definitions.html#command:target_compile_definitions">target_compile_definitions()</a></li><li><a href="https://cmake.org/cmake/help/latest/command/target_compile_options.html#command:target_compile_options">target_compile_options()</a></li><li><a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html#command:target_include_directories">target_include_directories()</a></li><li><a href="https://cmake.org/cmake/help/latest/command/target_link_libraries.html#command:target_link_libraries">target_link_libraries()</a></li></ul><p>观察我们之前写过的项目，MathFunctions 的头文件 MathFunctions.h 只有在主工程源文件 tutorial.cxx 中使用，而 MathFunctions 库本身并没有使用，所以这里可以定义一个“使用要求”，即 INTERFACE。</p><p>INTERFACE 意味着消费者（customer）需要使用但生产者（producer）不需要使用的东西，因此我们在 MathFunctions 文件夹下的 CMakeLists.txt 文件中添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">target_include_directories(MathFunctions<br>          INTERFACE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;<br>          )<br></code></pre></div></td></tr></table></figure><p>CMAKE_CURRENT_SOURCE_DIR 是当前层的 CMakeLists.txt 对应资源文件所在目录，这行命令告知 cmake 当前目录下的头文件我当前层的源代码不需要使用，上层需要使用。添加这一行后，就可以将根目录 CMakeLists.txt 文件中对 MathFunctions 头文件的引用去掉了：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">if(USE_MYMATH)<br>  add_subdirectory(MathFunctions)<br>  list(APPEND EXTRA_LIBS MathFunctions)<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">list(APPEND EXTRA_INCLUDES <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/MathFunctions&quot;</span>)</span><br>endif()<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">add the executable</span><br>add_executable(Tutorial tutorial.cxx)<br><br>target_link_libraries(Tutorial PUBLIC $&#123;EXTRA_LIBS&#125;)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">add the binary tree to the search path <span class="hljs-keyword">for</span> include files</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">so that we will find TutorialConfig.h</span><br>target_include_directories(Tutorial PUBLIC<br>                           &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;<br>                           # $&#123;EXTRA_INCLUDES&#125;<br>                           )<br></code></pre></div></td></tr></table></figure><p>重新 cmake 生成编译，运行 Tutorial 查看输出正常：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./Tutorial 16<br>Computing sqrt of 16 to be 8.5<br>Computing sqrt of 16 to be 5.19118<br>Computing sqrt of 16 to be 4.13666<br>Computing sqrt of 16 to be 4.00226<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>The square root of 16 is 4<br></code></pre></div></td></tr></table></figure><h2 id="step-4-安装和测试">step 4 安装和测试</h2><h3 id="安装规则">安装规则</h3><p>安装这一步比较简单，对于我们之前的项目，应用程序需要安装可执行程序和配置的头文件，MathFunctions 库需要安装库的二进制文件和库的头文件，安装的本质其实就是将编译出的文件复制到安装目录下。</p><p>首先我们在 MathFunctions 目录下的 CMakeLists.txt 中添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">install(TARGETS MathFunctions DESTINATION lib)<br>install(FILES MathFunctions.h DESTINATION include)<br></code></pre></div></td></tr></table></figure><p>然后在根目录的 CMakeLists.txt 中添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">install(TARGETS Tutorial DESTINATION bin)<br>install(FILES &quot;$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h&quot;<br>  DESTINATION include<br>  )<br></code></pre></div></td></tr></table></figure><p>最后我们进入 build 目录重新 cmake 生成编译，运行 install 命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cmake --install .<br>-- Install configuration: &quot;&quot;<br>-- Installing: /usr/local/bin/Tutorial<br>-- Installing: /usr/local/include/TutorialConfig.h<br>-- Installing: /usr/local/lib/libMathFunctions.a<br>-- Installing: /usr/local/include/MathFunctions.h<br></code></pre></div></td></tr></table></figure><p>Mac 系统默认的 DESTINATION 路径是 /usr/local/，cmake 在该路径下分别安装了二进制文件和头文件。</p><p>cmake 也可以通过 prefix 参数指定安装目录：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">cmake --install . --prefix=<span class="hljs-string">&quot;/Users/joker/Desktop/install&quot;</span><br>-- Install configuration: <span class="hljs-string">&quot;&quot;</span><br>-- Installing: <span class="hljs-regexp">/Users/</span>joker<span class="hljs-regexp">/Desktop/i</span>nstall<span class="hljs-regexp">/bin/</span>Tutorial<br>-- Installing: <span class="hljs-regexp">/Users/</span>joker<span class="hljs-regexp">/Desktop/i</span>nstall<span class="hljs-regexp">/include/</span>TutorialConfig.h<br>-- Installing: <span class="hljs-regexp">/Users/</span>joker<span class="hljs-regexp">/Desktop/i</span>nstall<span class="hljs-regexp">/lib/</span>libMathFunctions.a<br>-- Installing: <span class="hljs-regexp">/Users/</span>joker<span class="hljs-regexp">/Desktop/i</span>nstall<span class="hljs-regexp">/include/</span>MathFunctions.h<br></code></pre></div></td></tr></table></figure><h3 id="测试支持">测试支持</h3><p>接下来让我们测试我们的应用程序。在顶级<code>CMakeLists.txt</code> 文件的末尾，我们可以启用测试，然后添加一些基本测试来验证应用程序是否正常工作。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">enable_testing()<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">does the application run</span><br>add_test(NAME Runs COMMAND Tutorial 25)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">does the usage message work?</span><br>add_test(NAME Usage COMMAND Tutorial)<br>set_tests_properties(Usage<br>  PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage:.*number&quot;<br>  )<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">define a <span class="hljs-keyword">function</span> to simplify adding tests</span><br>function(do_test target arg result)<br>  add_test(NAME Comp$&#123;arg&#125; COMMAND $&#123;target&#125; $&#123;arg&#125;)<br><span class="hljs-meta prompt_">  set_tests_properties(Comp$</span><span class="language-bash">&#123;arg&#125;</span><br>    PROPERTIES PASS_REGULAR_EXPRESSION $&#123;result&#125;<br>    )<br>endfunction()<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">do</span> a bunch of result based tests</span><br>do_test(Tutorial 4 &quot;4 is 2&quot;)<br>do_test(Tutorial 9 &quot;9 is 3&quot;)<br>do_test(Tutorial 5 &quot;5 is 2.236&quot;)<br>do_test(Tutorial 7 &quot;7 is 2.645&quot;)<br>do_test(Tutorial 25 &quot;25 is 5&quot;)<br>do_test(Tutorial -25 &quot;-25 is (-nan|nan|0)&quot;)<br>do_test(Tutorial 0.0001 &quot;0.0001 is 0.01&quot;)<br></code></pre></div></td></tr></table></figure><p>第一个测试只是验证应用程序是否运行，没有段错误或以其他方式崩溃，并且返回值为零。这是 CTest 测试的基本形式。</p><p>下一个测试使用 PASS_REGULAR_EXPRESSION 属性来验证测试的输出是否包含某些字符串。在这种情况下，验证在提供不正确数量的参数时是否打印了使用消息。</p><p>最后，我们有一个调用函数 do_test 来运行应用程序并验证计算的平方根对于给定的输入是否正确。对于 的每次调用 do_test，都会将另一个测试添加到项目中，其中包含名称、输入和基于传递的参数的预期结果。</p><p>重建应用程序，然后 cd 到二进制目录并运行 ctest 可执行文件：和。对于多配置生成器（例如 Visual Studio），必须使用标志指定配置类型。例如，要在 Debug 模式下运行测试，请使用二进制目录（而不是 Debug 子目录！）。发布模式将从同一位置执行，但使用. 或者，从 IDE构建目标。</p><p><code>ctest -N``ctest -VV``-C &lt;mode&gt;``ctest -C Debug -VV``-C Release``RUN_TESTS</code></p><h2 id="step-5-添加系统能力检测">step 5 添加系统能力检测</h2><p>考虑在项目中添加一些代码，这些代码用于检测目标平台是否包含 log 和 exp 函数，如果平台有 log 和 exp，那么我们将使用它们来计算函数中的平方根。</p><p>我们首先在 MathFunctions 目录下的 CMakeLists.txt 中引入 CheckCXXSourceCompiles 模块，并使用 check_cxx_source_compiles() 函数将检测结果写入到 HAVE_LOG 和 HAVE_EXP 两个宏定义中：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">target_include_directories(MathFunctions<br>          INTERFACE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;<br>          )<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">does this system provide the <span class="hljs-built_in">log</span> and exp <span class="hljs-built_in">functions</span>?</span><br>include(CheckCXXSourceCompiles)<br>check_cxx_source_compiles(&quot;<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">include &lt;cmath&gt;</span><br>  int main() &#123;<br>    std::log(1.0);<br>    return 0;<br>  &#125;<br>&quot; HAVE_LOG)<br>check_cxx_source_compiles(&quot;<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">include &lt;cmath&gt;</span><br>  int main() &#123;<br>    std::exp(1.0);<br>    return 0;<br>  &#125;<br>&quot; HAVE_EXP)<br></code></pre></div></td></tr></table></figure><p>如果 log 和 exp 可用，使用 target_compile_definitions() 指定 HAVE_LOG 和 HAVE_EXP 作为 PRIVATE 编译定义：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">if(HAVE_LOG AND HAVE_EXP)<br>  target_compile_definitions(MathFunctions<br>                             PRIVATE &quot;HAVE_LOG&quot; &quot;HAVE_EXP&quot;)<br>endif()<br></code></pre></div></td></tr></table></figure><p>在 mysqrt.cxx 中添加 HAVE_LOG 和 HAVE_EXP 的判断：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(HAVE_LOG) &amp;&amp; defined(HAVE_EXP)</span><br>  <span class="hljs-type">double</span> result = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">exp</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">log</span>(x) * <span class="hljs-number">0.5</span>);<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Computing sqrt of &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; to be &quot;</span> &lt;&lt; result<br>            &lt;&lt; <span class="hljs-string">&quot; using log and exp&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">double</span> result = x;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><p>重新编译运行 Tutorial，控制台输出符合预期，使用系统的 log 和 exp 函数计算平方根：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./Tutorial 16<br>Computing sqrt of 16 to be 4 using log and exp<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>Computing sqrt of 16 to be 4<br>The square root of 16 is 4<br></code></pre></div></td></tr></table></figure><h2 id="step-6-添加自定义命令和生成文件">step 6 添加自定义命令和生成文件</h2><p>现在我们通过 cmake 的自定义命令动态生成一个包含计算平方根函数的文件，首先删除掉 step 5 中 log 和 exp 函数检查的相关代码，在 MathFunctions 目录下创建一个源文件 MakeTable.cxx 来生成文件，main函数中在传入路径上创建文件并注入计算平方根的数组代码：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// A simple program that builds a sqrt table</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>  <span class="hljs-comment">// make sure we have enough arguments</span><br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">std</span>::ofstream <span class="hljs-title function_">fout</span><span class="hljs-params">(argv[<span class="hljs-number">1</span>], <span class="hljs-built_in">std</span>::ios_base::out)</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">bool</span> fileOpen = fout.is_open();<br>  <span class="hljs-keyword">if</span> (fileOpen) &#123;<br>    fout &lt;&lt; <span class="hljs-string">&quot;double sqrtTable[] = &#123;&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>      fout &lt;&lt; <span class="hljs-built_in">sqrt</span>(static_cast&lt;<span class="hljs-type">double</span>&gt;(i)) &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-comment">// close the table with a zero</span><br>    fout &lt;&lt; <span class="hljs-string">&quot;0&#125;;&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    fout.close();<br>  &#125;<br>  <span class="hljs-keyword">return</span> fileOpen ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>; <span class="hljs-comment">// return 0 if wrote the file</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>接着在 MathFunctions 目录 CMakeLists.txt 文件顶部添加如下内容，将 MakeTable.cxx 编译成可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">add_executable(MakeTable MakeTable.cxx)<br></code></pre></div></td></tr></table></figure><p>然后我们添加一个自定义命令，通过执行命令，借助 MakeTable 可执行文件生成 Table.h:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">add_custom_command(<br>  OUTPUT $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h<br>  COMMAND MakeTable $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h<br>  DEPENDS MakeTable<br>  )<br></code></pre></div></td></tr></table></figure><p>接下来我们要让 CMake 知道 mysqrt.cxx 依赖于生成的文件 Table.h，这是通过将生成的 Table.h 添加到库 MathFunctions 的源列表中来完成的：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">add_library(MathFunctions<br>            mysqrt.cxx<br>            $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h<br>            )<br></code></pre></div></td></tr></table></figure><p>我们还必须将当前二进制目录添加到包含目录列表中，以便 Table.h 可以被 mysqrt.cxx 索引到：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">target_include_directories(MathFunctions<br>          INTERFACE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;<br>          PRIVATE $&#123;CMAKE_CURRENT_BINARY_DIR&#125;<br>          )<br></code></pre></div></td></tr></table></figure><p>最后需要修改 mysqrt 函数：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">double mysqrt(double x)<br>&#123;<br>  if (x &lt;= 0) &#123;<br>    return 0;<br>  &#125;<br><br>  // use the table to help find an initial value<br>  double result = x;<br>  if (x &gt;= 1 &amp;&amp; x &lt; 10) &#123;<br>    std::cout &lt;&lt; &quot;Use the table to help find an initial value &quot; &lt;&lt; std::endl;<br>    result = sqrtTable[static_cast&lt;int&gt;(x)];<br>  &#125;<br><br>  // do ten iterations<br>  for (int i = 0; i &lt; 10; ++i) &#123;<br>    if (result &lt;= 0) &#123;<br>      result = 0.1;<br>    &#125;<br>    double delta = x - (result * result);<br>    result = result + 0.5 * delta / result;<br>    std::cout &lt;&lt; &quot;Computing sqrt of &quot; &lt;&lt; x &lt;&lt; &quot; to be &quot; &lt;&lt; result &lt;&lt; std::endl;<br>  &#125;<br><br>  return result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>重新 cmake 生成编译，在 MathFunctions 编译目录下生成了 Table.h，执行 Tutorial 程序，输出符合预期：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./Tutorial 9<br>Use the table to help find an initial value<br>Computing sqrt of 9 to be 3<br>Computing sqrt of 9 to be 3<br>Computing sqrt of 9 to be 3<br>Computing sqrt of 9 to be 3<br>Computing sqrt of 9 to be 3<br>Computing sqrt of 9 to be 3<br>Computing sqrt of 9 to be 3<br>Computing sqrt of 9 to be 3<br>Computing sqrt of 9 to be 3<br>Computing sqrt of 9 to be 3<br>The square root of 9 is 3<br></code></pre></div></td></tr></table></figure><h2 id="step-7-打包安装程序">step 7 打包安装程序</h2><p>接下来假设我们想将项目分发给其他人，以便他们可以使用它。我们希望在各种平台上提供二进制和源代码分发。这与我们之前进行的安装有点不同，我们正在安装从源代码构建的二进制文件。在此示例中，我们将构建支持二进制安装和包管理功能的安装包。为此，我们将使用 CPack 创建特定于平台的安装程序。具体来说，我们需要在顶层 CMakeLists.txt 文件的底部添加几行:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">include(InstallRequiredSystemLibraries)<br>set(CPACK_RESOURCE_FILE_LICENSE &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/License.txt&quot;)<br>set(CPACK_PACKAGE_VERSION_MAJOR &quot;$&#123;Tutorial_VERSION_MAJOR&#125;&quot;)<br>set(CPACK_PACKAGE_VERSION_MINOR &quot;$&#123;Tutorial_VERSION_MINOR&#125;&quot;)<br>set(CPACK_SOURCE_GENERATOR &quot;TGZ&quot;)<br>include(CPack)<br></code></pre></div></td></tr></table></figure><p>这就是它的全部。我们首先引入 InstallRequiredSystemLibraries，该模块将包括当前平台项目所需的任何运行时库。接下来，我们将一些 CPack 变量设置为我们存储该项目的许可证和版本信息的位置。版本信息已在本教程前面设置，并且 License.txt 已包含在此步骤的顶级源目录中。这 CPACK_SOURCE_GENERATOR 变量选择源包的文件格式。</p><p>最后我们引入 CPack 模块，它将使用这些变量和当前系统的一些其他属性来设置安装程序。</p><p>下一步是以正常的方式构建项目，然后运行  cpack。要构建二进制发行版，请从二进制目录运行：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cpack<br></code></pre></div></td></tr></table></figure><p>要指定生成器，请使用 -G 选项。对于多配置构建，用于 -C 指定配置。例如：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cpack -G ZIP -C Debug<br></code></pre></div></td></tr></table></figure><h2 id="step-8-添加对测试仪表盘的支持">step 8 添加对测试仪表盘的支持</h2><p>在之前的 step 已经定义过了一些项目的测试，现在我们只需要将测试跑起来然后提交到仪表盘，为了支持仪表盘我们需要在根目录的 CMakeLists.txt 中引入 CTest 模块：</p><p>使用：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">include(CTest)<br></code></pre></div></td></tr></table></figure><p>替换：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">enable_testing</span><span class="hljs-params">()</span></span><br></code></pre></div></td></tr></table></figure><p>在根目录创建 CTestConfig.cmake 用来定义 CTest 的一些信息：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">set(CTEST_PROJECT_NAME &quot;CMakeTutorial&quot;)<br>set(CTEST_NIGHTLY_START_TIME &quot;00:00:00 EST&quot;)<br><br>set(CTEST_DROP_METHOD &quot;http&quot;)<br>set(CTEST_DROP_SITE &quot;my.cdash.org&quot;)<br>set(CTEST_DROP_LOCATION &quot;/submit.php?project=CMakeTutorial&quot;)<br>set(CTEST_DROP_SITE_CDASH TRUE)<br></code></pre></div></td></tr></table></figure><p>ctest 可执行文件将在运行时读入此文件。要创建一个简单的仪表板，您可以运行 cmake 可执行文件或 cmake-gui 配置项目，但尚未构建它。相反，将目录更改为二叉树，然后运行：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ctest [-VV] -D Experimental<br></code></pre></div></td></tr></table></figure><p>请记住，对于多配置生成器（例如 Visual Studio），必须指定配置类型：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ctest [-VV] -C Debug -D Experimental<br></code></pre></div></td></tr></table></figure><p>或者，从 IDE 构建 Experimental 目标。</p><p>ctest 可执行文件将构建和测试项目并将结果提交到 Kitware 的公共仪表板： <a href="https://my.cdash.org/index.php?project=CMakeTutorial">https 😕/my.cdash.org/index.php?project=CMakeTutorial </a>。</p><h2 id="step-9-选择静态或动态库">step 9 选择静态或动态库</h2><p>在本节中将展示 BUILD_SHARED_LIBS 变量是如何影响 add_library() 的默认行为的，为此我们需要在根目录 CMakeList.txt 文件中添加 BUILD_SHARED_LIBS，我们使用 option() 命令，因为它允许用户有选择地控制 ON 和 OFF。</p><p>接下来我们将重构 MathFunctions 使其成为一个真正封装 mysqrt 或 sqrt 的库，而不是要求调用代码来实现这个逻辑，这意味着 USE_MYMATH 不会影响 MathFunctions 库的正常编译，而是会控制这个库的行为。</p><p>第一步是更新根目录的 CMakeLists.txt：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cmake_minimum_required(VERSION 3.10)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">set</span> the project name and version</span><br>project(Tutorial VERSION 1.0)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">specify the C++ standard</span><br>set(CMAKE_CXX_STANDARD 11)<br>set(CMAKE_CXX_STANDARD_REQUIRED True)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">control <span class="hljs-built_in">where</span> the static and shared libraries are built so that on windows</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">we don<span class="hljs-string">&#x27;t need to tinker with the path to run the executable</span></span><br>set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;)<br>set(CMAKE_LIBRARY_OUTPUT_DIRECTORY &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;)<br>set(CMAKE_RUNTIME_OUTPUT_DIRECTORY &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;)<br><br>option(BUILD_SHARED_LIBS &quot;Build using shared libraries&quot; ON)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">configure a header file to pass the version number only</span></span><br>configure_file(TutorialConfig.h.in TutorialConfig.h)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">add the MathFunctions library</span></span><br>add_subdirectory(MathFunctions)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">add the executable</span></span><br>add_executable(Tutorial tutorial.cxx)<br>target_link_libraries(Tutorial PUBLIC MathFunctions)<br></code></pre></div></td></tr></table></figure><p>现在我们已经让 MathFunctions 这个库总是被编译，我们将需要更新该库的逻辑。因此，MathFunctions 目录下的 CMakeLists.txt 我们需要创建一个SqrtLibrary，它会在 USE_MYMATH 启用时有条件地构建和安装。现在，由于这是一个教程，我们将明确要求 SqrtLibrary 是静态构建的。</p><p>最终 MathFunctions 目录下的 CMakeLists.txt 应该如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">add the library that runs</span><br>add_library(MathFunctions MathFunctions.cxx)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">state that anybody linking to us needs to include the current <span class="hljs-built_in">source</span> <span class="hljs-built_in">dir</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">to find MathFunctions.h, <span class="hljs-keyword">while</span> we don<span class="hljs-string">&#x27;t.</span></span><br>target_include_directories(MathFunctions<br>                           INTERFACE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;<br>                           )<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">should we use our own math functions</span></span><br>option(USE_MYMATH &quot;Use tutorial provided math implementation&quot; ON)<br>if(USE_MYMATH)<br><br>  target_compile_definitions(MathFunctions PRIVATE &quot;USE_MYMATH&quot;)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-string">first we add the executable that generates the table</span></span><br>  add_executable(MakeTable MakeTable.cxx)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-string">add the command to generate the source code</span></span><br>  add_custom_command(<br>    OUTPUT $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h<br>    COMMAND MakeTable $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h<br>    DEPENDS MakeTable<br>    )<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-string">library that just does sqrt</span></span><br>  add_library(SqrtLibrary STATIC<br>              mysqrt.cxx<br>              $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/Table.h<br>              )<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-string">state that we depend on our binary dir to find Table.h</span></span><br>  target_include_directories(SqrtLibrary PRIVATE<br>                             $&#123;CMAKE_CURRENT_BINARY_DIR&#125;<br>                             )<br><br>  target_link_libraries(MathFunctions PRIVATE SqrtLibrary)<br>endif()<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">define the symbol stating we are using the declspec(dllexport) when</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">building on windows</span></span><br>target_compile_definitions(MathFunctions PRIVATE &quot;EXPORTING_MYMATH&quot;)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">install rules</span></span><br>set(installable_libs MathFunctions)<br>if(TARGET SqrtLibrary)<br>  list(APPEND installable_libs SqrtLibrary)<br>endif()<br>install(TARGETS $&#123;installable_libs&#125; DESTINATION lib)<br>install(FILES MathFunctions.h DESTINATION include)<br></code></pre></div></td></tr></table></figure><p>接下来，更新 mysqrt.cxx 以使用 mathfunctions 和 detail 命名空间：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MathFunctions.h&quot;</span></span><br><br><span class="hljs-comment">// include the generated table</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Table.h&quot;</span></span><br><br>namespace mathfunctions &#123;<br>namespace detail &#123;<br><span class="hljs-comment">// a hack square root calculation using simple operations</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">mysqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// use the table to help find an initial value</span><br>  <span class="hljs-type">double</span> result = x;<br>  <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">1</span> &amp;&amp; x &lt; <span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Use the table to help find an initial value &quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    result = sqrtTable[static_cast&lt;<span class="hljs-type">int</span>&gt;(x)];<br>  &#125;<br><br>  <span class="hljs-comment">// do ten iterations</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (result &lt;= <span class="hljs-number">0</span>) &#123;<br>      result = <span class="hljs-number">0.1</span>;<br>    &#125;<br>    <span class="hljs-type">double</span> delta = x - (result * result);<br>    result = result + <span class="hljs-number">0.5</span> * delta / result;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Computing sqrt of &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; to be &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们还需要对 进行一些更改 tutorial.cxx，使其不再使用 USE_MYMATH：</p><ol><li>始终引用 MathFunctions.h</li><li>始终使用 mathfunctions::sqrt</li><li>不包括 cmath</li></ol><p>最后，更新 MathFunctions/MathFunctions.h 使用 dll 导出定义：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_WIN32)</span><br><span class="hljs-meta">#  <span class="hljs-keyword">if</span> defined(EXPORTING_MYMATH)</span><br><span class="hljs-meta">#    <span class="hljs-keyword">define</span> DECLSPEC __declspec(dllexport)</span><br><span class="hljs-meta">#  <span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#    <span class="hljs-keyword">define</span> DECLSPEC __declspec(dllimport)</span><br><span class="hljs-meta">#  <span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">// non windows</span></span><br><span class="hljs-meta">#  <span class="hljs-keyword">define</span> DECLSPEC</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>namespace mathfunctions &#123;<br><span class="hljs-type">double</span> DECLSPEC <span class="hljs-title function_">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>此时，如果您构建所有内容，您可能会注意到链接失败，因为我们将没有位置无关代码的静态库与具有位置无关代码的库组合在一起。解决方案是显式设置 SqrtLibrary 的目标属性 POSITION_INDEPENDENT_CODE 为 True，与构建类型无关。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">state that SqrtLibrary need PIC when the default is shared libraries</span><br>set_target_properties(SqrtLibrary PROPERTIES<br>                      POSITION_INDEPENDENT_CODE $&#123;BUILD_SHARED_LIBS&#125;<br>                      )<br><br>target_link_libraries(MathFunctions PRIVATE SqrtLibrary)<br></code></pre></div></td></tr></table></figure><h2 id="step-10-添加生成器表达式">step 10 添加生成器表达式</h2><p>Generator expressions 在构建系统生成期间进行评估，以生成特定于每个构建配置的信息。</p><p>Generator expressions 在许多目标属性的上下文中是允许的，例如 LINK_LIBRARIES, INCLUDE_DIRECTORIES，COMPILE_DEFINITIONS 和别的。它们也可以在使用命令填充这些属性时使用，例如 target_link_libraries()，target_include_directories(), target_compile_definitions() 和别的。</p><p>Generator expressions 可用于启用条件链接、编译时使用的条件定义、条件包含目录等。条件可以基于构建配置、目标属性、平台信息或任何其他可查询信息。</p><p>有不同类型的 generator expressions 包括逻辑、信息和输出表达式。</p><p>generator expressions 的一个常见用法是有条件地添加编译器标志，例如语言级别或警告的标志。一个很好的模式是将此信息与 INTERFACE 允许此信息传播的目标相关联。让我们首先构造一个  INTERFACE 目标并指定所需的 C++ 标准级别，11 而不是使用 CMAKE_CXX_STANDARD.</p><p>所以下面的代码：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">specify the C++ standard</span><br>set(CMAKE_CXX_STANDARD 11)<br>set(CMAKE_CXX_STANDARD_REQUIRED True)<br></code></pre></div></td></tr></table></figure><p>将被替换为：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">add_library(tutorial_compiler_flags INTERFACE)<br>target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)<br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>：接下来的部分将需要更改 cmake_minimum_required() 代码中的用法。即将使用的生成器表达式是在 3.15 中引入的。更新调用以要求更新版本：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cmake_minimum_required(VERSION 3.15)<br></code></pre></div></td></tr></table></figure><p>接下来，我们为项目添加所需的编译器警告标志。由于警告标志因编译器而异，我们使用 COMPILE_LANG_AND_ID 生成器表达式来控制在给定语言和一组编译器 ID 的情况下应用哪些标志，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">set(gcc_like_cxx &quot;$&lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC&gt;&quot;)<br>set(msvc_cxx &quot;$&lt;COMPILE_LANG_AND_ID:CXX,MSVC&gt;&quot;)<br>target_compile_options(tutorial_compiler_flags INTERFACE<br>  &quot;$&lt;$&#123;gcc_like_cxx&#125;:$&lt;BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused&gt;&gt;&quot;<br>  &quot;$&lt;$&#123;msvc_cxx&#125;:$&lt;BUILD_INTERFACE:-W3&gt;&gt;&quot;<br>)<br></code></pre></div></td></tr></table></figure><p>看看这个，我们看到警告标志被封装在一个 BUILD_INTERFACE 条件中。这样做是为了使我们已安装项目的消费者不会继承我们的警告标志。</p><h2 id="step-11-添加导出配置">step 11 添加导出配置</h2><p>在本教程中，我们添加了 CMake 安装项目的库和标头的功能。在此期间 ，我们添加了打包此信息的功能，以便将其分发给其他人。</p><p>下一步是添加必要的信息，以便其他 CMake 项目可以使用我们的项目，无论是从构建目录、本地安装还是打包时。</p><p>第一步是更新我们的 install(TARGETS) 命令不仅可以指定 DESTINATION，还可以指定 EXPORT. 该 EXPORT 关键字生成一个 CMake 文件，其中包含从安装树导入 install 命令中列出的所有目标的代码。因此，让我们继续通过更新命令来明确 EXPORT 库，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">set(installable_libs MathFunctions tutorial_compiler_flags)<br>if(TARGET SqrtLibrary)<br>  list(APPEND installable_libs SqrtLibrary)<br>endif()<br>install(TARGETS $&#123;installable_libs&#125;<br>        EXPORT MathFunctionsTargets<br>        DESTINATION lib)<br>install(FILES MathFunctions.h DESTINATION include)<br></code></pre></div></td></tr></table></figure><p>现在我们已经 MathFunctions 被导出，我们还需要显式安装生成的 MathFunctionsTargets.cmake 文件。这是通过将以下内容添加到顶层的底部来完成的 CMakeLists.txt：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">install(EXPORT MathFunctionsTargets<br>  FILE MathFunctionsTargets.cmake<br>  DESTINATION lib/cmake/MathFunctions<br>)<br></code></pre></div></td></tr></table></figure><p>此时您应该尝试运行 CMake。如果一切设置正确，您将看到 CMake 将生成如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Target &quot;MathFunctions&quot; INTERFACE_INCLUDE_DIRECTORIES property contains<br>path:<br><br>  &quot;/Users/robert/Documents/CMakeClass/Tutorial/Step11/MathFunctions&quot;<br><br>which is prefixed in the source directory.<br></code></pre></div></td></tr></table></figure><p>CMake 想说的是，在生成导出信息期间，它将导出一个本质上与当前机器相关联的路径，并且在其他机器上无效。解决方法是更新 MathFunctions target_include_directories()了解它 INTERFACE 在构建目录和安装/包中使用时需要不同的位置。这意味着转换  target_include_directories() 要求 MathFunctions 看起来像：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">target_include_directories(MathFunctions<br>                           INTERFACE<br>                            $&lt;BUILD_INTERFACE:$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&gt;<br>                            $&lt;INSTALL_INTERFACE:include&gt;<br>                           )<br></code></pre></div></td></tr></table></figure><p>更新后，我们可以重新运行 CMake 并验证它不再发出警告。</p><p>此时，我们已经让 CMake 正确打包了所需的目标信息，但我们仍然需要生成一个 MathFunctionsConfig.cmake，以便 CMake find_package() 命令可以找到我们的项目。所以让我们继续在项目的顶层添加一个新文件，其 <a href="http://Config.cmake.in">Config.cmake.in</a> 内容如下：</p><p><a href="http://xn--os0ay97a.cmake.in">配置.cmake.in</a></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">@PACKAGE_INIT@<br><br>include ( &quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/MathFunctionsTargets.cmake&quot; )<br></code></pre></div></td></tr></table></figure><p>然后，要正确配置和安装该文件，请将以下内容添加到顶层的底部 CMakeLists.txt：</p><p>CMakeLists.txt</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">install(EXPORT MathFunctionsTargets<br>  FILE MathFunctionsTargets.cmake<br>  DESTINATION lib/cmake/MathFunctions<br>)<br><br>include(CMakePackageConfigHelpers)<br></code></pre></div></td></tr></table></figure><p>接下来，我们执行 configure_package_config_file(). 此命令将配置提供的文件，但与标准有一些特定差异 configure_file() 方法。@PACKAGE_INIT@ 要正确使用此功能，输入文件除了所需内容外，还应包含一行文本。该变量将替换为将设置值转换为相对路径的代码块。这些新值可以用相同的名称引用，但前面带有 PACKAGE_ 前缀。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">install(EXPORT MathFunctionsTargets<br>  FILE MathFunctionsTargets.cmake<br>  DESTINATION lib/cmake/MathFunctions<br>)<br><br>include(CMakePackageConfigHelpers)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">generate the config file that is includes the exports</span><br><span class="hljs-meta prompt_">configure_package_config_file($</span><span class="language-bash">&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/Config.cmake.in</span><br>  &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MathFunctionsConfig.cmake&quot;<br>  INSTALL_DESTINATION &quot;lib/cmake/example&quot;<br>  NO_SET_AND_CHECK_MACRO<br>  NO_CHECK_REQUIRED_COMPONENTS_MACRO<br>  )<br></code></pre></div></td></tr></table></figure><p>这 write_basic_package_version_file() 接下来是。此命令写入“find_package”文件使用的文件，其中包含所需包的版本和兼容性。在这里，我们使用 Tutorial_VERSION_* 变量并说它与 兼容 AnyNewerVersion，这表示该版本或任何更高版本与请求的版本兼容。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">write_basic_package_version_file(<br>  &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MathFunctionsConfigVersion.cmake&quot;<br>  VERSION &quot;$&#123;Tutorial_VERSION_MAJOR&#125;.$&#123;Tutorial_VERSION_MINOR&#125;&quot;<br>  COMPATIBILITY AnyNewerVersion<br>)<br></code></pre></div></td></tr></table></figure><p>最后，设置要安装的两个生成的文件：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">install(FILES<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MathFunctionsConfig.cmake</span><br><span class="hljs-meta prompt_">  $</span><span class="language-bash">&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MathFunctionsConfigVersion.cmake</span><br>  DESTINATION lib/cmake/MathFunctions<br>  )<br></code></pre></div></td></tr></table></figure><p>至此，我们已经为我们的项目生成了一个可重定位的 CMake 配置，可以在项目安装或打包后使用。如果我们希望我们的项目也可以从构建目录中使用，我们只需将以下内容添加到顶层的底部 CMakeLists.txt：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">export(EXPORT MathFunctionsTargets<br>  FILE &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MathFunctionsTargets.cmake&quot;<br>)<br></code></pre></div></td></tr></table></figure><p>通过这个导出调用，我们现在生成一个 Targets.cmake，允许 MathFunctionsConfig.cmake 其他项目使用构建目录中的配置，而无需安装它。</p><h2 id="step-12-打包调试和发布">step 12 打包调试和发布</h2><p>**注意：**此示例对单配置生成器有效，不适用于多配置生成器（例如 Visual Studio）。</p><p>默认情况下，CMake 的模型是构建目录只包含一个配置，无论是 Debug、Release、MinSizeRel 还是 RelWithDebInfo。但是，可以将 CPack 设置为捆绑多个构建目录并构建一个包含同一项目的多个配置的包。</p><p>首先，我们要确保调试和发布版本对将要安装的可执行文件和库使用不同的名称。让我们使用d作为调试可执行文件和库的后缀。</p><p>放 CMAKE_DEBUG_POSTFIX 在顶级 CMakeLists.txt 文件的开头附近：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">set(CMAKE_DEBUG_POSTFIX d)<br><br>add_library(tutorial_compiler_flags INTERFACE)<br></code></pre></div></td></tr></table></figure><p>和 DEBUG_POSTFIX 教程可执行文件的属性：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">add_executable(Tutorial tutorial.cxx)<br>set_target_properties(Tutorial PROPERTIES DEBUG_POSTFIX $&#123;CMAKE_DEBUG_POSTFIX&#125;)<br><br>target_link_libraries(Tutorial PUBLIC MathFunctions)<br></code></pre></div></td></tr></table></figure><p>让我们还将版本编号添加到 MathFunctions 库中。在 MathFunctions/CMakeLists.txt 中，设置 VERSION 和 SOVERSION 特性：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">set_property(TARGET MathFunctions PROPERTY VERSION &quot;1.0.0&quot;)<br>set_property(TARGET MathFunctions PROPERTY SOVERSION &quot;1&quot;)<br></code></pre></div></td></tr></table></figure><p>从 Step12 目录中，创建 debug 和 release 子目录。布局将如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">- Step12<br>   - debug<br>   - release<br></code></pre></div></td></tr></table></figure><p>现在我们需要设置调试和发布版本。我们可以用  CMAKE_BUILD_TYPE 设置配置类型：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd debug<br>cmake -DCMAKE_BUILD_TYPE=Debug ..<br>cmake --build .<br>cd ../release<br>cmake -DCMAKE_BUILD_TYPE=Release ..<br>cmake --build .<br></code></pre></div></td></tr></table></figure><p>现在调试和发布版本都已完成，我们可以使用自定义配置文件将两个版本打包到一个版本中。在  Step12 目录中，创建一个名为 MultiCPackConfig.cmake. 在此文件中，首先包含由  cmake 可执行。</p><p>接下来，使用 CPACK_INSTALL_CMAKE_PROJECTS 变量指定要安装的项目。在这种情况下，我们要同时安装调试和发布。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">include(&quot;release/CPackConfig.cmake&quot;)<br><br>set(CPACK_INSTALL_CMAKE_PROJECTS<br>    &quot;debug;Tutorial;ALL;/&quot;<br>    &quot;release;Tutorial;ALL;/&quot;<br>    )<br></code></pre></div></td></tr></table></figure><p>从 Step12 目录中，运行 cpack 使用以下选项指定我们的自定义配置文件 config：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cpack --config MultiCPackConfig.cmake<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《费曼学习法 - 用输出倒逼输入》读书笔记</title>
    <link href="/2022/06/28/%E3%80%8A%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95-%E7%94%A8%E8%BE%93%E5%87%BA%E5%80%92%E9%80%BC%E8%BE%93%E5%85%A5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/28/%E3%80%8A%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95-%E7%94%A8%E8%BE%93%E5%87%BA%E5%80%92%E9%80%BC%E8%BE%93%E5%85%A5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><h2 id="费曼简介">费曼简介</h2><p><strong>理查德·菲利普斯·费曼</strong>（英语：Richard Phillips Feynman，1918年5月11日－1988年2月15日），美国理论物理学家，以对量子力学的路径积分表述、量子电动力学、过冷液氦的超流性以及粒子物理学中部分子模型的研究闻名于世。因对量子电动力学的贡献，费曼于1965年与朱利安·施温格及朝永振一郎共同获得诺贝尔物理学奖。</p><p>以上描述摘自维基百科，费曼作为诺奖得主对量子动力学等物理学领域做出了卓越贡献。我们了解的 <strong>费曼学习法</strong>，虽然以物理学家费曼的名字命名，但实际方法来源一直受到争议。暂且抛开争议，费曼学习法确实是一套行之有效的高效率学习技巧，这种思维方式值得花时间去深入研究和实践。</p><h2 id="作者简介">作者简介</h2><p><strong>尹红心</strong>  毕业于中国人民解放军外国语学院，现任焦作师范高等专科学校讲师，从事英语教学工作至今。</p><p><strong>李伟</strong>  毕业于郑州大学，工学硕士，讲师。现为焦作师范高等专科学校教师。</p><h1>内容概要</h1><h2 id="内容框架">内容框架</h2><p>费曼学习法的核心即此书的副标题 - 用输出倒逼输入，简单的说就是在学习一门新知识时，要站在传授者的角度，假设或尝试向别人讲解这门知识，碰到解释不清含糊其辞的部分则重新学习后再进行下一轮输出，在不断的输入和输出的循环中将知识内化吸收。作者在费曼学习法的基础上拓展了一些内容，包括目标选择、知识获取途径以及后续的内化创新等等，结合自己的经历使费曼学习法的框架逐渐饱满，我将其中各模块重点总结如下图：</p><p><img src="/resources/image/feimanxuexifa.png" alt="费曼学习法"></p><p><strong>Select</strong>:</p><p><strong>确立要学习的目标</strong>  找到和列出自己想要了解的知识，可以是一本书，也可以是一门技术，甚至是能想象到的任意领域的事物。</p><p><strong>Input</strong>:</p><p><strong>理解要学习的对象</strong>  针对这个目标，准备好和筛选相关的资料，选择可靠和多个角度的信息来源，把这些内容系统化地归纳整理出来。</p><p><strong>Output</strong>:</p><p><strong>以教代学，用输出代替输入</strong>  模拟一个传授的场景，用自己的语言把这些知识讲给别人，用以检查自己是否已经掌握了这些知识。</p><p><strong>Block</strong>:</p><p><strong>进行回顾和反思</strong>  对其中遇到阻碍、模糊不清和有疑义的知识重新学习、回顾和反思。如有必要，可以重整旗鼓，进行再一次输出。</p><p><strong>Simplify</strong>:</p><p><strong>实现知识的简化和吸收</strong>  最后，通过针对性的简化和整合，实现这些知识的内化和有效的应用。</p><h2 id="内容摘录">内容摘录</h2><h3 id="Select">Select</h3><p>选择想要掌握的知识和技能只是第一步，我们还要找到学习它的必要性和重要的意义，并且强化这种内在的联系。</p><h4 id="选取目标的原则">选取目标的原则</h4><p>学习的第一步是目标的选取，可以结合自己的兴趣、当下的发展和未来的趋势选取学习目标。有许多途径可以评估自己的目标是否有价值，最好的方法就是 <strong>分析它能否匹配已有的知识体系</strong>。另外，假如这件事情 <strong>能做却不去做一定令自己终生遗憾</strong>，它就是你的目标，学习、工作和生活都是如此。</p><h4 id="目标的校验">目标的校验</h4><p>聪明的学习者善于反问和反省，愚蠢的学习者则喜欢自我感动，将一个错误的目标偏执地坚持到底。书中提到的“SMART”原则提供了一个简单明了的判断标准来检验目标是否正确：</p><p>S: (Speciffic)明确和具体的。------目标必须清晰和可以形容</p><p>M: (Measurable)可以衡量 / 量化的。 ------目标必须量化和能够评估</p><p>A: (Achievable)自身能力可以达到的。------目标必须在能力范围内</p><p>R: (Rewarding)能产生满足感 / 成就感的。------目标必须有积极的意义</p><p>T: (Time-bound)有时间限制的。------目标必须有实现的期限</p><h3 id="Input">Input</h3><p>对我们要学习的知识和概念进行归类对比，系统地理解这些内容，建立筛选和学习的原则。</p><h4 id="将知识有逻辑地系统化">将知识有逻辑地系统化</h4><p>现实中不乏记忆力超强的人，但能够在熟练记忆的同时将知识以一种合理的逻辑系统化的人却少之又少。逻辑就是你理解知识的出发点、角度、立场和思维方式；系统化则是你是否可以将这些知识纳入一个宏观的知识体系，互相印证和科学比对，对既有的知识体系形成补充。</p><ul><li><p>明白自己学习是为了什么</p></li><li><p>拥有一个足够宽阔的视野</p></li><li><p>建立最可能客观科学的逻辑</p></li></ul><h4 id="筛选和留下最可靠的知识">筛选和留下最可靠的知识</h4><p><strong>屏蔽来源不确定的知识</strong>  对知识来源的判断尤其重要，对于来源不确定的知识，要坚决屏蔽，对于来源不够专业和权威的知识，则要以审视的眼光对待它们，对于专业和权威的来源，我们也要学会独立地思考和谨慎地采纳。</p><p><strong>小心对待差异化的知识</strong>  知识的“差异化”是指非重复、有分歧甚至相互冲突的内容。两种看法尖锐对立，但可能又同是这方面的专家，都提供了严谨的论证。哪种观点是我们该采信的，对此要有务实的态度，结合自己的理解学习他们的观点。（手动狗头…）</p><p><strong>用对比的方式挑选和分辨知识</strong>  对比知识的来源，目的是删除重复和不可靠的信息，增加获取新知识的可信渠道，保证自己所获得知识的质量。通过归类对比，我们能把那些真正值得学习的知识找出来，将他们放入自己的学习系统。</p><h4 id="画一个思维导图，让知识“可视化”">画一个思维导图，让知识“可视化”</h4><p>思维导图的最大作用是可以让我们 <strong>对知识进行横向的扩展</strong>，把不同的点以列表、图像、分支的形式展现在一张纸上，让知识的主要节点一目了然。通过视觉表征的方式，刺激大脑的图像化思考，如同在城市中拥有了一种“直升机视野”，看到知识的关键部分。</p><p>我们对外界环境的感知主要是通过不同的感官实现，眼睛是获取知识最主要的一条通道。为知识画一张思维导图的最主要目的，就是扩大眼睛的作用，让知识变得立体化，使它的整体结构通过眼睛传输到大脑，可以节省很多不必要的精力。</p><p>在认知心理学中有一个 <strong>“双重编码”</strong> 理论，该理论认为，人的大脑中存在两种功能独立却又相互联系的信息加工系统：一种以文字语言为基础，另一种以表象语言为基础。前一种是语言意义，后一种是图像意义，对信息同时进行两种加工，等于实施了双重编码，记忆更加牢固，理解也更为深刻。</p><p>除此之外，制定思维导图还有一个重要的原因，那就是文字语言的表达天然具有碎片化的特征。如果你按部就班地阅读文字知识，就需要劳烦大脑把碎片化的知识拼接起来。文字语言碎片化的特点决定了它不利于高效能地学习，起码在理解的环节为我们设置了足以让人望而生畏的障碍。与之相比，视觉化的表达则具备强烈的整体性的特征，尤其善于表达知识之间的关系，使大脑能够更好地把复杂的信息迅速地加工和记忆。</p><p>总体而言，费曼在自己的教学工作中推荐的“思维和流程导图”有助于我们解决以下的 <strong>五个问题</strong>：</p><p><strong>快速地获取自己需要的信息</strong>------不论一本书，一门学科，还是一种技能，速度可以得到保证。</p><p><strong>掌握理解和分析知识的方法</strong>------和文字语言比起来，思维导图的形式为大脑创造了一条视觉化的路径。除了读书外，我们要借鉴图片、视频等工具输入内容。</p><p><strong>建立自己思考问题的框架</strong>------思维导图从整体和宏观的角度重新组织了知识，为我们提供了一个系统化思考问题的架构。</p><p><strong>形成高质量的学习笔记</strong>------组织和绘制思维导图的同时，我们也会完成高质量的学习笔记。</p><p><strong>为知识的输出做好准备</strong>------思维导图是以教代学的一个必要工具，如果你不能为所学的知识画出一个整体框架，就无法向别人输出知识。</p><h4 id="尝试对自己复述">尝试对自己复述</h4><p>费曼学习法格外重视”输出“的作用------简单地讲，输出就是复述你所学到并理解到的知识并让听者理解。第一次复述要做什么，是先讲给我们自己听一听。你要尝试着将学到的东西为自己讲解一遍，看能否想计划得那样理解，或者至少透彻地解读一大部分。</p><p>对自己复述一遍可以帮助你：</p><p><strong>建立长时记忆</strong>  一旦展开复述，我们就不得不回忆刚刚学到的内容，就像放电影一样。那些短时记忆从大脑中纷纷被调取出来，经过梳理、强化和初步形成知识系统，其中重要的部分便转化为了长时记忆。这个原理很简单，我们都知道------默读过的知识如果再朗读一遍，记得便尤为清楚。</p><p><strong>加深对知识的理解</strong>  在复述知识时，相当于你沿着自己的学习思路和知识的逻辑又走了一遍，对知识的要点、立论和逻辑体系的认知更加明确，理解也更加深入，还可以发现很多学习时被忽视的细节。我在读书时常常温习两到三遍才能悟到原先没领会到的作者的意图。这么做总能加深你对知识的印象。</p><p><strong>更加主动地学习</strong>  当你将复述作为一项任务加入学习计划中时，学习的过程中，你就能有意识和主动地对知识的重要部分加强理解，对论点、论证过程和逻辑基础也就更为敏感。这样一来，被动学习便过渡到了主动学习，提高了学习的效能。如果你没有一个复述的想法，学习时大脑逮着机会就会偷懒，它抱着完成任务的心态敷衍你，学习的效果往往不如预期。</p><p><strong>对知识展开联想</strong>  复述不只是对知识背诵、整理一遍或只介绍大概，而是会让你发现过去不曾有过的想法，或者突然冒出新的思路。你自己的观点和所学的知识在复述的过程中彼此碰撞交融，产生灵感的火花。这会带来意外的收货，为你扩展学习的视野。</p><p><strong>得到关于问题的反馈</strong>  需要一提的是，有很多公认的“好知识”盛名之下其实难副，权威的观点和论证也并非不存在问题，复述能帮助你尽可能发现那些与实际应用不相符合的内容。在复述时你可以对知识中的某一个论点、论据或论证逻辑提出自己的疑问，再从温习中找到反馈。这能为你养成很好的学习习惯。</p><h3 id="Output">Output</h3><p>设定一个传授的场景，当我们要输出这些知识时，才会真正清楚自己究竟掌握了多少，发现那些还需要强化和加深理解的内容。</p><h4 id="以教代学的原则">以教代学的原则</h4><ul><li><p>语言简洁易懂</p></li><li><p>精准到位，没有歧义</p></li><li><p>讲出一定的深度</p></li><li><p>加上自己的理解</p></li></ul><h4 id="输出的记忆学原理">输出的记忆学原理</h4><p>在记忆学的研究中，科学家认为记忆是过去的经验在人大脑中的反映，它不但是神经活动，还是一种复杂的心理活动。虽然神经细胞承担着记忆的主要责任，但人的心理活动却影响着记忆最终的结果。记忆的行程包括了 **识记、保持、再现和回忆 ** 四个基本环节，每个环节都不可或缺，也都由神经细胞和心理活动共同完成。</p><p><strong>识记------编码</strong>  我们的感官系统对于外界的刺激并非是悉数接收，不存在不加以区别便全部输入大脑的情况。因此识记信息时大脑有一个编码的步骤，即精准地识别信息，记录信息，把那些应该被记忆的内容挑选出来。</p><p><strong>保持------存储</strong>  存储信息就是大脑形成神经回路的过程，也就是使神经元的连接越发紧密并产生定式，这个定式就是神经回路。我们的眼睛、耳朵等感觉系统获得信息以后，先存储在“感觉区”内，时间非常短，此时尚属于短时记忆，也叫第一印象，等待大脑加工处理，然后把信息传入“海马区”。在这里，海马神经的细胞回路网络受到连续的刺激，加强了突触的结合时间，信息停留的时间被延长了，便产生了“第一级记忆”。</p><p><strong>再现------检索</strong>  当我们需要输出知识时，对记忆而言一个重要的变化将会产生。如同平地起惊雷，大脑将开启管理知识的新模式------从单向的输入转变为同步的输出和输入。输出知识时，我们的大脑内要准确地再次呈现神经元反映的信息，指导合成信息蛋白并把知识再现出来。在这个过程中，我们还要从大脑中找到信息，检索那些关键的部分。</p><p><strong>回忆------巩固</strong>  我们学到的知识如果不加以复习，结果注定是遗忘。输出就是一次高质量的复习，起到巩固记忆和提炼核心知识的目的。通过有针对性的、反复地输出，长时记忆甚至可以转化为永久记忆，做到终生不忘。我们在生活和工作中不假思索便能运用的知识，大部分都源于长时记忆或者永久记忆。</p><p>因为从记忆学的角度看，在输出相关的知识时，等于我们的大脑不断地重复记忆的四个环节：<strong>识记、保持、再现和回忆</strong>，一遍又一遍地开垦这个知识，倒逼输入，也加快记忆和理解。</p><h4 id="第二次复述">第二次复述</h4><p>第一次复述是把自己当做倾听者，第二次复述是进入一个真实的传授知识的场景，向别人甚至多个人阐述你对某项知识的看法。</p><ul><li>“分组讨论”是自主学习的一种高效方式</li><li>帮助你设计复述提纲并且准备一些问题</li><li>从听者那里获得中肯的评价和异议</li></ul><h3 id="Block">Block</h3><p>通过回顾和反思，对学习的不满意之处进行纠错，发现缺口，并用更精炼的语言概括自己掌握的知识。</p><h4 id="重新对比数据和事实">重新对比数据和事实</h4><ul><li><p>重新检查知识库</p></li><li><p>重新验证知识的关联</p></li></ul><h4 id="回顾原则">回顾原则</h4><p><strong>怀疑和探索</strong>  确保数据和事实是准确、精确和经过科学统计的。对未知保持强烈的好奇心，怀疑一切定论，哪怕它是权威定论。探索知识的本质和背后的问题，而不是仅记住知识的内容。</p><p><strong>寻找反证</strong>  否定式的证据具有无比重要的作用，对此不能刻意忽略。对薄弱环节要多方搜集信息，从多个角度加强理解，并提出自己的看法。重视争议性的观点，从让人困惑的争议中获取比黄金还珍贵的知识点。</p><p><strong>提升“内容留存率”</strong>  追求学习的效能，而不是知识的数量。将主要精力放到有用的学习上，也就是重复理解那些“有用的知识”。加大内容留存率，我们需要拥有“原理性思维”。</p><h3 id="Simplify">Simplify</h3><p>学习的最终目的，是抽取我们需要的东西，形成自己的知识体系。</p><h4 id="简化知识的要点">简化知识的要点</h4><p><strong>打开知识的“重要性开关”</strong>  即，哪些知识很重要，哪些知识一般重要，哪些知识不重要。为它们列一个优先级，排好顺序，全力吸收那些重要的知识。</p><p><strong>将知识从复杂回归简单</strong>  费曼认为，所有复杂的知识体系都有一个简单的核心逻辑，就像一团乱麻会有一根总的线头，找到这个线头往外一拽，这团乱麻便轻松地被化解了。要把学到的知识简化，我们就要提升自己的思考维度，站在高处往下看，找到里面的那个核心。</p><h4 id="形成自己的知识体系">形成自己的知识体系</h4><p>什么是我们自己的知识体系？通俗地说，就是我们可以将零碎分散、相对独立的知识和概念吸收转化为自己的东西，赋予他们逻辑，并且有效地运用这些知识。当你拥有自己的知识体系以后，解决问题时就可以形成自己的方法论。在学习时，也能有目的地挑选正确和满足自身需求的内容；吸收知识时，也能做到合理地筛选、归纳和整理，使不同来源、观点的知识为己所用，发挥应有的作用。</p><p>为了实现这个目标，我们需要养成对知识深度挖掘和深度学习的习惯。在深度挖掘和深度学习时，最好使用多种工具，比如重要内容摘录、画出知识图谱、标记核心要点、内容分类、概要总结等。</p><h4 id="“深度”的标准">“深度”的标准</h4><p><strong>技能的延伸和强化</strong>  让学习的过程不仅是解决一个问题，而是能够开拓新的领域，并且创造新的知识。</p><p><strong>对知识的前瞻性理解</strong>  深度挖掘知识的核心要素和其他问题的内在联系，掌握基本的原理和规律，然后提出前瞻性的见解。</p><p><strong>对知识的系统性强化</strong>  经过富有深度的学习，我们能打通不同领域的界限，优化自己的知识系统，开阔视野，从各个层面提高思考问题、解决问题的能力。</p><h4 id="碎片化学习的弊端">碎片化学习的弊端</h4><ul><li><p>你学的只是一堆空洞的结论而非丰满的逻辑</p></li><li><p>你所做的简化过程删除了最重要的推演环节</p></li><li><p>你的学习把多元化的辩证分析变成了一元化的立场总结</p></li><li><p>你只记住了表面的事实，没有发现背后的原理</p></li></ul><p><strong>长此以往，这种学习思维将彻底、完全地主宰你的行为模式，影响你的生活和工作：</strong></p><ul><li><p>你的知识不成体系，因此很难系统地、宏观地思考问题</p></li><li><p>你看待问题时容易简单化和片面化</p></li><li><p>你的思维与视野容易狭隘，看不到长远的可能性</p></li><li><p>你很难进行复杂、独立和具有深度的思考</p></li></ul><h4 id="第三次复述">第三次复述</h4><p>费曼说：“我们所有形式的学习都是为了达到三个目的：第一是解释问题，第二是解决问题，第三是预测问题。”本书倡导的第三次复述便是为了帮助读者在学习到一门知识后，可以同步实现这三个目标，能够使用自己所学的知识解释问题、解决问题和预测问题。</p><h1>划重点</h1><div class="note note-primary">            <p>学习，究其根本是 <strong>思维方式</strong> 的比拼，不是只是存储的较量，也不是学位的竞争。</p>          </div><div class="note note-secondary">            <p>作为著名的诺贝尔奖物理学家，理查德·费曼非常理解 <strong>记住知识</strong> 和 <strong>了解知识</strong> 之间的差别，这也是他成功最重要的原因之一。</p>          </div><div class="note note-success">            <p><strong>马太效应</strong>  任何个体、群体或地区，一旦在某一个方面（如金钱、名誉、地位等）获得成功和进步，就会产生一种积累优势，就会有更多的机会取得更大的成功和进步。</p>          </div><div class="note note-danger">            <p>学习不只是为了记住什么，而是我们通过学习建立自己行之有效的思维框架，并将知识运用到实践中，解决生活和工作中的实际问题。</p>          </div><div class="note note-warning">            <p>人要尽量保持童真，因为童真的心态能扩大你的视野，让你愿意并且能够在这个世界中看到更多的“可能性”。</p>          </div><div class="note note-info">            <p>从长远来看，阅读和记忆并不是一场数量的比赛。</p>          </div><div class="note note-light">            <p>在学习中，经验保证你的下限，好奇心则决定着你的上限。</p>          </div><div class="note note-primary">            <p>有时候你得到的知识根本称不上知识，充其量只是一堆信息。</p>          </div><div class="note note-secondary">            <p>主动的学习远比被动的学习重要；<br>系统的学习远比碎片式学习重要；<br>向内的学习远比向外的学习重要；<br>专业的学习远比跨界的学习重要。</p>          </div><h1>后记</h1><p>发现这本书的契机是离职后与前 Leader 的一段交谈，他对我的评价是很勤奋很上进，但是需要注意效率，他向我推荐了《费曼学习法》，读了一遍感觉受益匪浅。我自诩是一个比较勤奋的人，可以花很长时间沉下心来学习我认为重要的知识，但现在看来，之前的很多学习实际的转化率很低，有些已经完全忘干净了，究其原因还是在于学习的方法。我之前是不太相信什么方法论的，认为跟成功学之类的书一样云里雾里，但这本书确实对我来说是有用的，可以解答我职业生涯这几年工作学习中的一些困惑。</p><p>首先是学习目标的选取。来到七牛做售后工程师，需要学习的东西有很多，也比较杂。为了能跑通各业务线的接口，我学习了 python；为了理解云主机和容器，我学习了 linux、docker、k8s；为了能对接 web 端实时音视频的客户，我学习了前端开发；为了在公司能混下去，我学了 go（卑微。。。）。可以发现每次制定的学习目标，就仅是为了“跑通接口”或者“跑通Demo”，可以支持客户回答问题即可，没有更深度的学习，也没有形成对应的知识体系。学到的这些东西对我来说是碎片化的，充其量只能称为“信息”，而不是成体系的知识。这可能也跟技术支持这个岗位性质有一定关系，每天都有大量客户反馈各种产品线的问题，这种工作状态下的多领域学习很难不是浅尝辄止。</p><p>其次是成体系化的知识摄取。之前一直在想一个问题，为什么往往自学的效率没有参加系统培训的效率高，主要原因之一是，自学时由于对知识领域的不了解，很难以一个全局的视角俯看整体知识框架，没有框架的学习往往是漫无目的的，而那些系统培训班一般会在第一课讲义里画出这门课的整体架构思维导图，可以对这门知识需要学习哪些内容有清晰认识，可以根据不同模块儿的重要性分配学习时间， 这样学习往往效率会很高。我是去年参加完 LiveVideoStack 论坛后对音视频研发产生了极大的兴趣和向往，这对我来说是件好事，因为终于找到自己喜欢的，可以专心研发的方向了。对于音视频研发，首先赛道不错，选择这个方向深耕对我来说是一个不错的目标定位，那接下来就是知识的获取了，一定要摒弃之前浅尝辄止的思维习惯，也不可在不重要的知识点上浪费太长时间，学习之前先制定思维导图，明确自己要学什么并合理安排时间。信息化的时代能学习的东西实在太多，曾经有大佬说过：“这个时代拼勤奋已经来不及了”，我觉得有点绝对，主要还是效率和思维方式的提升，有个好的学习方法，剩下的，卷就完了。</p><p>费曼学习法的核心是输出，即以传授者的角度输出知识，倒逼自己完善知识体系，形成长时记忆。以输入为目的学习，总感觉会缺乏一些是否彻底学会的衡量标准，而以输出为目的的学习则是以听者能听懂并理解作为最终目标，这一点在写技术博客时体会比较深。写博客也是一个检验知识体系完整性、准确性和不断简化吸收的过程，虽然博客不见得有人一起交流讨论，但至少在写博客时，我是抱着能让别人看得懂的心态来写的，这也足以让我受益匪浅，面试时那些被我总结写进博客里的内容总是可以回答的很好。以输出为目的的学习是费曼学习法的核心，但在本书中用来介绍输出的部分只占了很小一个章节，其实也可以理解，费曼学习法总结起来就那么几句话，作者肯定是要以此为基础来发散，不然哪来的稿费。有些章节的内容确实很有帮助，比如 Select 和 Input 的章节，介绍了很多实用的方法，但是后几章就觉得写的有些空洞，经常会看到一些“给知识注入灵魂”这种比较玄幻的内容，看起来很有道理，但对实践毫无帮助，太虚了。不过整体来说对我还是有帮助，特别是对这个时期的我。休息的这3个月让我有时间去想一些事情，平时工作太忙就会容易陷入到一种“毛驴拉磨”的陷阱，很勤奋但不注重方式方法，结果也只能是在原地画圈。希望自己可以尽快丢弃掉这种思维方式，将从费曼学习法学到的运用到日常的工作生活中，多互动多交流，用市场来检验自己的学习成果，早日成为一枚高效能的卷王！</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>认知心理学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 端 ijkplayer 源码分析目录</title>
    <link href="/2022/05/30/iOS-%E7%AB%AF-ijkplayer-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%9B%AE%E5%BD%95/"/>
    <url>/2022/05/30/iOS-%E7%AB%AF-ijkplayer-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>ijkplayer 是 B 站开发的一款业界公认比较优秀的播放器框架，项目是开源的，所以也给音视频开发者提供了很好的学习资料。最近花了大概两周的时间整体看了一遍源码，学到了很多东西，也有些没有弄清楚的点，所以想借着写博客的机会分块再将 ijkplayer 的流程捋一遍，让自己这半个月的源码学习更有价值。</p><h1>播放器流程</h1><p>这里先贴一个雷神博客上的播放器流程图：</p><p><img src="/resources/image/20140201120523046.jpeg" alt="播放器流程图-雷霄骅"></p><p>一般在看播放器源码之前，需要先了解播放器的工作流程，将各阶段拆分开来阅读源码，思路会清晰一些。</p><p>每个阶段的具体分工，雷神的博客上有详细的讲解可以参考：<a href="https://blog.csdn.net/leixiaohua1020/article/details/18893769">https://blog.csdn.net/leixiaohua1020/article/details/18893769</a></p><h1>ijkplayer 整体框架</h1><p>iOS 端 ijkplayer 的上层框架如图：</p><p><img src="/resources/image/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%282%29.png" alt="ijkplayer 上层框架"></p><p>可以看到 ijkplayer 包含三种不同类型的播放器，为了方便 App 层接入使用，它们遵循同一套接口协议 IJKMediaPlayback，但底层框架和接口实现是不同的。IJKAVMoviePlayerController 基于 AVPlayer，IJKMPMoviePlayerController 基于更老一些的 MediaPlayer，它们都基于系统框架，底层的功能实现是看不到的，一般只要会使用就 OK。区别于前两者，IJKFFMoviePlayerController 基于 FFMPEG，准确地说 ijkplayer 是在 ffplay.c 的基础上做了 c 代码层的改造，虽然 FFMPEG 接口帮助完成了解协议、解封装和解码的操作，但仍需我们将整个流程串联起来，为每个阶段提供必要的缓存和操作线程控制，解码后的音视频数据的同步处理，音视频的渲染（ijkplayer 自己实现的一套 SDL），以及对顶层接口的适配等等，整个流程还是比较复杂的，所以会看到 ijkplayer 源码中定义了大量的成员变量，大部分都是没有注释的，需要结合代码一点点去理解它们代表的含义，这些也正是需要学习的东西。</p><p>ijkplayer（之后统一指 IJKFFMoviePlayerController）的整体流程图可以简化为：</p><p><img src="/resources/image/ijkplayer%E6%B5%81%E7%A8%8B.png" alt="转载自 http://yydcdut.com/2019/07/06/ijkplayer-video-audio-sync/"></p><p>上面提到过看播放器的源码最好是将功能拆分来看，可以看到最左侧的 stream_open 是整个流程的开始，调用 stream_open 之前主要是初始化相关的代码。stream_open 函数创建了两个线程，读取流数据线程（执行函数为 read_thread）和视频渲染线程（执行函数为 video_refresh）。read_thread 函数会先解析流信息，创建解码线程，并开始尝试从流中获取解码前的数据，将其发送的 Packet Queue。创建的解码线程基于数据流中 stream 的个数，音频解码线程执行函数为 audio_thread，视频解码线程执行函数为 video_thread，字幕解码线程执行函数为 subtitle_thread（图中没有画出来）。解码线程会不停像 Packet Queue 要解码前的数据，将其送到解码器解码，同时解码线程也会轮询解码器看是否有解码完成的原始数据帧，如果有就将它送进 Frame Queue。之后就是渲染线程不停地问 Frame Queue 要数据，这里有一个疑问，read_thread 中创建了视频渲染线程，但没有创建音频的，这是因为在 iOS 端音频输出使用的是 Audio Queue 或者更底层的 Audio Unit，系统框架会在 AU 的 remote_io 线程回调函数问上层去要数据，所以就不用额外创建了。渲染线程拿到各自想要的数据后，还需要做音视频同步，同步的方式有很多种，ijkplayer 默认使用的是视频向音频同步，因为对于画面来说，人类对于音频的不连续会更敏感一些。同步完成后就可以将数据提交给硬件去渲染了，iOS 平台音频使用 Audio Queue 来渲染，视频则将数据生成纹理，使用 OpenGL 渲染。</p><p>可以看到上图中其实就包含了 ijkplayer 的大部分工作流程，流程图非常清晰，后续的博客也会基于这张图的流程对源码做一个纵向的分析，同时也会总结一些这张图上没有的功能点，比如 seek 功能的实现，消息机制的设计和字幕流的处理，帮助更好的熟悉和理解源码。</p><h1>源码分析目录</h1><p>iOS 端 ijkplayer 源码分析 - 数据流的读取和解封装</p><p>iOS 端 ijkplayer 源码分析 - 视频流的解码</p><p>iOS 端 ijkplayer 源码分析 - 音频流的解码</p><p>iOS 端 ijkplayer 源码分析 - 字幕流的解码</p><p>iOS 端 ijkplayer 源码分析 - 视频流的渲染</p><p>iOS 端 ijkplayer 源码分析 - 音频流的渲染</p><p>iOS 端 ijkplayer 源码分析 - 字幕流的渲染</p><p>iOS 端 ijkplayer 源码分析 - 音视频同步</p><p>iOS 端 ijkplayer 源码分析 - seek 的实现</p><p>iOS 端 ijkplayer 源码分析 - 消息机制</p><h1>后记</h1>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ijkplayer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 编译 ijkplayer</title>
    <link href="/2022/05/13/iOS-%E7%BC%96%E8%AF%91-ijkplayer/"/>
    <url>/2022/05/13/iOS-%E7%BC%96%E8%AF%91-ijkplayer/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>最近想看看 ijkplayer 的源码，学习下 ffmpeg，这篇先记录下 iOS 端编译支持 SSL 的 ijkplayer framework。</p><h1>编译过程</h1><p>首先将 ijkplayer 下载到本地：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git clone git@github.com:bilibili/ijkplayer.git<br></code></pre></div></td></tr></table></figure><p>下载好的仓库在 k0.8.8的 Tag 上切分支：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git checkout -B develop k0.8.8<br></code></pre></div></td></tr></table></figure><p>进入仓库目录，我们编译用到的相关脚本是截图中红框部分：</p><p><img src="/resources/image/ijk.png" alt="ijkplayer 文件目录"></p><div class="note note-info">            <p><strong><a href="http://init-ios.sh">init-ios.sh</a></strong>: 将 gas-preprocessor 和 ffmpeg 下载到 extra/ 文件夹下，并将 ffmpeg 按具体架构 git clone --reference 到 ios/ 文件夹下用于编译不同的架构。</p><p><strong><a href="http://init-ios-ssl.sh">init-ios-ssl.sh</a></strong>: 将 openssl 源码下载到 extra/ 文件夹下，并将其按架构 git clone --reference 到 ios/ 文件夹下用于编译不同的架构。</p><p><strong><a href="http://compile-ffmpeg.sh">compile-ffmpeg.sh</a></strong>: 脚本调用 do-compile-ffmpeg 编译不同架构的 ffmpeg，编译后 lipo create 生成 universal 版本和头文件。</p><p><strong><a href="http://compile-openssl.sh">compile-openssl.sh</a></strong>: 脚本调用 do-compile-openssl 编译不同架构的 openssl，编译后 lipo create 生成 universal 版本和头文件。</p><p><strong>do-compile-ffmpeg</strong>: 配置编译参数，按架构编译 ffmpeg。</p><p><strong>do-compile-openssl</strong>: 配置编译参数，按架构编译 openssl。</p>          </div><p>如果不需要支持 ssl 按以下顺序执行脚本即可：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./init-ios.sh<br>cd ios/<br>./compile-ffmpeg.sh<br></code></pre></div></td></tr></table></figure><p>如果要支持 ssl，需要详细看下脚本内容，do-compile-ffmpeg 的 206 行有这样的代码：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">with openssl</span><br>if [ -f &quot;$&#123;FFMPEG_DEP_OPENSSL_LIB&#125;/libssl.a&quot; ]; then<br>    FFMPEG_CFG_FLAGS=&quot;$FFMPEG_CFG_FLAGS --enable-openssl&quot;<br><br>    FFMPEG_CFLAGS=&quot;$FFMPEG_CFLAGS -I$&#123;FFMPEG_DEP_OPENSSL_INC&#125;&quot;<br>    FFMPEG_DEP_LIBS=&quot;$FFMPEG_CFLAGS -L$&#123;FFMPEG_DEP_OPENSSL_LIB&#125; -lssl -lcrypto&quot;<br>fi<br></code></pre></div></td></tr></table></figure><p>do-compile-ffmpeg 脚本会先去当前架构下 openssl 的编译目录查看是否有编译好的 libssl.a 以此作为是否需要支持 ssl 的依据，所以在调用 <a href="http://compile-ffmpeg.sh">compile-ffmpeg.sh</a> 脚本前需要先编译好 openssl，支持 ssl 的脚本执行顺序：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./init-ios-openssl.sh<br>./init-ios.sh<br>cd ios/<br>./compile-openssl.sh<br>./compile-ffmpeg.sh<br></code></pre></div></td></tr></table></figure><p>这样编译的 ffmpeg 会启用 ssl，编译完成后，打开 ijkplayer 的 demo 可以看到 ijkplayer 有两个静态库的 target，IJKMediaFramework 和 IJKMediaFrameworkWithSSL：</p><p><img src="/resources/image/ijkplayerframework.png" alt="ijkMediaFramework"></p><p>IJKMediaFrameworkWithSSL 的库添加了 SSL 库的引用，但工程默认依赖的是 IJKMediaFramework，为了避免修改头文件，可以给 IJKMediaFramework 添加 SSL 库的引用：</p><p><img src="/resources/image/addssl.png" alt="添加 ssl 引用"></p><p>添加好就可以 Build 项目了。</p><h1>一个坑</h1><p>不出意外编译过程中会碰到一个 armv7 的报错类似<a href="https://github.com/bilibili/ijkplayer/issues/4494">这样</a>，解决方法是在脚本里将 armv7 架构去掉：</p><p><img src="/resources/image/armv7.png" alt="删除 armv7"></p><p>如果项目有要求支持 armv7，可以尝试使用低版本的 xcode sdk 编译，上面的 issue 上有解决方法，但没有尝试。</p><h1>后记</h1><p>开始撸源码吧。</p>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ijkplayer</tag>
      
      <tag>播放器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 RTMP 协议传输</title>
    <link href="/2022/05/12/%E4%BD%BF%E7%94%A8-RTMP-%E5%8D%8F%E8%AE%AE%E4%BC%A0%E8%BE%93/"/>
    <url>/2022/05/12/%E4%BD%BF%E7%94%A8-RTMP-%E5%8D%8F%E8%AE%AE%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>Adobe 公司的实时消息传输协议 (RTMP) 通过一个可靠地流传输提供了一个双向多通道消息服务，意图在通信端之间传递带有时间信息的视频、音频和数据消息流。RTMP 是建立在 TCP 连接基础上的应用层协议，TCP 连接成功后需要再在应用层做一次握手，握手成功后客户端和服务端就可以开始交换消息了。</p><p><a href="https://github.com/ossrs/librtmp">librtmp</a> 是依据 RTMP 协议标准实现的开源库，使用起来比较简单。我们依赖的是某互联网厂商对 librtmp 维护的一个版本，在源库基础上做了优化并增加一些功能比如获取 ip 和建连时间、设置 callback 回调等等。开源库地址：<a href="https://github.com/pili-engineering/pili-librtmp">Github</a></p><h1>代码实现</h1><p>创建 PILI_RTMP 结构体，配置参数，建立连接：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTMP_RECEIVE_TIMEOUT    2</span><br><br>...<br>  <span class="hljs-comment">// 初始化 PILI_RTMP</span><br>  PILI_RTMP* rtmp = PILI_RTMP_Alloc();<br>    <span class="hljs-keyword">if</span> (!rtmp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    PILI_RTMP_Init(rtmp);<br>    <br>    rtmp-&gt;m_tcp_nodelay = <span class="hljs-number">0</span>;<br>    rtmp-&gt;m_errorCallback = RTMPErrorCallback;<br>    rtmp-&gt;m_userData = (__bridge <span class="hljs-type">void</span> *)<span class="hljs-keyword">self</span>;<br>    rtmp-&gt;Link.timeout = RTMP_RECEIVE_TIMEOUT;<br>    rtmp-&gt;m_connCallback = ConnectionTimeCallback;<br><br><span class="hljs-comment">//设置URL</span><br>    <span class="hljs-keyword">if</span> (PILI_RTMP_SetupURL(_rtmp, push_url, &amp;_error) == <span class="hljs-literal">FALSE</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-comment">//设置可写，即发布流，这个函数必须在连接前使用，否则无效</span><br>    PILI_RTMP_EnableWrite(_rtmp);<br><br>    <span class="hljs-comment">//连接服务器</span><br>    <span class="hljs-keyword">if</span> (PILI_RTMP_Connect(_rtmp, <span class="hljs-literal">NULL</span>, &amp;_error) == <span class="hljs-literal">FALSE</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//连接流</span><br>    <span class="hljs-keyword">if</span> (PILI_RTMP_ConnectStream(_rtmp, <span class="hljs-number">0</span>, &amp;_error) == <span class="hljs-literal">FALSE</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>...<br></code></pre></div></td></tr></table></figure><p>PILI_RTMP_SetupURL 函数用来解析 URL 构造 PILI_RTMP_LNK 结构体用于网络连接，PILI_RTMP_EnableWrite 告知 librtmp 我们希望推送 RTMP 而不是播放。</p><p>PILI_RTMP_Connect 函数主要是完成 TCP 连接、RTMP 握手和发送 connect 消息：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">...<br>  <span class="hljs-type">int</span> t1 = PILI_RTMP_GetTime();<br><span class="hljs-comment">// tcp 连接</span><br>    <span class="hljs-keyword">if</span> (!PILI_RTMP_Connect0(r, cur_ai, port, error)) &#123;<br>        freeaddrinfo(ai);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>    &#125;<br>    conn_time.connect_time = PILI_RTMP_GetTime() - t1;<br>    r-&gt;m_bSendCounter = <span class="hljs-literal">TRUE</span>;<br><br>    <span class="hljs-type">int</span> t2 = PILI_RTMP_GetTime();<br><span class="hljs-comment">// rtmp 握手、发送 connect 消息</span><br>    <span class="hljs-type">int</span> ret = PILI_RTMP_Connect1(r, cp, error);<br>    conn_time.handshake_time = PILI_RTMP_GetTime() - t2;<br><br>    <span class="hljs-keyword">if</span> (r-&gt;m_connCallback != <span class="hljs-literal">NULL</span>) &#123;<br>        r-&gt;m_connCallback(&amp;conn_time, r-&gt;m_userData);<br>    &#125;<br>...<br></code></pre></div></td></tr></table></figure><p>连接 wireshark 抓包看下这个函数产生的数据包交互：</p><p><img src="/resources/image/wireshark-rtmp.png" alt="wireshark-connect"></p><p>Protocol 为 RTMP 的消息是 wireshark 帮忙解析出的应用层数据，可以看到客户端和服务端 TCP 握手成功后，客户端发送了 C0+C1 的握手消息，服务端收到后返回 S0+S1+S2，客户端收到后返回 C2 完成握手。随后客户端发送 connect 消息连接到应用 “pursue-online”，服务端发送窗口大小、对端带宽大小和 Chunk 大小的消息给客户端用来初始化网络出口和数据大小，其实这个服务端的包里还有一个消息是对客户端的 connect 的消息回复的 result，wireshark 没有显示出来。由于客户端断点没有做后续处理，服务端超过超时时间断开了 TCP 连接。</p><p>PILI_RTMP_ConnectStream 函数会循环读取从服务端收到的数据包（就是解析上图中蓝色背景的这条从服务端过来的数据）：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">...<br>    <span class="hljs-keyword">while</span> (!r-&gt;m_bPlaying &amp;&amp; PILI_RTMP_IsConnected(r) &amp;&amp; PILI_RTMP_ReadPacket(r, &amp;packet)) &#123;<br>            <span class="hljs-keyword">if</span> (RTMPPacket_IsReady(&amp;packet)) &#123;<br>                <span class="hljs-keyword">if</span> (!packet.m_nBodySize)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO) ||<br>                    (packet.m_packetType == RTMP_PACKET_TYPE_VIDEO) ||<br>                    (packet.m_packetType == RTMP_PACKET_TYPE_INFO)) &#123;<br>                    PILI_RTMP_Log(PILI_RTMP_LOGWARNING, <span class="hljs-string">&quot;Received FLV packet before play()! Ignoring.&quot;</span>);<br>                    PILI_RTMPPacket_Free(&amp;packet);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                PILI_RTMP_ClientPacket(r, &amp;packet);<br>                PILI_RTMPPacket_Free(&amp;packet);<br>            &#125;<br>        &#125;<br>...<br></code></pre></div></td></tr></table></figure><p>解析得到的消息有 4 个，分别是 0x05 设置窗口大小、0x06 设置带宽大小、0x01 设置 chunk 大小 以及 0x14 用来回复 connect 命令的 result，在收到 0x05、0x06、0x01 时 librtmp 更新了本地的配置，当收到 0x14 这条 connect 的 result 时，客户端确定成功链接到 App，于是发送 releaseStream 命令让服务端先将该流释放，然后发送 FCPublish 和 createStream 命令在 App 中创建流，收到服务端 createStream 的 result 后，客户端发送 publish 命令表明开始推流，服务端收到后返回 onStatus，客户端解析 OK 后将 isPlaying 标志位设置为 YES，表示可以开始推流音视频数据：</p><p><img src="/resources/image/wireshark-connect.png" alt="wireshark-connect"></p><p>接着是发送音视频数据包，librtmp 将数据单元抽象成 RTMPPacket 的结构体，需要使用 Tag Header 的属性参数和 Tag Body 的数据指针构建出 RTMPPacket，然后通过 RTMP_SendPacket 函数发送出去：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">...<br>PILI_RTMPPacket packet;<br>    PILI_RTMPPacket_Reset(&amp;packet);<br>    PILI_RTMPPacket_Alloc(&amp;packet, data_size);<br><br><span class="hljs-keyword">if</span> (FLV_TAG_TYPE_VIDEO == tag_type) &#123;<br>        pkt-&gt;m_packetType = tag_type; <span class="hljs-comment">// video 0x09</span><br>        pkt-&gt;m_nBodySize = data_size; <span class="hljs-comment">// body size</span><br>        pkt-&gt;m_nTimeStamp = timestamp;<br>        pkt-&gt;m_nChannel = <span class="hljs-number">0x06</span>;<br>        pkt-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE;<br>        pkt-&gt;m_nInfoField2 = m_stream_id;<br>        pkt-&gt;m_hasAbsTimestamp = <span class="hljs-number">0</span>;<br>        <br>        memcpy(pkt-&gt;m_body, data, data_size);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (FLV_TAG_TYPE_AUDIO == tag_type) &#123;<br>        pkt-&gt;m_packetType = tag_type; <span class="hljs-comment">// audio 0x08</span><br>        pkt-&gt;m_nBodySize = data_size; <span class="hljs-comment">// body size</span><br>        pkt-&gt;m_nTimeStamp = timestamp;<br>        pkt-&gt;m_nChannel = <span class="hljs-number">0x04</span>;<br>        pkt-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE;<br>        pkt-&gt;m_nInfoField2 = m_stream_id;<br>        pkt-&gt;m_hasAbsTimestamp = <span class="hljs-number">0</span>;<br>        <br>        memcpy(pkt-&gt;m_body, data, data_size);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (FLV_TAG_TYPE_SCRIPT == tag_type) &#123;<br>        pkt-&gt;m_packetType = tag_type; <span class="hljs-comment">// script 0x12</span><br>        pkt-&gt;m_nBodySize = data_size; <span class="hljs-comment">// body size</span><br>        pkt-&gt;m_nTimeStamp = timestamp;<br>        pkt-&gt;m_nChannel = <span class="hljs-number">0x04</span>;<br>        pkt-&gt;m_nInfoField2 = m_stream_id;<br>        pkt-&gt;m_hasAbsTimestamp = <span class="hljs-number">0</span>;<br>        <br>        memcpy(pkt-&gt;m_body, data, data_size);<br>    &#125;<br><br>RTMPError error = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">if</span> (!PILI_RTMP_SendPacket(rtmp, &amp;packet, <span class="hljs-number">0</span>, &amp;error)) &#123;<br>        PILI_RTMPPacket_Free(&amp;packet);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    PILI_RTMPPacket_Free(&amp;packet);<br>...<br></code></pre></div></td></tr></table></figure><p>wireshark 抓包可以看到，第一个包负载的是 metadata，也就是 FLV 的 script tag，之后交替的是 audio 和 video tag：</p><p><img src="/resources/image/wireshark-stream.png" alt="wireshark-stream"></p><p>使用完别忘了关闭连接释放资源：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">...<br>  PILI_RTMP_Close(rtmp, <span class="hljs-literal">NULL</span>);<br>    PILI_RTMP_Free(rtmp);<br>    rtmp = <span class="hljs-literal">NULL</span>;<br>...<br></code></pre></div></td></tr></table></figure><h1>后记</h1><p>这篇主要是介绍下 iOS 平台 RTMP 协议推流的功能实现，没有涉及太多的协议内容，RTMP 协议内容还是比较多的，需要大量的时间去研究和实践，文末会贴一些官方翻译文档和工具库。</p><p>至此，推流的整个流程就都完成了，从采集、渲染、编码、封装再到传输都有了一个大致的了解，每个模块都学到了很多东西，对我自己来说是一个很大的提升了，而这些也仅仅是音视频开发最基础的部分。作为一个商用的音视频 SDK 还要考虑如何将这些模块合理编排，如何封装接口兼容每一项配置，并通过大批量的用户接入打磨框架和接口。有了一个稳定框架的基础，就可以做一些有意思的事情，比如图像和声音的处理，抗弱网的策略，协议层面的优化等等，音视频技术深不见底也望不到边，需要学习的还很多，加油骚年！</p><h1>参考文档</h1><blockquote><p>RTMP 协议规范（中文版） <a href="https://www.cnblogs.com/Kingfans/p/7083100.html">https://www.cnblogs.com/Kingfans/p/7083100.html</a></p><p>带你吃透 RTMP <a href="https://www.jianshu.com/p/b2144f9bbe28">https://www.jianshu.com/p/b2144f9bbe28</a></p><p>手撕 RTMP 协议细节 <a href="https://cloud.tencent.com/developer/article/1630596?from=article.detail.1633286">https://cloud.tencent.com/developer/article/1630596?from=article.detail.1633286</a></p><p>librtmp <a href="https://github.com/ossrs/librtmp">https://github.com/ossrs/librtmp</a></p><p>pili-librtmp <a href="https://github.com/pili-engineering/pili-librtmp">https://github.com/pili-engineering/pili-librtmp</a></p><p>LFLiveKit（iOS 开源推流 SDK）<a href="https://github.com/LaiFengiOS">https://github.com/LaiFengiOS</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FLV 协议封装</title>
    <link href="/2022/05/10/FLV-%E5%8D%8F%E8%AE%AE%E5%B0%81%E8%A3%85/"/>
    <url>/2022/05/10/FLV-%E5%8D%8F%E8%AE%AE%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>这篇简单记录一下 FLV 的封装过程。</p><h1>FLV 封装格式简介</h1><p>FLV（Flash Video）是 Adobe 公司设计开发的一种流行的流媒体格式，由于其视频文件体积轻巧、封装简单等特点，使其很适合在互联网上进行应用。此外，FLV 可以使用 Flash Player 进行播放，而 Flash Player 插件已经安装在全世界绝大部分浏览器上，这使得通过网页播放FLV视频十分容易，FLV封装格式的文件后缀通常为“.flv”。</p><p>FLV 数据流由一个个的 Tag 组成，一个 FLV 中最多只能包含一路视频流和一路音频流，同一个类型的 Tag 也不能定义多条独立的流。另外 FLV 在存储时使用大端，所以在写入数据时需要注意字节序的转换。</p><p>FLV 的基本结构：</p><p><img src="/resources/image/flv%E7%BB%93%E6%9E%84.png" alt="flv结构"></p><p>可以看到 FLV 的结构相对比较简单，由一个固定长度的 FLV Header 和包含若干 Tag 的 FLV Body 构成，Tag 的类型可以是 Audio（音频数据）、Video（视频数据） 或 Script（元数据），每个 Tag 前面有一个 PreviousTagSize 字段用来标识前一个 Tag 的长度。</p><h2 id="FLV-Header">FLV Header</h2><p>FLV Header 是整个 FLV 文件的开始，固定长度为 9 个字节，它包含以下字段：</p><table><thead><tr><th>字段</th><th>字段长度/类型</th><th>字段内容</th></tr></thead><tbody><tr><td>Signature</td><td>UI8</td><td>签名字段，总是 0x46，‘F’</td></tr><tr><td>Signature</td><td>UI8</td><td>签名字段，总是 0x4C，‘L’</td></tr><tr><td>Signature</td><td>UI8</td><td>签名字段，总是 0x56，‘V’</td></tr><tr><td>Version</td><td>UI8</td><td>版本号，0x01 代表 FLV version 1</td></tr><tr><td>TypeFlagsReserved</td><td>UB[5]</td><td>保留字段，必须是 0</td></tr><tr><td>TypeFlagsAudio</td><td>UB[1]</td><td>如果是 1 说明 FLV 中包含音频 Tag</td></tr><tr><td>TypeFlagsReserved</td><td>UB[1]</td><td>保留字段，必须是 0</td></tr><tr><td>TypeFlagsVideo</td><td>UB[1]</td><td>如果是 1 说明 FLV 中包含视频 Tag</td></tr><tr><td>DataOffset</td><td>UI32</td><td>FLV Body 距离文件起始位置的偏移量，即 FLV Header 的长度。在 FLV version 1 中固定是 9。</td></tr></tbody></table><h2 id="FLV-Body">FLV Body</h2><p>从第 10 个字节开始是 FLV Body，包含多个 PreviousTagSize 和 Tag 的组合对：</p><table><thead><tr><th>字段</th><th>字段长度/类型</th><th>字段内容</th></tr></thead><tbody><tr><td>PreviousTagSize0</td><td>UI32</td><td>由于 PreviousTagSize0 前面没有 Tag 所以一定是 0</td></tr><tr><td>Tag1</td><td>FLVTAG</td><td>第一个 Tag</td></tr><tr><td>PreviousTagSize1</td><td>UI32</td><td>Tag1 的长度（Tag Header + Tag Body）</td></tr><tr><td>Tag2</td><td>FLVTAG</td><td>第二个 Tag</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table><h3 id="PreviousTagSize">PreviousTagSize</h3><p>表示前一个 Tag 的长度，固定为 4 字节的无符号整型。</p><h3 id="Tag">Tag</h3><p>Tag 用来负载实际的数据，为了标识 Tag 的类型和其他信息，又将 Tag 拆分成 Tag Header 和 Tag Body：</p><h4 id="Tag-Header">Tag Header</h4><p>固定长度为 11 个字节，包含以下字段：</p><table><thead><tr><th>字段</th><th>字段长度/类型</th><th>字段内容</th></tr></thead><tbody><tr><td>TagType</td><td>UI8</td><td>标识 Tag 类型<br />8：audio<br />9：video<br />18：script</td></tr><tr><td>DataSize</td><td>UI24</td><td>Tag Body 的长度</td></tr><tr><td>Timestamp</td><td>UI24</td><td>相对于第一个 Tag 的时间戳，单位为 ms<br />第一个 Tag 时间戳是 0</td></tr><tr><td>TimestampExtended</td><td>UI8</td><td>时间戳的扩展，如果 Timestamp 的 3 字节不够用，会增加 TimestampExtended 表示最高的 8 位</td></tr><tr><td>StreamID</td><td>UI24</td><td>固定是 0</td></tr></tbody></table><p>在播放回放的场景时，FLV 会始终依赖 Tag Header 里的时间戳，而忽略使用 Tag Data 负载中的时间信息。</p><h4 id="Tag-Body">Tag Body</h4><p>从 Tag Header 中可以知道这个 Tag 的类型是音频、视频还是元信息，负载的大小和时间信息，下面将这三种类型分开讨论：</p><h5 id="AudioData">AudioData</h5><p>解析音频编码数据前，需要让播放端知晓一些信息，比如编码格式、采样率、位深、声道数，播放端需要这些信息去初始化解码器，所以 AudioData 中除了音频编码数据外还有一些信息字段：</p><table><thead><tr><th>字段</th><th>字段长度/类型</th><th>字段内容</th></tr></thead><tbody><tr><td>SoundFormat</td><td>UB[4]</td><td>音频编码格式：<br />0 = Linear PCM, platform endian<br/>1 = ADPCM<br/>2 = MP3<br/>3 = Linear PCM, little endian<br/>4 = Nellymoser 16-kHz mono<br/>5 = Nellymoser 8-kHz mono<br/>6 = Nellymoser<br/>7 = G.711 A-law logarithmic PCM 8 = G.711 mu-law logarithmic PCM 9 = reserved<br/>10 = AAC<br/>11 = Speex<br/>14 = MP3 8-Khz<br/>15 = Device-specific sound</td></tr><tr><td>SoundRate</td><td>UB[2]</td><td>音频采样率，对于 AAC 总是 3：<br />0 = 5.5-kHz<br/>1 = 11-kHz<br/>2 = 22-kHz<br/>3 = 44-kHz</td></tr><tr><td>SoundSize</td><td>UB[1]</td><td>音频采样位深：<br />0 = snd8Bit<br/>1 = snd16Bit</td></tr><tr><td>SoundType</td><td>UB[1]</td><td>声道数，对于 Nellymoser 总是 0，对于 AAC 总是 1：<br />0 = sndMono<br/>1 = sndStereo</td></tr><tr><td>SoundData</td><td>UI8[size of sound data]</td><td>包含负载数据的最后一层，根据不同的编码格式，还会区分不同的结构，如果编码是 AAC，则是 AACAUDIODATA 结构</td></tr></tbody></table><h6 id="AACAUDIODATA">AACAUDIODATA</h6><p>先看看它长什么样子：</p><table><thead><tr><th>字段</th><th>字段长度/类型</th><th>字段内容</th></tr></thead><tbody><tr><td>AACPacketType</td><td>UI8</td><td>用来标识 AAC Packet 的类型<br />0: AAC sequence header<br/>1: AAC raw</td></tr><tr><td>Data</td><td>UI8[n]</td><td>如果 AACPacketType 为 0，是两字节的 AudioSpecificConfig；<br />如果 AACPacketType 为 1，是 AAC 帧数据。</td></tr></tbody></table><p>如<a href="https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Audio_Specific_Config">维基百科</a>上关于 AudioSpecificConfig（后面简称 ASC） 的描述：</p><blockquote><p>The Audio Specific Config is the global header for MPEG-4 Audio:</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-number">5</span> bits: object type<br><span class="hljs-keyword">if</span> (object type == <span class="hljs-number">31</span>)<br>    <span class="hljs-number">6</span> bits + <span class="hljs-number">32</span>: object type<br><span class="hljs-number">4</span> bits: frequency index<br><span class="hljs-keyword">if</span> (frequency index == <span class="hljs-number">15</span>)<br>    <span class="hljs-number">24</span> bits: frequency<br><span class="hljs-number">4</span> bits: channel configuration<br>var bits: AOT Specific Config<br></code></pre></div></td></tr></table></figure></blockquote><p>ASC 是 MPEG-4 定义的 AAC 的一个全局头部，它包含编码类型（object type），采样率（frequency index）、通道数（channel configuration）和 AOT Specific Config（未知，我们暂时没有用到）。可以看到有些字段在 AudioData 中是有定义过的，这里为什么会要求重新传呢？可以看下 adobe 官方文档上的解释：</p><blockquote><p>If the SoundFormat indicates AAC, the SoundType should be set to 1 (stereo) and the SoundRate should be set to 3 (44 kHz). However, this does not mean that AAC audio in FLV is always stereo, 44 kHz data. Instead, the Flash Player ignores these values and extracts the channel and sample rate data is encoded in the AAC bitstream.</p></blockquote><p>可以看到对于 AAC 格式， Adobe 的 Flash Player 并没有使用 AudioData 中的编码类型、采样率、通道数信息，而是读取的 ASC 中的信息，猜测一部分原因是 AudioData 中定义的信息类型有些局限，而 ASC 中相当于扩展了可选编码类型、采样率和通道数，使 FLV 能更好地兼容负载编码数据的特性。</p><p>由于 ASC 是一个全局的头部信息，所以在打包 Audio Tag 时，第一个 Audio Tag 需要携带 ASC（AACPacketType = 0），后续的 Audio Tag 才是 AAC 帧数据（AACPacketType = 1），后面的例子里可以看到。</p><h5 id="VideoData">VideoData</h5><p>解码视频帧之前需要让播放器知晓编码类型等其他参数用于解码，所以除了视频帧数据还有一些参数信息在 VideoData 里：</p><table><thead><tr><th>字段</th><th>字段长度/类型</th><th>字段内容</th></tr></thead><tbody><tr><td>FrameType</td><td>UB[4]</td><td>帧类型，对于 AVC 关键帧 是 1，非关键帧是 2<br />1: keyframe (for AVC, a seekable frame) <br/>2: inter frame (for AVC, a non- seekable frame)；<br/>3: disposable inter frame (H.263 only)<br/>4: generated keyframe (reserved for server use only)<br/>5: video info/command frame</td></tr><tr><td>CodecID</td><td>UB[4]</td><td>编码类型，AVC 是 7<br />1: JPEG (currently unused)<br/>2: Sorenson H.263<br/>3: Screen video<br/>4: On2 VP6<br/>5: On2 VP6 with alpha channel 6: Screen video version 2<br/>7: AVC</td></tr><tr><td>VideoData</td><td>UI8[size of video data]</td><td>根据编码类型的不同，VideoData 又分为不同的负载格式，对于 AVC 是  AVCVIDEOPACKET:<br />If CodecID == 2:  H263VIDEOPACKET<br/>If CodecID == 3 SCREENVIDEOPACKET<br/>If CodecID == 4: VP6FLVVIDEOPACKET<br/>If CodecID == 5: VP6FLVALPHAVIDEOPACKET<br/>If CodecID == 6: SCREENV2VIDEOPACKET<br/>If CodecID == 7: AVCVIDEOPACKET</td></tr></tbody></table><h6 id="AVCVIDEOPACKET">AVCVIDEOPACKET</h6><table><thead><tr><th>字段</th><th>字段长度/类型</th><th>字段内容</th></tr></thead><tbody><tr><td>AVCPacketType</td><td>UI8</td><td>标识 AVC Packet 的负载类型：<br />0: AVC sequence header<br/>1: AVC NALU<br/>2: AVC end of sequence</td></tr><tr><td>CompositionTime</td><td>SI24</td><td>当 AVCPacketType 为 1 时，CompositionTime 表示该 AVC 视频帧 pts 和 dts 的偏移，单位毫秒，AVCPacketType 不为 1 时为 0</td></tr><tr><td>Data</td><td>UI8[n]</td><td>Tag 实际负载的视频编码数据<br />AVCPacketType 为 0 时负载为 AVCDecoderConfigurationRecord 即 sps、pps；<br />AVCPacketType 为 1 时负载为一个或多个 NALU 单元；<br />AVCPacketType 为 1 时为空。</td></tr></tbody></table><p>FLV 封装 H264 时使用的是 AVCC 标准而非 AnnexB，所以 sps 和 pps 需要单独打包成 ExtraData，而不是作为一个 NALU 来发送。FLV 使用 AVCPacketType 字段标识负载是 ExtraData 还是视频帧数据 NALU，ExtraData 的字段参考：<a href="https://blog.csdn.net/yue_huang/article/details/75126155">码流格式: Annex-B, AVCC(H.264)与HVCC(H.265), extradata详解</a></p><h5 id="ScriptData">ScriptData</h5><p>ScriptData 中一般包含音视频的 meta data 信息，使用 AMF 编码，由于要支持多种数据类型和可变长度，所以相对会复杂一点，首先看下 ScriptData 的整体结构：</p><table><thead><tr><th>字段</th><th>字段长度/类型</th><th>字段内容</th></tr></thead><tbody><tr><td>Objects</td><td>SCRIPTDATAOBJECT[]</td><td>任意数量的 SCRIPTDATAOBJECT 结构</td></tr><tr><td>End</td><td>UI24</td><td>标识 ScriptData 的结束，总是 9，即 0x000009</td></tr></tbody></table><h6 id="SCRIPTDATAOBJECT-结构">SCRIPTDATAOBJECT 结构</h6><table><thead><tr><th>字段</th><th>字段长度/类型</th><th>字段内容</th></tr></thead><tbody><tr><td>ObjectName</td><td>SCRIPTDATASTRING</td><td>Object 的名称</td></tr><tr><td>ObjectData</td><td>SCRIPTDATAVALUE</td><td>Object 的内容</td></tr></tbody></table><h6 id="SCRIPTDATASTRING-结构">SCRIPTDATASTRING 结构</h6><table><thead><tr><th>字段</th><th>字段长度/类型</th><th>字段内容</th></tr></thead><tbody><tr><td>StringLength</td><td>UI16</td><td>字符串长度</td></tr><tr><td>StringData</td><td>STRING</td><td>字符串内容</td></tr></tbody></table><h6 id="还有一个长字符的-SCRIPTDATALONGSTRING-结构">还有一个长字符的 SCRIPTDATALONGSTRING 结构</h6><table><thead><tr><th>字段</th><th>字段长度/类型</th><th>字段内容</th></tr></thead><tbody><tr><td>StringLength</td><td>UI32</td><td>字符串长度</td></tr><tr><td>StringData</td><td>STRING</td><td>字符串内容</td></tr></tbody></table><p>AMF 编码的 key 一般会是一个字符串，在编码字符串前需要先编码字符串的长度，如果长度大于 UI16 Max，可以使用 SCRIPTDATALONGSTRING 拓展成 32 位表示长度，这里有个问题，拿什么来标识是 SCRIPTDATASTRING 还是 SCRIPTDATALONGSTRING？先看下 SCRIPTDATAVALUE 的结构：</p><h6 id="SCRIPTDATAVALUE-结构">SCRIPTDATAVALUE 结构</h6><table><thead><tr><th>字段</th><th>字段长度/类型</th><th>字段内容</th></tr></thead><tbody><tr><td>Type</td><td>UI8</td><td>变量的类型：<br />0 = Number type<br/>1 = Boolean type<br/>2 = String type<br/>3 = Object type<br/>4 = MovieClip type<br/>5 = Null type<br/>6 = Undefined type<br/>7 = Reference type 8 = ECMA array type 10 = Strict array type 11 = Date type<br/>12 = Long string type</td></tr><tr><td>ECMAArrayLength</td><td>仅 Type = 8 时，UI32</td><td>ECMA 数组长度</td></tr><tr><td>ScriptDataValue</td><td>If Type == 0 DOUBLE<br />If Type == 1 UI8<br />If Type == 2 SCRIPTDATASTRING<br />If Type == 3 SCRIPTDATAOBJECT<br />If Type == 4 SCRIPTDATASTRING<br />defining the MovieClip path<br />If Type == 7 UI16<br />If Type == 8 SCRIPTDATAVARIABLE[ECMAArrayLength]<br />If Type == 10 SCRIPTDATAVARIABLE[n]<br />If Type == 11 SCRIPTDATADATE<br />If Type == 12 SCRIPTDATALONGSTRING</td><td>Value 数据，定义了具体类型</td></tr><tr><td>ScriptDataValueTerminator</td><td>if Type == 3 SCRIPTDATAOBJECTEND<br />if Type == 8 SCRIPTDATAVARIABLEEND</td><td>Object 和 Array 的结束标识，对于ECMA array 结束标识为 0x000009</td></tr></tbody></table><p>如果 Type == 8，即 ECMA Array，在一字节的 Type 字段后会有 4 个字节的 ECMAArrayLength 标识数组长度，ScriptDataValue 内容类型为 SCRIPTDATAVARIABLE，数组的结束标识为 ScriptDataValueTerminator 即 0x000009。</p><h6 id="SCRIPTDATAVARIABLE-结构">SCRIPTDATAVARIABLE 结构</h6><table><thead><tr><th>字段</th><th>字段长度/类型</th><th>字段内容</th></tr></thead><tbody><tr><td>VariableName</td><td>SCRIPTDATASTRING</td><td>变量名称</td></tr><tr><td>VariableData</td><td>SCRIPTDATAVALUE</td><td>变量内容</td></tr></tbody></table><h1>实现思路</h1><p>项目依赖的 RTMP 框架是 librtmp，这个框架在发送 FLV Tag 时，只需要外层传入 Tag Body 和 Tag Header 的一些参数描述，librtmp 内部会自己打包成 FLV Tag。所以先自定义一个 flv_tag 的结构体用于描述 Tag Header 并携带 Tag Body 数据：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * FLV Tag 类型定义</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> flv_tag &#123;<br>    uint8_t     tag_type;<br>    uint32_t    data_size;<br>    uint32_t    timestamp;<br>    uint32_t    stream_id;<br>    <span class="hljs-type">void</span>        *data;  <br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> flv_tag, flv_tag_t<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> flv_tag, *flv_tag_p<br></code></pre></div></td></tr></table></figure><p>所以要做的就是用 metaData、video、audio 数据构建这个结构体，创建一个本地写入的类，先后写入 FLV Header、Script Tag、Audio &amp; Video Tag，写入完成后我们使用 ffplay 播放 FLV 文件，并使用 UltraEdit 来查看二进制流来分析。</p><h1>部分代码实现</h1><h2 id="Script-Tag-的生成">Script Tag 的生成</h2><p>首先需要根据官方文档的 AMF 编码方式生成 metaData，再封装成 flv_tag 结构体：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-keyword">define</span> kFlvScriptTagBodyLength 222</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLV_TAG_TYPE_SCRIPT ((uint8_t)0x12)</span><br><br>...<br>  <span class="hljs-comment">// 创建 script tag body 指针，kFlvScriptTagBodyLength 需要根据下边的 metadata 字段提前计算好</span><br>    uint8_t *data = malloc(kFlvScriptTagBodyLength);<br>    uint8_t *p = data;<br>  <br>    <span class="hljs-comment">// 写入1字节字符串类型 + 2字节字符串长度 + 10字节字符串 </span><br>    p = put_string(p, <span class="hljs-string">&quot;onMetaData&quot;</span>, <span class="hljs-number">10</span>);  <span class="hljs-comment">// 13</span><br>  <br>  <span class="hljs-comment">// 写入1字节 EMCA 数组类型</span><br>    p = put_byte(p, kAMFEMCAArray); <span class="hljs-comment">// 1</span><br>  <br>  <span class="hljs-comment">// 写入4字节数组长度</span><br>    p = put_be32(p, <span class="hljs-number">8</span>); <span class="hljs-comment">// 4</span><br>    <br>  <span class="hljs-comment">// 写入2字节字符串长度 + 8字节字符串 + 1字节double类型 + 8字节double值</span><br>    p = put_named_double(p, <span class="hljs-string">&quot;duration&quot;</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 8 + 11</span><br>    p = put_named_double(p, <span class="hljs-string">&quot;width&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">720</span>);  <span class="hljs-comment">// 5 + 11</span><br>    p = put_named_double(p, <span class="hljs-string">&quot;height&quot;</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1280</span>);    <span class="hljs-comment">// 6 + 11</span><br>    p = put_named_double(p, <span class="hljs-string">&quot;videocodecid&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-number">7</span>);    <span class="hljs-comment">// 12 + 11</span><br>    p = put_named_double(p, <span class="hljs-string">&quot;audiodatarate&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-number">128</span>);  <span class="hljs-comment">// 13 + 11</span><br>    p = put_named_double(p, <span class="hljs-string">&quot;audiosamplerate&quot;</span>, <span class="hljs-number">15</span>, <span class="hljs-number">48000</span>); <span class="hljs-comment">// 15 + 11</span><br>    p = put_named_double(p, <span class="hljs-string">&quot;audiocodecid&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>);   <span class="hljs-comment">// 12 + 11</span><br>    <br>  <span class="hljs-comment">// 写入2字节字符串长度 + 8字节字符串 + 1字节字符串类型 + 2字节字符串长度 + 19字节字符串</span><br>    p = put_named_string(p, <span class="hljs-string">&quot;app_name&quot;</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&quot;XPLivePusherKitDemo&quot;</span>, <span class="hljs-number">19</span>);  <span class="hljs-comment">// 8 + 19 + 5</span><br>    p = put_named_string(p, <span class="hljs-string">&quot;app_version&quot;</span>, <span class="hljs-number">11</span>, <span class="hljs-string">&quot;1.0.0&quot;</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 11 + 5 + 5</span><br>    <br>  <span class="hljs-comment">// 写入结束标识 0x000009</span><br>    p = put_be16(p, <span class="hljs-number">0</span>); <span class="hljs-comment">// 2</span><br>    p = put_byte(p, kAMFObjectEnd); <span class="hljs-comment">// 1</span><br>    <br>  <span class="hljs-comment">// 封装成 flv_tag</span><br>    flv_init_tag(_script_tag,<br>                 FLV_TAG_TYPE_SCRIPT,<br>                 kFlvScriptTagBodyLength,<br>                 XPGetTimeStampOffset(_timeBase),<br>                 <span class="hljs-number">0</span>,<br>                 data);<br>...<br></code></pre></div></td></tr></table></figure><h2 id="Audio-Tag-的生成">Audio Tag 的生成</h2><p>AAC 编码格式的 Audio Tag Body 包含三块内容：1 字节的 Flags、1 字节的 AACPacketType 以及负载数据，Flags 包括 4 bit 的编码格式、2 bit 的采样率、1 bit 的位深、1 bit 的通道数，所以在封装 flv_tag 之前这些参数是需要准备的：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLV_AUDIO_TAG_SOUND_FORMAT_AAC   10 &lt;&lt; 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLV_AUDIO_TAG_SOUND_SIZE_16      1 &lt;&lt; 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLV_AUDIO_TAG_SOUND_TYPE_MONO    0x00</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLV_AUDIO_TAG_SOUND_TYPE_STEREO  0x01</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLV_AUDIO_TAG_SOUND_RATE_11      1 &lt;&lt; 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLV_AUDIO_TAG_SOUND_RATE_22      2 &lt;&lt; 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLV_AUDIO_TAG_SOUND_RATE_44      3 &lt;&lt; 2</span><br><br>...<br>    <span class="hljs-comment">// 判断单双声道</span><br>    <span class="hljs-type">int</span> flvStereoOrMono = (<span class="hljs-number">2</span> == channelCount) ? FLV_AUDIO_TAG_SOUND_TYPE_STEREO : FLV_AUDIO_TAG_SOUND_TYPE_MONO;<br><br>    <span class="hljs-comment">// 创建 Flags，根据参数给对应的 bit 位写值</span><br>    <span class="hljs-type">int</span> flags = <span class="hljs-number">0</span>;<br>    flags = FLV_AUDIO_TAG_SOUND_FORMAT_AAC | FLV_AUDIO_TAG_SOUND_SIZE_16 | flvStereoOrMono;<br><br>    <span class="hljs-keyword">switch</span> (sampleRate) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">11025</span>:<br>        flags |= FLV_AUDIO_TAG_SOUND_RATE_11;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">22050</span>:<br>        flags |= FLV_AUDIO_TAG_SOUND_RATE_22;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">44100</span>:<br>        flags |= FLV_AUDIO_TAG_SOUND_RATE_44;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    int32_t size = (int32_t)(AACFrame.dataSize + <span class="hljs-number">2</span>);<br>    flv_tag_p flv_tag = flv_create_tag();<br>    uint8_t *data = malloc(size);<br><br>    <span class="hljs-comment">// 判断负载是 ASC 还是 AAC Packet</span><br>    <span class="hljs-type">BOOL</span> isAudioSpecificConfig = (AACFrame.dataSize == <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 写入</span><br>    uint8_t *p = data;<br>    p = put_byte(p, flags);<br>    p = put_byte(p, isAudioSpecificConfig ? <span class="hljs-literal">NO</span> : <span class="hljs-literal">YES</span>);<br>    p = put_buff(p, AACFrame.data, AACFrame.dataSize);<br><br>    <span class="hljs-comment">// 封装 flv_tag</span><br>    flv_init_tag(flv_tag,<br>                 FLV_TAG_TYPE_AUDIO,<br>                 size,<br>                 (uint32_t)metaData.pts,<br>                 <span class="hljs-number">0</span>,<br>                 data);<br>...<br></code></pre></div></td></tr></table></figure><h2 id="Video-Tag-的生成">Video Tag 的生成</h2><p>AVC 编码的 Video Tag 负载类型一般有两种，AVC sequence header 即 AVCDecoderConfigurationRecord，以及 NALU，在负载内容前需要标识 1 字节的 Flags（包含 4 bit 帧类型 FrameType 和 4 bit 编码类型CodecID），接着是 1 字节的 AVCPacketType 和 3 字节的 CompositionTime：</p><h3 id="AVCDecoderConfigurationRecord">AVCDecoderConfigurationRecord</h3><p>iOS 的 VideoToolBox 回调方法中拿到的 sps 和 pps 是独立的，需要将他们打包成 extradata 放到 Tag Body 里作为负载数据：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLV_VIDEO_TAG_CODEC_AVC               7</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLV_VIDEO_TAG_FRAME_TYPE_KEYFRAME     1 &lt;&lt; 4</span><br><br>...<br>    <span class="hljs-comment">// 创建 Flags，写入编码类型</span><br>    <span class="hljs-type">int</span> flags = <span class="hljs-number">0</span>;<br>    flags = FLV_VIDEO_TAG_CODEC_AVC | FLV_VIDEO_TAG_FRAME_TYPE_KEYFRAME;<br><br>    uint8_t *conf = <span class="hljs-literal">NULL</span>;<br>    int32_t outputDataSize = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 计算拼接好的 extradata长度</span><br>    size_t confSize = <span class="hljs-number">11</span> + __spsSize + __ppsSize;<br>    conf = (uint8_t *)malloc(confSize);<br>    uint8_t *p2 = conf;<br><br>    <span class="hljs-comment">// version</span><br>    p2 = put_byte(p2, <span class="hljs-number">1</span>); <br>    <span class="hljs-comment">// avc profile</span><br>    p2 = put_byte(p2, __sps[<span class="hljs-number">1</span>]); <br>    <span class="hljs-comment">// avc compatibility</span><br>    p2 = put_byte(p2, __sps[<span class="hljs-number">2</span>]); <span class="hljs-comment">// compat</span><br>    <span class="hljs-comment">// avc level</span><br>    p2 = put_byte(p2, __sps[<span class="hljs-number">3</span>]); <br>    <span class="hljs-comment">// 0xFC | (2bit 的 NALU 长度占用字节 - 1) ff：4  11111111</span><br>    p2 = put_byte(p2, <span class="hljs-number">0xff</span>);   <br>    <span class="hljs-comment">// 0xE0 | (5bit 的 sps 个数) e1：1  11111101</span><br>    p2 = put_byte(p2, <span class="hljs-number">0xe1</span>);   <br>    <span class="hljs-comment">// sps size</span><br>    p2 = put_be16(p2, __spsSize);<br>    <span class="hljs-comment">// sps data</span><br>    p2 = put_buff(p2, (<span class="hljs-keyword">const</span> uint8_t *)__sps, __spsSize);<br>    <span class="hljs-comment">// pps 个数</span><br>    p2 = put_byte(p2, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// pps size</span><br>    p2 = put_be16(p2, __ppsSize);<br>    <span class="hljs-comment">// pps data</span><br>    p2 = put_buff(p2, (<span class="hljs-keyword">const</span> uint8_t *)__pps, __ppsSize);<br><br>    <span class="hljs-comment">// Tag Body 整体大小</span><br>    outputDataSize = (int32_t)(confSize + <span class="hljs-number">5</span>);<br>    uint8_t *outputData = (uint8_t *)malloc(outputDataSize);<br><br>    uint8_t *p = outputData;<br>    <span class="hljs-comment">// 写入 Flags</span><br>    p = put_byte(p, flags);<br>    <span class="hljs-comment">// 写入 AVCPacketType，0 为 extradata</span><br>    p = put_byte(p, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 写入 CompositionTime</span><br>    p = put_be24(p, (<span class="hljs-type">int</span>)(metaData.pts - metaData.dts));<br>    <span class="hljs-comment">// 写入 extradata</span><br>    p = put_buff(p, conf, confSize);<br><br>    <span class="hljs-comment">// 封装 flv_tag</span><br>    flv_tag_p tag = flv_create_tag();<br>    flv_init_tag(tag,<br>                 FLV_TAG_TYPE_VIDEO,<br>                 outputDataSize,<br>                 (uint32_t)metaData.pts,<br>                 <span class="hljs-number">0</span>,<br>                 outputData);<br>...<br></code></pre></div></td></tr></table></figure><h3 id="NALU">NALU</h3><p>NALU 的封装相对简单一点：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLV_VIDEO_TAG_FRAME_TYPE_KEYFRAME     1 &lt;&lt; 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLV_VIDEO_TAG_FRAME_TYPE_INTERFRAME   2 &lt;&lt; 4</span><br><br>...<br>    <span class="hljs-comment">// 创建 Flags 写入编码类型和帧类型</span><br>    <span class="hljs-type">int</span> flags = <span class="hljs-number">0</span>;<br>    flags = FLV_VIDEO_TAG_CODEC_AVC;<br><br>    <span class="hljs-keyword">if</span> (XPNALUTypeIDR ==  naluFrame.type || XPNALUTypeSEI == naluFrame.type) &#123;<br>      flags |= FLV_VIDEO_TAG_FRAME_TYPE_KEYFRAME;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      flags |= FLV_VIDEO_TAG_FRAME_TYPE_INTERFRAME;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算 Tag Body 总长度</span><br>    int32_t outputDataSize = <span class="hljs-number">5</span> + (int32_t)naluFrame.dataSize;<br>    uint8_t *outputData = (uint8_t *)malloc(outputDataSize);<br><br>    uint8_t *p = outputData;<br>    <span class="hljs-comment">// 写入 Flags</span><br>    p = put_byte(p, flags);<br>    <span class="hljs-comment">// 写入 AVCPacketType，1 为 NALU</span><br>    p = put_byte(p, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 写入 CompositionTime</span><br>    p = put_be24(p, (<span class="hljs-type">int</span>)(metaData.pts - metaData.dts));<br>    <span class="hljs-comment">// 写入 NALU</span><br>    p = put_buff(p, (<span class="hljs-keyword">const</span> uint8_t *)naluFrame.data, naluFrame.dataSize);<br><br>    <span class="hljs-comment">// 封装 flv_tag</span><br>    flv_tag_p tag = flv_create_tag();<br>    flv_init_tag(tag,<br>                 FLV_TAG_TYPE_VIDEO,<br>                 outputDataSize,<br>                 (uint32_t)metaData.pts,<br>                 <span class="hljs-number">0</span>,<br>                 outputData);<br>...<br></code></pre></div></td></tr></table></figure><h2 id="FLV-Header-的写入">FLV Header 的写入</h2><p>FLV Header 一共是 9 个字节，包含 Signature、Version、Flags 和 Headersize，写入时需要注意 FLV 采用大端的字节序，而 iOS 平台是小端，写入大于一个字节数字类型时需要调整字节序，SetValue 函数提供了这样的功能：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">//    - FLV Header（9字节）：</span><br><span class="hljs-comment">//        1.Signature（3字节） 文件表示  总为&quot;FLV&quot;（0x46, 0x4c, 0x56）</span><br><span class="hljs-comment">//        2.Version（1字节） 版本号   目前为0x01</span><br><span class="hljs-comment">//        3.Flags（1字节） 前5位保留  必须为0   第6位标识是否存在音频Tag   第7位保留  必须为0  第8位标识是否存在视频Tag</span><br><span class="hljs-comment">//        4.Headersize（4字节） 从FLV Header开始到FLV Body开始的字节数  版本1中总是9</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> kFlvHeaderLength 9</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> kFlvTagHeaderFlags_Audio 0x04</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> kFlvTagHeaderFlags_Video 0x01</span><br><br>...<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span>* signature = <span class="hljs-string">&quot;FLV&quot;</span>;<br>    uint8_t version = <span class="hljs-number">1</span>;<br>    uint8_t flags = kFlvTagHeaderFlags_Audio | kFlvTagHeaderFlags_Video;<br>    uint32_t headerSize = kFlvHeaderLength;<br>    <br>    SetValue(header, &amp;index, (uint8_t *)signature, <span class="hljs-number">3</span>, <span class="hljs-literal">NO</span>);<br>    SetValue(header, &amp;index, (uint8_t *)&amp;version, <span class="hljs-number">1</span>, <span class="hljs-literal">YES</span>);<br>    SetValue(header, &amp;index, (uint8_t *)&amp;flags, <span class="hljs-number">1</span>, <span class="hljs-literal">YES</span>);<br>    SetValue(header, &amp;index, (uint8_t *)&amp;headerSize, <span class="hljs-number">4</span>, <span class="hljs-literal">YES</span>);<br>...<br></code></pre></div></td></tr></table></figure><p>FLV Header 获取到后，使用 NSFileManager 在本地创建文件，使用 NSFileHandler 负责后续 Tag 的写入：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-keyword">define</span> kFlvHeaderLength 9</span><br>...<br>    <span class="hljs-built_in">NSData</span> *flvFileHeaderData = [<span class="hljs-built_in">NSData</span> dataWithBytes:flvHeader length:kFlvHeaderLength];<br>    [[<span class="hljs-built_in">NSFileManager</span> defaultManager] createFileAtPath:filePath contents:flvFileHeaderData attributes:<span class="hljs-literal">nil</span>];<br>    _filledLength += kFlvHeaderLength;<br>    <br>    _handle = [<span class="hljs-built_in">NSFileHandle</span> fileHandleForWritingAtPath:filePath];<br>    [_handle seekToEndOfFile];<br>...<br></code></pre></div></td></tr></table></figure><h2 id="FLV-Tag-的写入">FLV Tag 的写入</h2><p>将 previousTagSize 和 Tag Header 放在一起写入：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">//    - Tag Header（11字节）：</span><br><span class="hljs-comment">//        1.Type（1字节） 表示Tag类型  包括音频(0x08)  视频(0x09)和script data(0x12)</span><br><span class="hljs-comment">//        2.Datasize（3字节） 表示该Tag Data部分的大小</span><br><span class="hljs-comment">//        3.Timestamp（3字节） 表示该Tag的时间戳</span><br><span class="hljs-comment">//        4.Timestamp_ex（1字节） 表示时间戳的扩展字节  当24位数值不够时  该字节作为最高位将时间戳扩展为32位数值</span><br><span class="hljs-comment">//        5.StreamID（3字节） 表示stream id  总是0</span><br>    <br><span class="hljs-comment">//    每个Tag前面是一个Previous Tag Size字段（4字节）  表示前面一个Tag的大小</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> kFlvPreviousTagSizeLength 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> kFlvTagHeaderLength 11</span><br><br>...    <br>    uint8_t header[kFlvPreviousTagSizeLength + kFlvTagHeaderLength];<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <br><span class="hljs-comment">// timestamp 中高位 1 字节</span><br>    uint8_t timestampUpper1Byte = flvTag-&gt;timestamp &gt;&gt; <span class="hljs-number">24</span>;<br><span class="hljs-comment">// timestamp 中低位 3 字节</span><br>    uint32_t timestampLower3Bytes = flvTag-&gt;timestamp &amp; <span class="hljs-number">0x00FFFFFF</span>;<br>    <br><span class="hljs-comment">// 写入 4 字节 previousTagSize</span><br>    SetValue(header, &amp;index, (uint8_t *)&amp;_previousTagSize, kFlvPreviousTagSizeLength, <span class="hljs-literal">YES</span>);<br><span class="hljs-comment">// 写入 1 字节 Tag 类型，0x08 音频，0x09 视频，0x12 Script</span><br>    SetValue(header, &amp;index, (uint8_t *)&amp;(flvTag-&gt;tag_type), <span class="hljs-number">1</span>, <span class="hljs-literal">YES</span>);<br><span class="hljs-comment">// 写入 Tag Body 长度</span><br>    SetValue(header, &amp;index, (uint8_t *)&amp;(flvTag-&gt;data_size), <span class="hljs-number">3</span>, <span class="hljs-literal">YES</span>);<br><span class="hljs-comment">// 写入低位 3 字节时间戳</span><br>    SetValue(header, &amp;index, (uint8_t *)&amp;timestampLower3Bytes, <span class="hljs-number">3</span>, <span class="hljs-literal">YES</span>);<br><span class="hljs-comment">// 写入高位 1 字节时间戳</span><br>    SetValue(header, &amp;index, (uint8_t *)&amp;timestampUpper1Byte, <span class="hljs-number">1</span>, <span class="hljs-literal">YES</span>);<br><span class="hljs-comment">// 写入 stream Id 固定是 0</span><br>    SetValue(header, &amp;index, (uint8_t *)&amp;(flvTag-&gt;stream_id), <span class="hljs-number">3</span>, <span class="hljs-literal">YES</span>);<br>    <br>    <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSData</span> dataWithBytes:header length:<span class="hljs-keyword">sizeof</span>(header)];<br>    [_handle writeData:data];<br>...<br></code></pre></div></td></tr></table></figure><p>Tag Header 写好后，把上面生成好的 Tag Body 直接写入即可：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">...<br><span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSData</span> dataWithBytes:flvTag-&gt;data length:flvTag-&gt;data_size];<br>    [_handle writeData:data];<br>...<br></code></pre></div></td></tr></table></figure><p>写入时一般第一个 Tag 会是 Script Tag，之后是音视频 Tag。文件写好后，下载好沙盒文件，用 ffplay 播放查看效果：</p><p><img src="/resources/image/meta.png" alt="metadata"></p><p>黄框部分是 Script Tag 中携带的 metadata 的一部分，ffmpeg 貌似只打印值是字符串的字段，红色部分则是从 ASC 和 sps/pps 中解析出的音视频编码参数，有两个 Stream 说明播放器已经解析出 FLV 包含音频和视频，剩下的就是观察画面和声音是否正常，音画是否同步。</p><h1>二进制文件分析</h1><p>写好后的 FLV 文件可以用 UltraEdit 打开查看二进制信息：</p><p><img src="/resources/image/byte-audio.png" alt="flv_byte_audio"></p><p>红框部分是 FLV Header，可以看到前三个字节 0x46、0x4C、0x56 是协议名 FLV，第四个字节 0x01 是 FLV 版本，第五个字节 0x05 即 00000101，表示 FLV 流中包含音频和视频的 Tag。</p><p>第一个篮框部分是 previousTagSize0，由于前面没有 Tag，所以这 4 字节固定为 0。</p><p>接着黄框部分是第一个 Tag 的 Header，首字节是 0x12，说明第一个 Tag 是 Script Tag，之后的 3 字节 0x00000DE 表示 Tag Body 的长度为 222，再往后的 4 个字节 0x00000000 表示 Tag 的时间戳，最后 3 字节表示 stream id 为 0。</p><p>黄框后的部分是 Tag Body，也就是 metaData 数据了，可以看到右侧已经解析出了部分 metadata。Tag Body 的起始位置是 0x00000018 加上 0x00000DE 的长度，Tag Body 的结束位置应该在 0x000000F5，可以看到 0x000000F3、0x000000F4、0x000000F5 这三个字节刚好是 AMF 定义的结束标识 0x000009 ，说明 metadata 写入是 OK 的。</p><p>接下来第二个蓝框表示第一个 Script Tag 的长度，11 字节的 Tag Header，222 字节的 Tag Body 加一起刚好是 0x000000E9。</p><p>第二个黄框是第二个 Tag 的 Header，0x08 说明是一个音频 Tag，然后跨过 Header 其他字段直接看 Tag Body，第一个字节 A2 即10100010，前 4 位表示编码类型是 AAC，第 5、6 位表示采样率 5.5-kHz（其实这里应该固定是 3，即 44.1-kHz，但因为解码并没有依赖这个字段，而是依赖 ASC，所以这里没有影响），第 7 位表示 16 位深，第 8 位表示单声道。再往后第二个字节是 AACPacketType，0x00 表示这个 Audio Tag 的负载是 ASC，所以之后的两个字节 0x1188 是 ASC。</p><p>接着第三个蓝框表示第二个 Audio Tag 的长度，11 字节的 Tag Header 加上 4 字节的 Tag Body 刚好是 0x0000000F。</p><p>第三个黄框首字节依然是 0x08，音频 Tag，可以看到 Tag Body 第二个字节的 AACPacketType 是 0x01，说明 Audio Tag 携带的是 AAC Packet。</p><p>再来看下视频的 Tag：</p><p><img src="/resources/image/byte-video.png" alt="flv_byte_video"></p><p>这个 FLV 文件的第一个 Tag 依然是 Script Tag，接着是视频 Tag。</p><p>第二个黄框的首字节 0x09 标识是一个视频 Tag，Tag Body 的首字节 0x17 即 00010111，前 4 位标识是一个关键帧（虽然这是个 extradata 的 Tag，但还是标记成关键帧），后 4 位标识编码类型 AVC，之后第二个字节 AVCPacketType 是 0x00 说明这个视频 Tag 负载的是 extradata，服务端获取后可以解析出 sps/pps。</p><p>第三个黄框的首字节 0x09 说明还是一个视频 Tag，不同的是这个 Tag 的 Body 第二字节 AVCPacketType 是 0x01，说明 Tag 负载的是 NALU，并且第一个字节 0x17 还说明负载中的 NALU 中包含关键帧。</p><h1>后记</h1><p>至此 FLV 封装就完成了，如果本地播放没有问题，就可以用 Tag Body 和 Tag Header 信息构造 librtmp 的 RTMPPacket 结构体，通过 RTMP 协议推送给服务端了。</p><h1>参考文档</h1><blockquote><p>Adobe 官方文档 <a href="https://rtmp.veriskope.com/pdf/video_file_format_spec_v10.pdf">https://rtmp.veriskope.com/pdf/video_file_format_spec_v10.pdf</a></p><p>之前按雷神文档写过的一个 FLV 解析工具 <a href="https://github.com/XiaopingSun/AVTools/blob/main/AVTools/Module/FLVMediainfo/FLVMediainfo.cpp">https://github.com/XiaopingSun/AVTools/blob/main/AVTools/Module/FLVMediainfo/FLVMediainfo.cpp</a></p><p>FLV 协议5分钟入门浅析 <a href="https://www.cnblogs.com/chyingp/p/flv-getting-started.html">https://www.cnblogs.com/chyingp/p/flv-getting-started.html</a></p><p>MPEG-4 Audio 维基百科 <a href="https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies">https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies</a></p><p>码流格式: Annex-B, AVCC(H.264)与HVCC(H.265), extradata详解 <a href="https://blog.csdn.net/yue_huang/article/details/75126155">https://blog.csdn.net/yue_huang/article/details/75126155</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flash Video</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 使用 VideoToolBox 编码 H.264</title>
    <link href="/2022/05/06/iOS-%E4%BD%BF%E7%94%A8-VideoToolBox-%E7%BC%96%E7%A0%81-H-264/"/>
    <url>/2022/05/06/iOS-%E4%BD%BF%E7%94%A8-VideoToolBox-%E7%BC%96%E7%A0%81-H-264/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>上一篇使用了 AudioToolBox 将音频数据编码成 AAC，这次的需求是将视频帧编码成 H264。在 iOS 8.0 之前，如果要在 iOS 平台上硬编码 H264 只能使用 AVAssetWriter 的野路子&quot;曲线救国&quot;，先利用系统硬编将视频帧写到本地 mp4 文件里，然后需要自己写逻辑去 mp4 的 Box 里读取 sps、pps 和 NALU 数据，会有频繁的文件读写操作。iOS 8.0 苹果提供了 VideoToolBox 来支持硬件的编解码，大大提升了开发效率，让开发者可以直接拿到编码后的数据，因此我们视频编码基于 VideoToolBox 来实现。</p><h1>实现思路</h1><p>使用 VideoToolBox 一般会用到 VTCompressionSessionRef 这个类，使用方式比较简单，首先调用 VTCompressionSessionCreate 创建编码器实例：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">VT_EXPORT OSStatus<br>VTCompressionSessionCreate(<br><span class="hljs-built_in">CM_NULLABLE</span> <span class="hljs-built_in">CFAllocatorRef</span>allocator, <span class="hljs-comment">// 内存分配器，传 NULL 即可</span><br>int32_twidth,  <span class="hljs-comment">// 编码分辨率宽</span><br>int32_theight, <span class="hljs-comment">// 编码分辨率高</span><br><span class="hljs-built_in">CMVideoCodecType</span>codecType,  <span class="hljs-comment">// 编码器类型 kCMVideoCodecType_H264</span><br><span class="hljs-built_in">CM_NULLABLE</span> <span class="hljs-built_in">CFDictionaryRef</span>encoderSpecification, <span class="hljs-comment">// NULL 使用默认编码器</span><br><span class="hljs-built_in">CM_NULLABLE</span> <span class="hljs-built_in">CFDictionaryRef</span>sourceImageBufferAttributes, <span class="hljs-comment">// pixelBuffer 属性</span><br><span class="hljs-built_in">CM_NULLABLE</span> <span class="hljs-built_in">CFAllocatorRef</span>compressedDataAllocator, <span class="hljs-comment">// 内存分配器，传 NULL 即可</span><br><span class="hljs-built_in">CM_NULLABLE</span> VTCompressionOutputCallbackoutputCallback, <span class="hljs-comment">// 编码完成的回调函数</span><br><span class="hljs-type">void</span> * <span class="hljs-built_in">CM_NULLABLE</span>outputCallbackRefCon,  <span class="hljs-comment">// 回调函数上下文指针</span><br><span class="hljs-built_in">CM_RETURNS_RETAINED_PARAMETER</span> <span class="hljs-built_in">CM_NULLABLE</span> VTCompressionSessionRef * <span class="hljs-built_in">CM_NONNULL</span> <span class="hljs-comment">// 实例</span><br>  compressionSessionOut) API_AVAILABLE(macosx(<span class="hljs-number">10.8</span>), ios(<span class="hljs-number">8.0</span>), tvos(<span class="hljs-number">10.2</span>));<br></code></pre></div></td></tr></table></figure><p>实例创建好后，可以给编码器配置输出参数，一般常用的属性有帧率、码率、GOP大小、profileLevel，注意 propertyValue 是 CoreFoundation 类型，需要手动管理指针的释放：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">VT_EXPORT OSStatus<br>VTSessionSetProperty(<br>  <span class="hljs-built_in">CM_NONNULL</span> VTSessionRef       session,  <span class="hljs-comment">// 实例</span><br>  <span class="hljs-built_in">CM_NONNULL</span> <span class="hljs-built_in">CFStringRef</span>        propertyKey,  <span class="hljs-comment">// key</span><br>  <span class="hljs-built_in">CM_NULLABLE</span> <span class="hljs-built_in">CFTypeRef</span>         propertyValue  <span class="hljs-comment">// value</span><br>) API_AVAILABLE(macosx(<span class="hljs-number">10.8</span>), ios(<span class="hljs-number">8.0</span>), tvos(<span class="hljs-number">10.2</span>));<br></code></pre></div></td></tr></table></figure><p>配置好属性，调用方法让编码器分配足够内存准备编码（可选）：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">VT_EXPORT OSStatus<br>VTCompressionSessionPrepareToEncodeFrames( <span class="hljs-built_in">CM_NONNULL</span> VTCompressionSessionRef session ) API_AVAILABLE(macosx(<span class="hljs-number">10.9</span>), ios(<span class="hljs-number">8.0</span>), tvos(<span class="hljs-number">10.2</span>));<br></code></pre></div></td></tr></table></figure><p>准备工作完成，就可以将采集到的视频数据送入编码器了：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">VT_EXPORT OSStatus<br>VTCompressionSessionEncodeFrame(<br><span class="hljs-built_in">CM_NONNULL</span> VTCompressionSessionRefsession,  <span class="hljs-comment">// 实例</span><br><span class="hljs-built_in">CM_NONNULL</span> CVImageBufferRefimageBuffer,<span class="hljs-comment">// 采集的视频帧</span><br><span class="hljs-built_in">CMTime</span>presentationTimeStamp,<span class="hljs-comment">// pts</span><br><span class="hljs-built_in">CMTime</span>duration, <span class="hljs-comment">// may be kCMTimeInvalid </span><br><span class="hljs-built_in">CM_NULLABLE</span> <span class="hljs-built_in">CFDictionaryRef</span>frameProperties, <span class="hljs-comment">// 视频帧属性  没有变化传 NULL 即可</span><br><span class="hljs-type">void</span> * <span class="hljs-built_in">CM_NULLABLE</span>sourceFrameRefcon,  <span class="hljs-comment">// 这一帧的上下文  会在 callback 里回调</span><br>VTEncodeInfoFlags * <span class="hljs-built_in">CM_NULLABLE</span>infoFlagsOut  <span class="hljs-comment">// 用来获取编码器状态  传 NULL 即可</span><br>) API_AVAILABLE(macosx(<span class="hljs-number">10.8</span>), ios(<span class="hljs-number">8.0</span>), tvos(<span class="hljs-number">10.2</span>));<br></code></pre></div></td></tr></table></figure><p>编码器在编码一帧后会回调在 VTCompressionSessionCreate 传入的 outputCallback 函数，将编码后的数据和上下文指针回调出来：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> (*VTCompressionOutputCallback)(<br><span class="hljs-type">void</span> * <span class="hljs-built_in">CM_NULLABLE</span> outputCallbackRefCon,  <span class="hljs-comment">// 创建编码器时指定的上下文指针</span><br><span class="hljs-type">void</span> * <span class="hljs-built_in">CM_NULLABLE</span> sourceFrameRefCon,   <span class="hljs-comment">// 编码每一帧时指定的上下文指针</span><br>OSStatus status, <span class="hljs-comment">// 该帧编码状态</span><br>VTEncodeInfoFlags infoFlags,   <span class="hljs-comment">// 编码器状态信息</span><br><span class="hljs-built_in">CM_NULLABLE</span> <span class="hljs-built_in">CMSampleBufferRef</span> sampleBuffer );  <span class="hljs-comment">// 编码后的数据</span><br></code></pre></div></td></tr></table></figure><p>拿到 sampleBuffer 就可以解析出视频帧编码后的数据和一些其他信息了。</p><h1>代码实现</h1><p>首先创建编码器实例，配置属性：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)setupCompressionSession &#123;<br>    [_lock lock];<br>  <span class="hljs-comment">// 用户定义的编码参数信息</span><br>    XPVideoEncodeConfig *configuration = _videoEncodeConfig;<br>    OSStatus err = noErr;<br>    <br>    VTCompressionSessionRef session = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">NSDictionary</span> *pixelBufferOptions = @&#123; (<span class="hljs-built_in">NSString</span>*) kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA),<br>                                          (<span class="hljs-built_in">NSString</span>*) kCVPixelBufferWidthKey : @([configuration videoSize].width),<br>                                          (<span class="hljs-built_in">NSString</span>*) kCVPixelBufferHeightKey : @([configuration videoSize].height),<br>                                          (<span class="hljs-built_in">NSString</span>*) kCVPixelBufferOpenGLESCompatibilityKey : @YES&#125;;<br>    <br>  <span class="hljs-comment">// 创建编码器实例，将当前编码器的类对象传入上下文参数</span><br>    err = VTCompressionSessionCreate(kCFAllocatorDefault,<br>                                     [configuration videoSize].width,<br>                                     [configuration videoSize].height,<br>                                     kCMVideoCodecType_H264,<br>                                     <span class="hljs-literal">NULL</span>,<br>                                     (__bridge <span class="hljs-built_in">CFDictionaryRef</span>)pixelBufferOptions,<br>                                     kCFAllocatorDefault,<br>                                     &amp;vtCallback,<br>                                     (__bridge <span class="hljs-type">void</span> *)<span class="hljs-keyword">self</span>, &amp;session);<br>        <br>    <span class="hljs-keyword">if</span> (err != noErr) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: failed to setup VTCompressionSession. %d&quot;</span>, err);<br>    &#125;<br>    <br>    _compressionSession = session;<br>    <br>    <span class="hljs-comment">// 设置 GOP 长度、帧率</span><br>    <span class="hljs-keyword">if</span> (err == noErr) &#123;<br>        <span class="hljs-keyword">const</span> int32_t interval = (int32_t)[configuration videoMaxKeyFrameInterval];<br>        <span class="hljs-keyword">const</span> int32_t frameRate = (int32_t)[configuration expectedSourceVideoFrameRate];<br>        int32_t duration = (int32_t)(interval / frameRate);<br>        <br>      <span class="hljs-comment">// gop 长度：多少帧出现一个关键帧</span><br>        err = SetVTSessionIntProperty(session, kVTCompressionPropertyKey_MaxKeyFrameInterval, interval);<br>        <span class="hljs-keyword">if</span>(err != noErr) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: failed to setup VTCompressionSession. %d&quot;</span>, err);<br>        &#125;<br>      <span class="hljs-comment">// 关键帧间隔时间 = gop 长度 / 帧率</span><br>        err = SetVTSessionIntProperty(session, kVTCompressionPropertyKey_MaxKeyFrameIntervalDuration, duration);<br>        <span class="hljs-keyword">if</span>(err != noErr) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: failed to setup VTCompressionSession. %d&quot;</span>, err);<br>        &#125;<br>      <span class="hljs-comment">// 期望帧率</span><br>        err = SetVTSessionIntProperty(session, kVTCompressionPropertyKey_ExpectedFrameRate, frameRate);<br>        <span class="hljs-keyword">if</span>(err != noErr) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: failed to setup VTCompressionSession. %d&quot;</span>, err);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 禁止 B 帧</span><br>    <span class="hljs-keyword">if</span>(err == noErr) &#123;<br>        err = SetVTSessionBoolProperty(session, kVTCompressionPropertyKey_AllowFrameReordering, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span>(err != noErr) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: failed to setup VTCompressionSession. %d&quot;</span>, err);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置码率（后面会详细写）</span><br>    <span class="hljs-keyword">if</span>(err == noErr) &#123;<br>        err = [<span class="hljs-keyword">self</span> setExpectedBitrate:[configuration averageVideoBitrate]];<br>        <span class="hljs-keyword">if</span>(err != noErr) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: failed to setup VTCompressionSession. %d&quot;</span>, err);<br>        &#125;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 设置编码模式为 RealTime  保证直播场景的低延迟</span><br>    <span class="hljs-keyword">if</span>(err == noErr) &#123;<br>        err = SetVTSessionBoolProperty(session, kVTCompressionPropertyKey_RealTime, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">if</span>(err != noErr) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: failed to setup VTCompressionSession. %d&quot;</span>, err);<br>        &#125;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 设置 profile Level</span><br>    <span class="hljs-keyword">if</span>(err == noErr) &#123;<br>        err = SetVTSessionStringProperty(session, kVTCompressionPropertyKey_ProfileLevel, (__bridge <span class="hljs-built_in">CFTypeRef</span>)[configuration videoProfileLevel]);<br>        <span class="hljs-keyword">if</span>(err != noErr) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot; error:failed to setup VTCompressionSession. %d&quot;</span>, err);<br>        &#125;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 准备开始编码</span><br>    <span class="hljs-keyword">if</span> (err == noErr) &#123;<br>        err = VTCompressionSessionPrepareToEncodeFrames(session);<br>        <span class="hljs-keyword">if</span> (err != noErr) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: failed to setup VTCompressionSession. %d&quot;</span>, err);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(err != noErr) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: failed to setup VTCompressionSession. %d&quot;</span>, err);<br>        <br>        [_lock unlock];<br>        <span class="hljs-keyword">@throw</span> [<span class="hljs-built_in">NSException</span> exceptionWithName:kXPH264VTEncoderErrorInit<br>                                       reason:<span class="hljs-string">@&quot;failed to setup VTCompressionSession&quot;</span><br>                                     userInfo:<span class="hljs-literal">nil</span>];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    [_lock unlock];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化方法里用到的 SetVTSession***Property 是封装的自定义函数，避免代码里频繁出现 CF 框架对象的创建和释放：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">// Convenience function for setting a VT int32 property.</span><br><span class="hljs-keyword">static</span> OSStatus SetVTSessionIntProperty(VTSessionRef session,<br>                                        <span class="hljs-built_in">CFStringRef</span> key,<br>                                        int32_t value) &#123;<br>    <span class="hljs-built_in">CFNumberRef</span> cfNum =<br>    <span class="hljs-built_in">CFNumberCreate</span>(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;value);<br>    OSStatus status = VTSessionSetProperty(session, key, cfNum);<br>    <span class="hljs-built_in">CFRelease</span>(cfNum);<br>    <span class="hljs-keyword">if</span> (status != noErr) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;VTSessionSetProperty failed to set key: %@ with value: %d&quot;</span>,<br>               (__bridge <span class="hljs-built_in">NSString</span>*)key,<br>               value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-comment">// Convenience function for setting a VT bool property.</span><br><span class="hljs-keyword">static</span> OSStatus SetVTSessionBoolProperty(VTSessionRef session,<br>                                         <span class="hljs-built_in">CFStringRef</span> key,<br>                                         <span class="hljs-type">bool</span> value) &#123;<br>    <span class="hljs-built_in">CFBooleanRef</span> cf_bool = (value) ? kCFBooleanTrue : kCFBooleanFalse;<br>    OSStatus status = VTSessionSetProperty(session, key, cf_bool);<br>    <span class="hljs-keyword">if</span> (status != noErr) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;VTSessionSetProperty failed to set key: %@ with value: %@&quot;</span>,<br>               (__bridge <span class="hljs-built_in">NSString</span>*)key,<br>               value ? <span class="hljs-string">@&quot;YES&quot;</span>:<span class="hljs-string">@&quot;NO&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-comment">// Convenience function for setting a VT string property.</span><br><span class="hljs-keyword">static</span> OSStatus SetVTSessionStringProperty(VTSessionRef session,<br>                          <span class="hljs-built_in">CFStringRef</span> key,<br>                          <span class="hljs-built_in">CFStringRef</span> value) &#123;<br>    OSStatus status = VTSessionSetProperty(session, key, value);<br>    <span class="hljs-keyword">if</span> (status != noErr) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;VTSessionSetProperty failed to set key: %@ with value: %@&quot;</span>,<br>               (__bridge <span class="hljs-built_in">NSString</span>*)key,<br>               (__bridge <span class="hljs-built_in">NSString</span>*)value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>码率的设置会相对复杂一些，kVTCompressionPropertyKey_AverageBitRate 用来设置平均码率，实际的码率会围绕平均码率浮动，所以还需要设置一个浮动的范围：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (OSStatus)setExpectedBitrate:(<span class="hljs-built_in">NSUInteger</span>)averageBitrate &#123;<br>    <span class="hljs-keyword">if</span> (!_compressionSession) &#123;<br>        <span class="hljs-keyword">return</span> kNilOptions;<br>    &#125;<br>    <span class="hljs-type">int</span> bitrate = (<span class="hljs-type">int</span>)averageBitrate;<br><br>  <span class="hljs-comment">// 设置平均码率</span><br>    OSStatus status;<br>    status = SetVTSessionIntProperty(_compressionSession,<br>                                     kVTCompressionPropertyKey_AverageBitRate,<br>                                     (int32_t)bitrate);<br>    <span class="hljs-keyword">if</span> (status != noErr) &#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 设置码率浮动范围  kLimitToAverageBitRateFactor 是 1.5</span><br>    int64_t dataLimitBytesPerSecond = (int64_t)(bitrate * kLimitToAverageBitRateFactor / <span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">CFNumberRef</span> bytesPerSecondRef = <span class="hljs-built_in">CFNumberCreate</span>(kCFAllocatorDefault,<br>                                                   kCFNumberSInt64Type,<br>                                                   &amp;dataLimitBytesPerSecond);<br>    int64_t aSecond = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">CFNumberRef</span> aSecondRef = <span class="hljs-built_in">CFNumberCreate</span>(kCFAllocatorDefault,<br>                                            kCFNumberSInt64Type,<br>                                            &amp;aSecond);<br>    <span class="hljs-keyword">const</span> <span class="hljs-type">void</span>* nums[<span class="hljs-number">2</span>] = &#123; bytesPerSecondRef, aSecondRef &#125;;<br>    <span class="hljs-built_in">CFArrayRef</span> dataRateLimitsRef = <span class="hljs-built_in">CFArrayCreate</span>(<span class="hljs-literal">NULL</span>, nums, <span class="hljs-number">2</span>, &amp;kCFTypeArrayCallBacks);<br>    status = VTSessionSetProperty(_compressionSession,<br>                                  kVTCompressionPropertyKey_DataRateLimits,<br>                                  dataRateLimitsRef);<br>    <br>    <span class="hljs-keyword">if</span> (bytesPerSecondRef) &#123;<br>        <span class="hljs-built_in">CFRelease</span>(bytesPerSecondRef);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (aSecondRef) &#123;<br>        <span class="hljs-built_in">CFRelease</span>(aSecondRef);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dataRateLimitsRef) &#123;<br>        <span class="hljs-built_in">CFRelease</span>(dataRateLimitsRef);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>准备工作完成后，当采集到视频数据时就可以将其送进编码器了：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)pushBuffer:(CVPixelBufferRef)pixelBuffer metaData:(XPMetaData *)metaData &#123;<br>    <span class="hljs-keyword">if</span> (_compressionSession == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (pixelBuffer == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: pixel buffer is NULL&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    size_t width = CVPixelBufferGetWidth(pixelBuffer);<br>    size_t height = CVPixelBufferGetHeight(pixelBuffer);<br>    <br>    <span class="hljs-keyword">if</span> (width == <span class="hljs-number">0</span> || height == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 用户定义的编码参数</span><br>    XPVideoEncodeConfig *configuration = _videoEncodeConfig;<br>  <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    这里还需要对 pixelBuffer 的宽高做校验，保证与编码宽高的比例是一致的</span><br><span class="hljs-comment">    */</span><br>    <br>  <span class="hljs-comment">// 创建时间戳，timescale 需要指定为 1000，metaData.pts 是采集视频帧时打的时间戳，单位 ms</span><br>    <span class="hljs-built_in">CMTime</span> presentationTime = &#123;<span class="hljs-number">0</span>&#125;;<br>    presentationTime.timescale = <span class="hljs-number">1000</span>;   <span class="hljs-comment">// has to be 1000 !</span><br>    presentationTime.value = metaData.pts;<br>    presentationTime.flags = kCMTimeFlags_Valid;<br>    <br>  <span class="hljs-comment">// pixelBuffer 送入编码器</span><br>    [_lock lock];<br>    VTEncodeInfoFlags flags;<br>    VTCompressionSessionEncodeFrame(_compressionSession, pixelBuffer, presentationTime, kCMTimeInvalid, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;flags);<br>    [_lock unlock];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>VideoToolBox 编码完成后会回调先前定义的回调函数：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> vtCallback(<br>                       <span class="hljs-type">void</span> * <span class="hljs-built_in">CM_NULLABLE</span> outputCallbackRefCon,<br>                       <span class="hljs-type">void</span> * <span class="hljs-built_in">CM_NULLABLE</span> sourceFrameRefCon,<br>                       OSStatus status,<br>                       VTEncodeInfoFlags infoFlags,<br>                       <span class="hljs-built_in">CM_NULLABLE</span> <span class="hljs-built_in">CMSampleBufferRef</span> sampleBuffer ) &#123;<br>    <br>  <span class="hljs-comment">// 获取当前编码器类的实例对象</span><br>    XPVTH264Encoder *encoder = (__bridge XPVTH264Encoder *)outputCallbackRefCon;<br>    <span class="hljs-keyword">if</span> (!encoder) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// CMBlockBufferRef 封装了编码后的数据块</span><br>    <span class="hljs-built_in">CMBlockBufferRef</span> block = <span class="hljs-built_in">CMSampleBufferGetDataBuffer</span>(sampleBuffer);<br>  <span class="hljs-comment">// attachments 包含一些编码的额外信息  比如当前是否是关键帧</span><br>    <span class="hljs-built_in">CFArrayRef</span> attachments = <span class="hljs-built_in">CMSampleBufferGetSampleAttachmentsArray</span>(sampleBuffer, <span class="hljs-literal">false</span>);<br>  <span class="hljs-comment">// 获取当前编码数据块的时间戳</span><br>    <span class="hljs-built_in">CMTime</span> pts = <span class="hljs-built_in">CMSampleBufferGetPresentationTimeStamp</span>(sampleBuffer);<br>    <br>  <span class="hljs-comment">// 判断是否为关键帧</span><br>    <span class="hljs-type">bool</span> isKeyframe = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (attachments !=  <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">CFDictionaryRef</span> attachment;<br>        <span class="hljs-built_in">CFBooleanRef</span> dependsOnOthers;<br>        attachment = (<span class="hljs-built_in">CFDictionaryRef</span>)<span class="hljs-built_in">CFArrayGetValueAtIndex</span>(attachments, <span class="hljs-number">0</span>);<br>        dependsOnOthers = (<span class="hljs-built_in">CFBooleanRef</span>)<span class="hljs-built_in">CFDictionaryGetValue</span>(attachment, kCMSampleAttachmentKey_DependsOnOthers);<br>        isKeyframe = (dependsOnOthers == kCFBooleanFalse);<br>    &#125;<br>    <br>  <span class="hljs-comment">// 如果是第一个关键帧，需要获取 sps、pps 打包成 flv 的首个 video tag</span><br>    <span class="hljs-keyword">if</span> (isKeyframe &amp;&amp; !encoder.isConfigSent) &#123;<br>        size_t spsSize = <span class="hljs-number">0</span>, ppsSize = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> uint8_t* sps = <span class="hljs-literal">NULL</span>, *pps = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// Send the SPS and PPS.</span><br>        <span class="hljs-built_in">CMFormatDescriptionRef</span> format = <span class="hljs-built_in">CMSampleBufferGetFormatDescription</span>(sampleBuffer);<br>        size_t paramCount;<br>        <br>      <span class="hljs-comment">// 获取 sps 及其长度</span><br>        <span class="hljs-built_in">CMVideoFormatDescriptionGetH264ParameterSetAtIndex</span>(format, <span class="hljs-number">0</span>, &amp;sps, &amp;spsSize, &amp;paramCount, <span class="hljs-literal">NULL</span>);<br>      <span class="hljs-comment">// 获取 pps 及其长度</span><br>        <span class="hljs-built_in">CMVideoFormatDescriptionGetH264ParameterSetAtIndex</span>(format, <span class="hljs-number">1</span>, &amp;pps, &amp;ppsSize, &amp;paramCount, <span class="hljs-literal">NULL</span>);<br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这里将 sps 和 pps 回调给上层封装处理</span><br><span class="hljs-comment">        */</span><br>        <br>        encoder.configSent = <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">char</span>* bufferData;<br>    size_t size;<br>    uint8_t *naluData;<br>    <br>  <span class="hljs-comment">// 从 CMBlockBufferRef 中获取编码后的数据块的指针地址和数据长度</span><br>    status = <span class="hljs-built_in">CMBlockBufferGetDataPointer</span>(block, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, &amp;size, &amp;bufferData);<br>    <br>    <span class="hljs-keyword">if</span> (status == noErr) &#123;<br>        naluData = (uint8_t *)malloc(size);<br>        memcpy(naluData, (uint8_t *)bufferData, size);<br>        <br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这里将编码数据回调给上层封装处理</span><br><span class="hljs-comment">        */</span><br>        <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: video toolbox encoder error: %d&quot;</span>, status);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在收到第一个编码后的关键帧时，先从 SampleBuffer 里解析出 sps 和 pps，将其封装成 AVCC 的 extradata ，打包成 flv tag，并作为第一个 video tag 发送给服务端。通过 CMBlockBufferGetDataPointer 方法拿到的编码数据块中可能包含多个 NALU，苹果有时会将 SEI 和 IDR 帧放到同一个 CMBlockBuffer 中，如果需要把每个 NALU 单独解析出来，可以判断前 4 个字节的 NALU 长度，将 NALU 一个一个解析出来。</p><p>iOS 平台的 h264 硬编码使用的都是 AVCC，而非 Annex B，在实际使用编码数据的过程中，需要根据不同的场景对 NALU 做转换。RTMP 协议使用 flv 的封装格式，而恰好 flv 也是用 AVCC，所以封装的时候就很方便了。</p><p>使用结束之后，别忘了释放编码器实例：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)teardownCompressionSession &#123;<br>    [_lock lock];<br>    <span class="hljs-keyword">if</span> (_compressionSession) &#123;<br>        VTCompressionSessionInvalidate(_compressionSession);<br>        <span class="hljs-built_in">CFRelease</span>(_compressionSession); <br>        _compressionSession = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    [_lock unlock];<br>&#125;<br></code></pre></div></td></tr></table></figure><h1>后记</h1><p>下一步，flv 封装！</p>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编码</tag>
      
      <tag>VideoToolBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 使用 AudioToolBox 编码 MPEG4-AAC</title>
    <link href="/2022/05/04/iOS-%E4%BD%BF%E7%94%A8-AudioToolBox-%E7%BC%96%E7%A0%81-MPEG4-AAC/"/>
    <url>/2022/05/04/iOS-%E4%BD%BF%E7%94%A8-AudioToolBox-%E7%BC%96%E7%A0%81-MPEG4-AAC/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>上一篇使用 Audio Unit 实现了麦克风数据的采集，下一步需要将音频数据送到编码器编码，一般 RTMP 协议使用的音频编码格式是 AAC，而恰好苹果的 Core Audio 下有提供给我们音频格式转换的工具 - AudioConvertRef。</p><h1>实现思路</h1><p>AudioConvertRef 接口比较简单，AudioConverterNewSpecific 函数指定编码器类型和输入输出的 ASBD 创建实例：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">//-----------------------------------------------------------------------------</span><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment">    @function   AudioConverterNewSpecific</span><br><span class="hljs-comment">    @abstract   Create a new AudioConverter using specific codecs.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    @param      inSourceFormat</span><br><span class="hljs-comment">                    The format of the source audio to be converted.</span><br><span class="hljs-comment">    @param      inDestinationFormat</span><br><span class="hljs-comment">                    The destination format to which the audio is to be converted.</span><br><span class="hljs-comment">    @param      inNumberClassDescriptions</span><br><span class="hljs-comment">                    The number of class descriptions.</span><br><span class="hljs-comment">    @param      inClassDescriptions</span><br><span class="hljs-comment">                    AudioClassDescriptions specifiying the codec to instantiate.</span><br><span class="hljs-comment">    @param      outAudioConverter</span><br><span class="hljs-comment">                    On successful return, points to a new AudioConverter instance.</span><br><span class="hljs-comment">    @result     An OSStatus result code.</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">This function is identical to AudioConverterNew(), except that the client may</span><br><span class="hljs-comment">explicitly choose which codec to instantiate if there is more than one choice.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">extern</span> OSStatus<br>AudioConverterNewSpecific(  <span class="hljs-keyword">const</span> AudioStreamBasicDescription * inSourceFormat,<br>                            <span class="hljs-keyword">const</span> AudioStreamBasicDescription * inDestinationFormat,<br>                            <span class="hljs-built_in">UInt32</span>                              inNumberClassDescriptions,<br>                            <span class="hljs-keyword">const</span> AudioClassDescription *       inClassDescriptions,<br>                            AudioConverterRef __<span class="hljs-keyword">nullable</span> * __<span class="hljs-keyword">nonnull</span> outAudioConverter)<br>                                                                                API_AVAILABLE(macos(<span class="hljs-number">10.4</span>), ios(<span class="hljs-number">2.0</span>), watchos(<span class="hljs-number">2.0</span>), tvos(<span class="hljs-number">9.0</span>));<br></code></pre></div></td></tr></table></figure><p>AudioConverterFillComplexBuffer 函数传入目标 AudioBufferList 和回调函数 inInputDataProc，之后 AudioConvertRef 会同步调用该回调函数 inInputDataProc 问我们要 PCM 原始数据，在检查数据没有问题之后编码器将开始编码：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">//-----------------------------------------------------------------------------</span><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment">    @function   AudioConverterFillComplexBuffer</span><br><span class="hljs-comment">    @abstract   Converts data supplied by an input callback function, supporting non-interleaved</span><br><span class="hljs-comment">                and packetized formats.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    @param      inAudioConverter</span><br><span class="hljs-comment">                    The AudioConverter to use.</span><br><span class="hljs-comment">    @param      inInputDataProc</span><br><span class="hljs-comment">                    A callback function which supplies the input data.</span><br><span class="hljs-comment">    @param      inInputDataProcUserData</span><br><span class="hljs-comment">                    A value for the use of the callback function.</span><br><span class="hljs-comment">    @param      ioOutputDataPacketSize</span><br><span class="hljs-comment">                    On entry, the capacity of outOutputData expressed in packets in the</span><br><span class="hljs-comment">                    converter&#x27;s output format. On exit, the number of packets of converted</span><br><span class="hljs-comment">                    data that were written to outOutputData.</span><br><span class="hljs-comment">    @param      outOutputData</span><br><span class="hljs-comment">                    The converted output data is written to this buffer. On entry, the buffers&#x27;</span><br><span class="hljs-comment">                    mDataByteSize fields (which must all be the same) reflect buffer capacity.</span><br><span class="hljs-comment">                    On exit, mDataByteSize is set to the number of bytes written.</span><br><span class="hljs-comment">    @param      outPacketDescription</span><br><span class="hljs-comment">                    If non-null, and the converter&#x27;s output uses packet descriptions, then</span><br><span class="hljs-comment">                    packet descriptions are written to this array. It must point to a memory</span><br><span class="hljs-comment">                    block capable of holding *ioOutputDataPacketSize packet descriptions.</span><br><span class="hljs-comment">                    (See AudioFormat.h for ways to determine whether an audio format</span><br><span class="hljs-comment">                    uses packet descriptions).</span><br><span class="hljs-comment">    @result     An OSStatus result code.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Produces a buffer list of output data from an AudioConverter. The supplied input</span><br><span class="hljs-comment">callback function is called whenever necessary.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">extern</span> OSStatus<br>AudioConverterFillComplexBuffer(    AudioConverterRef                   inAudioConverter,<br>                                    AudioConverterComplexInputDataProc  inInputDataProc,<br>                                    <span class="hljs-type">void</span> * __<span class="hljs-keyword">nullable</span>                   inInputDataProcUserData,<br>                                    <span class="hljs-built_in">UInt32</span> *                            ioOutputDataPacketSize,<br>                                    AudioBufferList *                   outOutputData,<br>                                    AudioStreamPacketDescription * __<span class="hljs-keyword">nullable</span> outPacketDescription)<br>                                                                                API_AVAILABLE(macos(<span class="hljs-number">10.2</span>), ios(<span class="hljs-number">2.0</span>), watchos(<span class="hljs-number">2.0</span>), tvos(<span class="hljs-number">9.0</span>));<br></code></pre></div></td></tr></table></figure><p>使用完调用 AudioConverterDispose 释放资源：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">//-----------------------------------------------------------------------------</span><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment">    @function   AudioConverterDispose</span><br><span class="hljs-comment">    @abstract   Destroy an AudioConverter.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    @param      inAudioConverter</span><br><span class="hljs-comment">                    The AudioConverter to dispose.</span><br><span class="hljs-comment">    @result     An OSStatus result code.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">extern</span> OSStatus<br>AudioConverterDispose(  AudioConverterRef   inAudioConverter)                   API_AVAILABLE(macos(<span class="hljs-number">10.1</span>), ios(<span class="hljs-number">2.0</span>), watchos(<span class="hljs-number">2.0</span>), tvos(<span class="hljs-number">9.0</span>));<br></code></pre></div></td></tr></table></figure><p>有两个问题需要额外注意下：</p><p>一是送入编码器的数据量。AudioConverterFillComplexBuffer 的 ioOutputDataPacketSize 参数需要指定编码器此次编码的 aac packet 数量，通常 AAC-LC 一个 packet 包含 1024 个 pcm frame，所以每次送入编码器的 pcm frame 个数需要是 1024 * 通道数 的整数倍。但使用 Audio Unit 采集音频每次回调的 frame 个数是不确定的，可能会比 1024 小，所以音频数据在送到编码器之前需要先加入一个 Buffer Data 队列里，满足数量要求再从队列取出送进编码器。</p><p>另一个是时间戳的计算，在后续封装 Flv 时需要在 Tag Header 里指定这一帧起始位置的时间戳，为了保证音画同步，需要计算原始数据产生时的时间戳，我们在 Audio Unit 回调时打了一个时间戳，但这个时间戳至少是在此 Buffer 最后一个采样点产生时生成的，需要校准成第一个采样点产生时的时间，这个偏移量很好计算，用采样点个数除以采样率。由于 Buffer Data 需要先加入队列后取出，所以 Meta Data 也需要同样的操作，取出时需要再计算一个偏移量，保证给编码器的 Buffer 首个采样点的时间是对的。</p><div class="note note-warning">            <p>实际测试过程中发现，在送入第一个 1024 frame 的 Buffer Data 给编码器后，输出的 Packet Size 只有 4 个字节，这显然是不足以压缩 1024 个 frame 的，由于目前还不太清楚编码器底层的实现，盲猜一下可能是编码器内部也有缓存，如果是这样的话，那上边计算时间戳的方式也是有偏差的，但实际影响不大，测试效果是 OK 的。</p>          </div><h1>代码实现</h1><p>输出的 ASBD 指定 mFormatID 为 kAudioFormatMPEG4AAC，mChannelsPerFrame 为通道数，其他参数设置为 0 即可：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">_destASBD = calloc(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(AudioStreamBasicDescription));<br>_destASBD-&gt;mFormatID = kAudioFormatMPEG4AAC;<br>_destASBD-&gt;mFormatFlags = <span class="hljs-number">0</span>;<br>_destASBD-&gt;mBytesPerFrame = <span class="hljs-number">0</span>;<br>_destASBD-&gt;mBytesPerPacket = <span class="hljs-number">0</span>;<br>_destASBD-&gt;mChannelsPerFrame = <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure><p>AudioConverterRef 初始化：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">...<br>  <span class="hljs-comment">// 定义软解、硬解编码器</span><br>    AudioClassDescription codecs[<span class="hljs-number">2</span>] = &#123;<br>        &#123;<br>            kAudioEncoderComponentType,<br>            kAudioFormatMPEG4AAC,<br>            kAppleSoftwareAudioCodecManufacturer<br>        &#125;,<br>        &#123;<br>            kAudioEncoderComponentType,<br>            kAudioFormatMPEG4AAC,<br>            kAppleHardwareAudioCodecManufacturer<br>        &#125;<br>    &#125;;<br>    <br>  <span class="hljs-comment">// 初始化 AudioConverterRef  输入源的 ASBD 可以从采集类拿到</span><br>    <span class="hljs-keyword">if</span> (XPAudioUnitCheckError(AudioConverterNewSpecific(<span class="hljs-keyword">self</span>.sourceASBD, <span class="hljs-keyword">self</span>.destASBD, <span class="hljs-number">2</span>, codecs, &amp;_context.audioConverter), <span class="hljs-string">&quot;AudioConverterNewSpecific error&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 设置输出码率  一般 AAC 可设置的码率为 64Kbps、96Kbps、128Kbps</span><br>    <span class="hljs-built_in">UInt32</span> encodeBitrate = <span class="hljs-number">128000</span>;<br>    <span class="hljs-keyword">if</span> (XPAudioUnitCheckError(AudioConverterSetProperty(_context.audioConverter, kAudioConverterEncodeBitRate, <span class="hljs-keyword">sizeof</span>(encodeBitrate), &amp;encodeBitrate), <span class="hljs-string">&quot;set encode bitrate error&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 获取编码输出的最大 packet size，用于初始化接收编码数据的 AudioBuffer</span><br>    <span class="hljs-built_in">UInt32</span> maxOutputPacketSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">UInt32</span> propertySize = <span class="hljs-keyword">sizeof</span>(maxOutputPacketSize);<br>    <span class="hljs-keyword">if</span> (XPAudioUnitCheckError(AudioConverterGetProperty(_context.audioConverter, kAudioConverterPropertyMaximumOutputPacketSize, &amp;propertySize, &amp;maxOutputPacketSize), <span class="hljs-string">&quot;get max output packet size error&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 这里初始化 PCM Buffer Data 和 Meta Data 的队列</span><br>    _PCMDataQueue = [[XPPCMDataQueue alloc] initWithPCMFramesPerAACPacket:kPCMFramesPerAACPacket bytesPerPCMFrame:<span class="hljs-keyword">self</span>.sourceASBD-&gt;mBytesPerFrame sampleRate:<span class="hljs-keyword">self</span>.sourceASBD-&gt;mSampleRate];<br>  <br>  <span class="hljs-comment">// 将一些参数设置给 context</span><br>    _context.maxOutputPacketSize = maxOutputPacketSize;<br>    _context.channelCount = <span class="hljs-keyword">self</span>.sourceASBD-&gt;mChannelsPerFrame;<br>    _context.bytesPerFrame = <span class="hljs-keyword">self</span>.sourceASBD-&gt;mBytesPerFrame;<br>...<br></code></pre></div></td></tr></table></figure><p>最后几行用到的 context 是一个结构体，用来在调用 AudioConverterFillComplexBuffer 方法时给回调函数传入一个 user data，便于在回调函数里使用这些参数：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    AudioConverterRef audioConverter;<br>    <span class="hljs-built_in">UInt32</span> maxOutputPacketSize;<br>    <span class="hljs-built_in">UInt32</span> channelCount;<br>    <span class="hljs-built_in">UInt32</span> bytesPerFrame;<br>    <span class="hljs-built_in">NSMutableArray</span>&lt;<span class="hljs-built_in">NSData</span> *&gt; *PCMBufferDataList;<br>    <span class="hljs-built_in">NSData</span> *currentBufferData;<br>&#125; AudioConverterContext;<br></code></pre></div></td></tr></table></figure><p>接收到音频数据和时间戳后，将它们 push 进队列里，满足一定数量帧个数时从队列里取出并计算起始帧的时间戳，最后送入编码器。等待编码器编码完成，将 AAC Frame 回调给上层做封装处理：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">...<br>  <span class="hljs-comment">// 计算 audioBuffer 包含的 frame 个数</span><br>    <span class="hljs-built_in">UInt32</span> frameCount = audioBuffer-&gt;mDataByteSize / <span class="hljs-keyword">self</span>.sourceASBD-&gt;mBytesPerFrame;<br>    <br>    <span class="hljs-comment">// 将 pts 对齐到 buffer 的首个采样点  音频 dts 和 pts 保持一致即可</span><br>    <span class="hljs-keyword">if</span> (metaData.pts &gt; <span class="hljs-number">1000</span> * frameCount / <span class="hljs-keyword">self</span>.sourceASBD-&gt;mSampleRate) &#123;<br>        metaData.pts -= <span class="hljs-number">1000</span> * frameCount / <span class="hljs-keyword">self</span>.sourceASBD-&gt;mSampleRate;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        metaData.pts = <span class="hljs-number">0</span>;<br>    &#125;<br>    metaData.dts = metaData.pts;<br>    <br>    <span class="hljs-comment">// bufferData 和 metaData 加入到队列（audioBuffer 由上层释放 这里 freeWhenDone 为 NO）</span><br>    <span class="hljs-built_in">NSData</span> *bufferData = [<span class="hljs-built_in">NSData</span> dataWithBytesNoCopy:audioBuffer-&gt;mData length:audioBuffer-&gt;mDataByteSize freeWhenDone:<span class="hljs-literal">NO</span>];<br>  <br>  <span class="hljs-comment">// bufferData 和 metaData 送入队列</span><br>    [_PCMDataQueue enqueueBufferData:bufferData];<br>    [_PCMDataQueue enqueueMetaData:metaData frameCount:frameCount];<br>    <br>    <span class="hljs-comment">// 尝试从队列中取出 bufferData</span><br>    <span class="hljs-built_in">NSData</span> *dequeueBufferData = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        dequeueBufferData = [_PCMDataQueue dequeueBufferData];<br>        <span class="hljs-keyword">if</span> (!dequeueBufferData) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        [_context.PCMBufferDataList addObject:dequeueBufferData];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 计算此次送入编码器的 Buffer 总长度</span><br>    size_t totalBufferBytes = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSData</span> *data <span class="hljs-keyword">in</span> _context.PCMBufferDataList) &#123;<br>        totalBufferBytes += data.length;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 计算编码前的 frame 个数、编码后的 facket 个数</span><br>    size_t totalFrameCount = totalBufferBytes / <span class="hljs-keyword">self</span>.sourceASBD-&gt;mBytesPerFrame;<br>    size_t totalPacketCount = totalFrameCount / kPCMFramesPerAACPacket;<br>    <br>    <span class="hljs-comment">// 如果不足一个 packet 直接返回</span><br>    <span class="hljs-keyword">if</span> (!totalPacketCount) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 循环编码每个 AAC Packet</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; totalPacketCount; i++) &#123;<br>        <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>            uint8_t *outputBuffer = (uint8_t *)calloc(<span class="hljs-number">1</span>, _context.maxOutputPacketSize);<br>            <span class="hljs-built_in">UInt32</span> numberOfPackets = <span class="hljs-number">1</span>;<br>            <br>          <span class="hljs-comment">// 初始化用于接收 AAC Packet 的 AudioBufferList，每次问编码器要 1 个 Packet</span><br>            AudioBufferList l;<br>            l.mNumberBuffers = <span class="hljs-number">1</span>;<br>            l.mBuffers[<span class="hljs-number">0</span>].mNumberChannels = _context.channelCount;<br>            l.mBuffers[<span class="hljs-number">0</span>].mDataByteSize = _context.maxOutputPacketSize;<br>            l.mBuffers[<span class="hljs-number">0</span>].mData = outputBuffer;<br>            <br>          <span class="hljs-comment">// 开始编码，设置回调函数 ioProcess，设置 user data 为之前定义的 context</span><br>            <span class="hljs-keyword">if</span> (XPAudioUnitCheckError(AudioConverterFillComplexBuffer(_context.audioConverter,<br>                                                                      ioProcess,<br>                                                                      &amp;_context,<br>                                                                      &amp;numberOfPackets,<br>                                                                      &amp;l,<br>                                                                      <span class="hljs-literal">NULL</span>),<br>                                      <span class="hljs-string">&quot;AudioConverterFillComplexBuffer error&quot;</span>)) &#123;<br>                <br>                free(outputBuffer);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <br>          <span class="hljs-comment">// 到这一步已经可以获取编码结果了，AudioConverterRef 会将实际编码的 Packet 数量写回 numberOfPackets</span><br>            <span class="hljs-keyword">if</span> (numberOfPackets) &#123;<br>              <span class="hljs-comment">// 走到这里说明已经成功拿到编码数据</span><br>              <span class="hljs-comment">// 计算时间戳偏移，从队列中取出</span><br>                XPMetaData *dequeuedMetaData = [_PCMDataQueue dequeueMetaData];<br>                <span class="hljs-built_in">NSAssert</span>(dequeuedMetaData, <span class="hljs-string">@&quot;Something wrong with meta data queue&quot;</span>);<br>                <br>                <span class="hljs-comment">// send aac raw</span><br>                XPAACFrame *aacFrame = [XPAACFrame frameWithType:XPAACFrameType_Raw data:outputBuffer dataSize:l.mBuffers[<span class="hljs-number">0</span>].mDataByteSize];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.delegate &amp;&amp; [<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(aacEncoder:didGetAACFrame:metaData:channelCount:sampleRate:)]) &#123;<br>                    [<span class="hljs-keyword">self</span>.delegate aacEncoder:<span class="hljs-keyword">self</span> didGetAACFrame:aacFrame metaData:dequeuedMetaData channelCount:<span class="hljs-keyword">self</span>.audioEncodeConfig.encodeChannelCount sampleRate:(<span class="hljs-built_in">UInt32</span>)<span class="hljs-keyword">self</span>.audioEncodeConfig.encodeSampleRate];<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// 此次没有编码数据输出  释放资源  等待下一次</span><br>                free(outputBuffer);<br>            &#125;<br>        &#125;<br>    &#125;<br>...<br></code></pre></div></td></tr></table></figure><p>调用 AudioConverterFillComplexBuffer 方法后，如果传入的参数都没问题，AudioConverterRef 会去调用回调函数 ioProcess：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> OSStatus ioProcess(AudioConverterRef inAudioConverter,<br>                          <span class="hljs-built_in">UInt32</span> *ioNumberDataPackets,<br>                          AudioBufferList *ioData,<br>                          AudioStreamPacketDescription * __<span class="hljs-keyword">nullable</span> * __<span class="hljs-keyword">nullable</span> outDataPacketDescription,<br>                          <span class="hljs-type">void</span> * __<span class="hljs-keyword">nullable</span> inUserData) &#123;<br>    <br>  <span class="hljs-comment">// user data 转成 AudioConverterContext</span><br>    AudioConverterContext *context = (AudioConverterContext *)inUserData;<br>    <span class="hljs-keyword">if</span> (!context || !context-&gt;PCMBufferDataList.count) &#123;<br>        *ioNumberDataPackets = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> kConverterShouldContinueCode;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 从 PCMBufferDataList 取出第一个 Buffer Data</span><br>    context-&gt;currentBufferData = context-&gt;PCMBufferDataList[<span class="hljs-number">0</span>];<br>    [context-&gt;PCMBufferDataList removeObjectAtIndex:<span class="hljs-number">0</span>];<br>    <br>  <span class="hljs-comment">// 计算 Buffer Data 中包含的 frame 个数</span><br>    <span class="hljs-built_in">UInt32</span> sampleCount = (<span class="hljs-built_in">UInt32</span>)context-&gt;currentBufferData.length / context-&gt;bytesPerFrame;<br>    <br>  <span class="hljs-comment">// *ioNumberDataPackets 是 AudioConverterRef 告知我们此次编码需要的 frame 个数</span><br>    <span class="hljs-keyword">if</span> (*ioNumberDataPackets &lt; sampleCount) &#123;<br>      <span class="hljs-comment">// 如果需要的个数比 Buffer Data 中的个数少，需要将剩余部分重新插入到 PCMBufferDataList</span><br>        <span class="hljs-built_in">NSData</span> *dataToUse = [<span class="hljs-built_in">NSData</span> dataWithBytes:context-&gt;currentBufferData.bytes length:*ioNumberDataPackets * context-&gt;bytesPerFrame];<br>        <span class="hljs-built_in">NSData</span> *dataRemain = [<span class="hljs-built_in">NSData</span> dataWithBytes:context-&gt;currentBufferData.bytes + *ioNumberDataPackets * context-&gt;bytesPerFrame length:(sampleCount - *ioNumberDataPackets) * context-&gt;bytesPerFrame];<br>        <br>        context-&gt;currentBufferData = dataToUse;<br>        [context-&gt;PCMBufferDataList insertObject:dataRemain atIndex:<span class="hljs-number">0</span>];<br>      <br>      <span class="hljs-comment">// 实际送入的 frame 个数以 *ioNumberDataPackets 为准</span><br>        sampleCount = *ioNumberDataPackets;<br>    &#125;<br>    <br>  <span class="hljs-comment">// *ioNumberDataPackets 需要赋值实际送入的 frame 个数</span><br>    *ioNumberDataPackets = sampleCount;<br>  <br>  <span class="hljs-comment">// 给 ioData 赋值</span><br>    ioData-&gt;mBuffers[<span class="hljs-number">0</span>].mData = context-&gt;currentBufferData.bytes;<br>    ioData-&gt;mBuffers[<span class="hljs-number">0</span>].mDataByteSize = (<span class="hljs-built_in">UInt32</span>)context-&gt;currentBufferData.length;<br>    ioData-&gt;mBuffers[<span class="hljs-number">0</span>].mNumberChannels = context-&gt;channelCount;<br>    <br>    <span class="hljs-keyword">return</span> noErr;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在 ioProcess 回调函数的两个参数 ioNumberDataPackets 和 ioData 都是 io 开头，说明这两个参数不光作为输入，也要作为输出，也就是需要在回调函数里给它们赋值，如果传参没有问题就可以直接运行程序进行编码了。</p><div class="note note-info">            <p>编码出的 AAC 裸数据不能直接拿来播放，一般有两种用途：</p><p>1.在裸数据前加一个 ADTS 或者 ADIF 写入本地，用于本地播放。</p><p>2.作为流媒体数据分发。如 Flv 格式，需要额外写入一个 Audio Specific Config 来描述 AAC 的信息。</p>          </div><h1>后记</h1><p>整体代码量是比较少的，实际调试过程中，内存的问题比较常见，比如一些 c 和 object-c 内存管理方式转换导致的 double free 问题，调试起来是比较麻烦的，不过调试的过程对理解苹果的设计模式和音视频数据的特性是很有帮助的。编码完成后，下一步就是封装了，不过在此之前还需要把 VideoToolbox 视频编码的部分写完，大概还得两周的时间吧。算一算自己在家已经宅了 1 个多月了，日子过的真滴舒服也真滴可怕，希望上海早日解封吧！</p>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Core Audio</tag>
      
      <tag>编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 使用 AudioUnit 采集麦克风音频数据</title>
    <link href="/2022/04/29/iOS-%E4%BD%BF%E7%94%A8-AudioUnit-%E9%87%87%E9%9B%86%E9%BA%A6%E5%85%8B%E9%A3%8E%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/04/29/iOS-%E4%BD%BF%E7%94%A8-AudioUnit-%E9%87%87%E9%9B%86%E9%BA%A6%E5%85%8B%E9%A3%8E%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>提到 iOS 的音频，首先想到的是苹果提供的 Core Audio。Core Audio 其实是一个抽象的概念，它包含平台下所有音频相关的类库，包括 AVFoundation、Audio Queue Services、Audio Unit、OpenAL 等等。我们这次需要实现一个音频采集类，采集麦克风的原始数据给到推流 SDK 的 codec 做编码，可实现的方式有很多种，可以用 AVFoundation 获取音频设备后直接采集音频 Buffer，也可以用稍底层的 Audio Queue Services 来采集，这两种方式很方便，但有局限性，比如混音、回声消除、效果器这类功能没办法实现，所以我们使用的是苹果提供的最底层的 Audio Unit。</p><h1>实现思路</h1><p>Audio Unit 是一个极其强大的音频引擎模块，它将功能模块按类型划分抽象成不同的 Unit，比如输入输出的 Unit 与硬件直接交互、延迟混响类效果器 Unit 可以串联在输入 Unit 后给采集的声音添加各种效果，混音 Unit 可以将多路音频合成一路最终串联输出 Unit 送给音频设备播放，还有一些 MIDI、采样相关的 Unit 一般在编曲相关的 App 中比较常见，苹果官方的编曲软件 GarageBand 和 Logic 都是基于此来完成。与 OC 平台相比，iOS 平台上可用的 Unit 数量是比较有限的，不如 OS 平台丰富，但对于移动设备来说已经很够用了，并且随着 iOS 版本的更新 Unit 数量也在不断增加。</p><p>目前只需要实现采集音频的功能，所以 Unit 的类型我们选择 kAudioUnitType_Output，虽然从字面上来看这个类型像是用于输出的，但这里理解为”外设“更好一点，因为它可以包含输入和输出。kAudioUnitType_Output 类型下包含很多子类型，我们要用到的是 kAudioUnitSubType_RemoteIO：</p><p><img src="/resources/image/remoteio.png" alt="output unit"></p><p>上图是 RemoteIO Unit 的数据流向图，它包含两个 Bus（Bus 是编曲软件 Logic 的叫法，代码里一般记作 element），可以理解成是两个数据通道，Bus1 与输入设备硬件交互，Bus0 与输出设备硬件交互。还有一个 Scope 的概念，数据流从外界进入到 Bus 中的端口叫做 Input Scope，数据从 Bus 中流出的端口叫做 Output Scope，所以 RemoteIO Unit 的工作流程可以总结为：输入设备硬件采集到的数据通过 Bus1 的 Input Scope 流入 Bus1，经过 Bus1 的 DSP 处理后，从 Bus1 的 Output Scope 流入 Bus0 的 Input Scope，经过 Bus0 的 DSP 处理后发送给输出硬件设备。</p><p>我们不需要 Bus0 发送数据给输出设备来播放我们采集到的声音，所以可以用代码设置将 Bus0 关闭，同时我们希望经过 Bus1 的 DSP 处理后可以得到我们想要的数据格式，因此要给 Bus1 的 Output Scope 设置 Audio Stream Basic Description，并监听 Output Scope 的 Input 事件，在事件回调中渲染音频数据，拿到我们想要的 Buffer。</p><h1>代码实现</h1><p>首先需要设置 AVAudioSession，将 Category 配置为支持音频采集：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">BOOL</span>)setupAudioSession &#123;<br>    <span class="hljs-built_in">NSError</span> *error;<br><br>    <span class="hljs-built_in">AVAudioSession</span> *audioSession = [<span class="hljs-built_in">AVAudioSession</span> sharedInstance];<br>    [audioSession setPreferredSampleRate:<span class="hljs-number">48000</span> error:&amp;error];<br>    <span class="hljs-keyword">if</span> (error) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;set preferred sample rate failed, error: %@&quot;</span>, error.localizedDescription);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">AVAudioSessionCategoryOptions</span> option = <span class="hljs-built_in">AVAudioSessionCategoryOptionDefaultToSpeaker</span> | <span class="hljs-built_in">AVAudioSessionCategoryOptionAllowBluetooth</span> | <span class="hljs-built_in">AVAudioSessionCategoryOptionMixWithOthers</span>;<br>    <br>    <span class="hljs-type">BOOL</span> success;<br>    success = [audioSession setCategory:<span class="hljs-built_in">AVAudioSessionCategoryPlayAndRecord</span> withOptions:option error:&amp;error];<br>    <span class="hljs-keyword">if</span> (!success || error) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;set category failed error: %@&quot;</span>, error.localizedDescription);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>    success = [audioSession setActive:<span class="hljs-literal">YES</span> error:&amp;error];<br>    <span class="hljs-keyword">if</span> (!success || error) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;set active failed error: %@&quot;</span>, error.localizedDescription);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接着初始化 Audio Stream Basic Description 用来描述采集数据的参数配置：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)setupASBD &#123;<br>    memset(&amp;_asbd, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(AudioStreamBasicDescription));<br>  <span class="hljs-comment">// 采集的数据格式</span><br>    _asbd.mFormatID = kAudioFormatLinearPCM;<br>  <span class="hljs-comment">// 配置数据属性</span><br>    _asbd.mFormatFlags = kAudioFormatFlagIsSignedInteger | kAudioFormatFlagIsPacked | kAudioFormatFlagsNativeEndian;<br>  <span class="hljs-comment">// 通道数</span><br>    _asbd.mChannelsPerFrame = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// pcm 格式一个 packet 对应一个 frame</span><br>    _asbd.mFramesPerPacket = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 位深</span><br>    _asbd.mBitsPerChannel = <span class="hljs-number">16</span>;<br>  <span class="hljs-comment">// 每帧数据的字节数</span><br>    _asbd.mBytesPerFrame = _asbd.mChannelsPerFrame * _asbd.mBitsPerChannel / <span class="hljs-number">8</span>;<br>  <span class="hljs-comment">// 每个包数据的字节数</span><br>    _asbd.mBytesPerPacket = _asbd.mFramesPerPacket * _asbd.mBytesPerFrame;<br>  <span class="hljs-comment">// 采样率</span><br>    _asbd.mSampleRate = <span class="hljs-number">48000</span>;<br>  <span class="hljs-comment">// 保留位</span><br>    _asbd.mReserved = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>mBytesPerFrame 和 mBytesPerPacket 最好使用已有的字段计算得出。</p><p>综上我们希望采集采样率 48000Hz，16bit 位深，单声道的 pcm数据，下面看下 Audio Unit 的使用：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">BOOL</span>)setupAudioUnit &#123;<br>  <br>  <span class="hljs-comment">// 初始化音频组件描述  用于查找指定类型的 Audio Unit  </span><br>    AudioComponentDescription acd;<br>  <span class="hljs-comment">// 指定类型为 kAudioUnitType_Output</span><br>    acd.componentType = kAudioUnitType_Output;<br>  <span class="hljs-comment">// 设置子类型，这里做了一个判断，如果 App 层开启了回声消除开关，就使用 kAudioUnitSubType_VoiceProcessingIO 作为 subtype，否则使用 kAudioUnitSubType_RemoteIO。</span><br>    <span class="hljs-comment">// kAudioUnitSubType_VoiceProcessingIO 相比 kAudioUnitSubType_RemoteIO 增加了回声消除的 DSP 算法，在外放状态下开启返听时建议使用。</span><br>    acd.componentSubType = <span class="hljs-keyword">self</span>.audioCaptureConfig.acousticEchoCancellationEnable ? kAudioUnitSubType_VoiceProcessingIO : kAudioUnitSubType_RemoteIO;<br>    acd.componentManufacturer = kAudioUnitManufacturer_Apple;<br>    acd.componentFlags = <span class="hljs-number">0</span>;<br>    acd.componentFlagsMask = <span class="hljs-number">0</span>;<br>    <br>  <span class="hljs-comment">// XPAudioUnitCheckError 这个方法用来校验 Audio Unit 函数的返回值</span><br>  <span class="hljs-comment">// 创建 AUGraph</span><br>    <span class="hljs-keyword">if</span> (XPAudioUnitCheckError(NewAUGraph(&amp;_graph), <span class="hljs-string">&quot;create AUGraph error.&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 使用之前创建的 AudioComponentDescription 创建 AUNode（实际是在 Audio Unit 上封装了一层，用于 AUGraph 上 Node 与 Node 的连接）</span><br>    AUNode ioNode;<br>    <span class="hljs-keyword">if</span> (XPAudioUnitCheckError(AUGraphAddNode(_graph, &amp;acd, &amp;ioNode), <span class="hljs-string">&quot;AUGraph add node error.&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 打开 AUGraph</span><br>    <span class="hljs-keyword">if</span> (XPAudioUnitCheckError(AUGraphOpen(_graph), <span class="hljs-string">&quot;AUGraph open error&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 从 AUNode 上获取 RemoteIO 的 Audio Unit 用于之后的属性设置</span><br>    <span class="hljs-keyword">if</span> (XPAudioUnitCheckError(AUGraphNodeInfo(_graph, ioNode, <span class="hljs-literal">NULL</span>, &amp;_audioUnit), <span class="hljs-string">&quot;get audio unit error.&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 之前介绍过，RemoteIO 上输出是 Bus0，输入是 Bus1</span><br>    AudioUnitElement outputBus = <span class="hljs-number">0</span>;<br>    AudioUnitElement inputBus = <span class="hljs-number">1</span>;<br>    <br>  <span class="hljs-comment">// 我们需要使用输入的 Bus1，先将 Bus1 的 Input Scope 打开</span><br>    <span class="hljs-built_in">UInt32</span> enableInput = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (XPAudioUnitCheckError(AudioUnitSetProperty(_audioUnit,<br>                                               kAudioOutputUnitProperty_EnableIO,<br>                                               kAudioUnitScope_Input,<br>                                               inputBus,<br>                                               &amp;enableInput,<br>                                               <span class="hljs-keyword">sizeof</span>(enableInput)),<br>                              <span class="hljs-string">&quot;enable input bus error.&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 不需要输出的 Bus0，将 Bus0 的 Output Scope 关闭</span><br>    <span class="hljs-built_in">UInt32</span> disableOutput = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (XPAudioUnitCheckError(AudioUnitSetProperty(_audioUnit,<br>                                               kAudioOutputUnitProperty_EnableIO,<br>                                               kAudioUnitScope_Output,<br>                                               outputBus,<br>                                               &amp;disableOutput,<br>                                               <span class="hljs-keyword">sizeof</span>(disableOutput)),<br>                              <span class="hljs-string">&quot;disable output bus error.&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 给输入 Bus1 的 Output Scope 配置 ASBD，指定采集音频的配置</span><br>    <span class="hljs-keyword">if</span> (XPAudioUnitCheckError(AudioUnitSetProperty(_audioUnit,<br>                                               kAudioUnitProperty_StreamFormat,<br>                                               kAudioUnitScope_Output,<br>                                               inputBus,<br>                                               &amp;_asbd,<br>                                               <span class="hljs-keyword">sizeof</span>(AudioStreamBasicDescription)),<br>                              <span class="hljs-string">&quot;set ASBD to output scope of input bus failed.&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 给输入 Bus1 的 Output Scope 配置 Input Callback</span><br>    AURenderCallbackStruct inputCallback;<br>    inputCallback.inputProc = &amp;AUInputCallback;  <span class="hljs-comment">// 回调函数</span><br>    inputCallback.inputProcRefCon = (__bridge <span class="hljs-type">void</span> * _Nullable)<span class="hljs-keyword">self</span>; <span class="hljs-comment">// user data</span><br>    <span class="hljs-keyword">if</span> (XPAudioUnitCheckError(AudioUnitSetProperty(_audioUnit,<br>                                               kAudioOutputUnitProperty_SetInputCallback,<br>                                               kAudioUnitScope_Output,<br>                                               inputBus,<br>                                               &amp;inputCallback,<br>                                               <span class="hljs-keyword">sizeof</span>(inputCallback)),<br>                              <span class="hljs-string">&quot;set input callback failed.&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 初始化 AUGraph</span><br>    <span class="hljs-keyword">if</span> (XPAudioUnitCheckError(AUGraphInitialize(_graph), <span class="hljs-string">&quot;AUGraph init failed.&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>AURenderCallbackStruct 是用来描述 Audio Unit 回调函数的结构体，inputProc 指定回调函数指针，函数会在每次 Bus1 有数据可以读取时回调，在函数中需要提供我们自己的 AudioBuffer 指针给 Bus1 做渲染，而不是直接使用函数回调的 AudioBufferList，因为它每次都是空的。inputProcRefCon 指定一个 user data，会在回调时带上这个参数，我们来看下回调函数的实现：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">OSStatus AUInputCallback(<span class="hljs-type">void</span> *inRefCon,<br>                         AudioUnitRenderActionFlags *ioActionFlags,<br>                         <span class="hljs-keyword">const</span> AudioTimeStamp *inTimeStamp,<br>                         <span class="hljs-built_in">UInt32</span> inBusNumber,<br>                         <span class="hljs-built_in">UInt32</span> inNumberFrames,<br>                         AudioBufferList * __<span class="hljs-keyword">nullable</span> ioData) &#123;<br>    <br>  <span class="hljs-comment">// user data 指针转换成我们传入的 ”self“ 对应的对象</span><br>    XPMicrophoneSource *THIS = (__bridge XPMicrophoneSource *)inRefCon;<br>    <br>  <span class="hljs-comment">// 创建一个 Buffer 容器，指定通道数，计算此次可以渲染的 Buffer 大小，inNumberFrames 指本次可渲染的音频帧数</span><br>    AudioBuffer buffer;<br>    buffer.mNumberChannels = THIS.asbd.mChannelsPerFrame;<br>    buffer.mDataByteSize = inNumberFrames * THIS.asbd.mBytesPerFrame;<br>    buffer.mData = malloc(buffer.mDataByteSize);<br>    <br>  <span class="hljs-comment">// 组装成 AudioBufferList，数据是交错的，所以 mNumberBuffers 固定是 1</span><br>    AudioBufferList bufferList;<br>    bufferList.mNumberBuffers = <span class="hljs-number">1</span>;<br>    bufferList.mBuffers[<span class="hljs-number">0</span>] = buffer;<br>    <br>    <span class="hljs-keyword">if</span> (THIS.isMuted) &#123;<br>        <span class="hljs-comment">// 这块儿做了个判断，如果 App 层调用了静音，则不做渲染，将所有数据清 0 表示静音。</span><br>        memset(buffer.mData, <span class="hljs-number">0</span>, buffer.mDataByteSize);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 主动调用 AudioUnitRender 让 Bus1 将数据渲染到我们创建的 Audio Buffer 上</span><br>        OSStatus status = XPAudioUnitCheckError(AudioUnitRender(THIS.audioUnit,<br>                                                                ioActionFlags,<br>                                                                inTimeStamp,<br>                                                                inBusNumber,<br>                                                                inNumberFrames,<br>                                                                &amp;bufferList),<br>                                                <span class="hljs-string">&quot;audio unit render failed.&quot;</span>);<br>        <span class="hljs-keyword">if</span> (status || buffer.mDataByteSize &lt;= <span class="hljs-number">0</span>) &#123;<br>            free(buffer.mData);<br>            <span class="hljs-keyword">return</span> status;<br>        &#125;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 回调上层</span><br>    <span class="hljs-keyword">if</span> (THIS.delegate &amp;&amp; [THIS.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(microphoneSource:didGetAudioBuffer:asbd:)]) &#123;<br>        [THIS.delegate microphoneSource:THIS didGetAudioBuffer:&amp;buffer asbd:&amp;THIS-&gt;_asbd];<br>    &#125;<br>    free(buffer.mData);<br>    <span class="hljs-keyword">return</span> noErr;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>准备工作完成了，现在可以调用 AUGraph 的接口开始和停止采集：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)startRunning &#123;<br>    XPAudioUnitCheckError(AUGraphStart(<span class="hljs-keyword">self</span>-&gt;_graph), <span class="hljs-string">&quot;AUGraph start error.&quot;</span>);<br>    <span class="hljs-keyword">self</span>.isRunning = <span class="hljs-literal">YES</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)stopRunning &#123;<br>    XPAudioUnitCheckError(AUGraphStop(<span class="hljs-keyword">self</span>-&gt;_graph), <span class="hljs-string">&quot;AUGraph stop error.&quot;</span>);<br>    <span class="hljs-keyword">self</span>.isRunning = <span class="hljs-literal">NO</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>释放是 AUGraph 创建的逆过程：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)dealloc &#123;<br>    AUGraphStop(_graph);<br>    AUGraphUninitialize(_graph);<br>    AUGraphClose(_graph);<br>    DisposeAUGraph(_graph);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Tips：打印 Audio Unit 错误信息的工具函数，先将 OSStatus 转成大端，如果是字符就打印字符，如果是数字就打印数字，会拼接在我们自定义的错误信息之后：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> OSStatus XPAudioUnitCheckError(OSStatus error, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *operation) &#123;<br>    <span class="hljs-keyword">if</span> (error == noErr) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];<br>    <span class="hljs-comment">// see if it appears to be a 4-char-code</span><br>    *(<span class="hljs-built_in">UInt32</span> *)(str + <span class="hljs-number">1</span>) = <span class="hljs-built_in">CFSwapInt32HostToBig</span>(error);<br>    <span class="hljs-keyword">if</span> (isprint(str[<span class="hljs-number">1</span>]) &amp;&amp; isprint(str[<span class="hljs-number">2</span>]) &amp;&amp; isprint(str[<span class="hljs-number">3</span>]) &amp;&amp; isprint(str[<span class="hljs-number">4</span>])) &#123;<br>        str[<span class="hljs-number">0</span>] = str[<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;\&#x27;&#x27;</span>;<br>        str[<span class="hljs-number">6</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// no, format it as an integer</span><br>        sprintf(str, <span class="hljs-string">&quot;%d&quot;</span>, (<span class="hljs-type">int</span>)error);<br>    &#125;<br>    fprintf(stderr, <span class="hljs-string">&quot;Error: %s (%s)\n&quot;</span>, operation, str);<br>    <span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1>后记</h1><p>Audio Unit 的设计模式对于音频开发者来说是很有吸引力的，而且性能要比 Windows 和 Linux 平台要好很多，同样高灵活性组件化的代码，在配合使用上会有各种难排查的问题，开发起来会有一定难度。音频采集只是最基本的 Audio Unit 使用，后续会再添加一些其他功能，比如返听、混音和效果器串联。</p><p>关于 Core Audio 有几个网站、书籍和源码库值得推荐：</p><blockquote><p>苹果官方文档 <a href="https://developer.apple.com/library/archive/documentation/MusicAudio/Conceptual/CoreAudioOverview/WhatisCoreAudio/WhatisCoreAudio.html#//apple_ref/doc/uid/TP40003577-CH3-SW1">https://developer.apple.com/library/archive/documentation/MusicAudio/Conceptual/CoreAudioOverview/WhatisCoreAudio/WhatisCoreAudio.html#//apple_ref/doc/uid/TP40003577-CH3-SW1</a></p><p>OSStatus 错误码查询 <a href="https://www.osstatus.com/">https://www.osstatus.com/</a></p><p>《Learning CoreAudio》Chris Adamson、Kevin Avila</p><p>The Amazing Audio Engine <a href="https://github.com/TheAmazingAudioEngine/TheAmazingAudioEngine">https://github.com/TheAmazingAudioEngine/TheAmazingAudioEngine</a></p><p>Audio Kit <a href="https://github.com/AudioKit/AudioKit">https://github.com/AudioKit/AudioKit</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>采集</tag>
      
      <tag>Core Audio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 使用 OpenGLES 渲染水印图片</title>
    <link href="/2022/04/19/iOS-%E4%BD%BF%E7%94%A8-OpenGLES-%E6%B8%B2%E6%9F%93%E6%B0%B4%E5%8D%B0%E5%9B%BE%E7%89%87/"/>
    <url>/2022/04/19/iOS-%E4%BD%BF%E7%94%A8-OpenGLES-%E6%B8%B2%E6%9F%93%E6%B0%B4%E5%8D%B0%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>这次我们用 OpenGLES 将水印、贴图渲染到相机的预览画面上，代码跟上一篇 <a href="https://pursue.top/2022/04/19/iOS-%E4%BD%BF%E7%94%A8-OpenGLES-%E5%AE%9E%E7%8E%B0%E7%9B%B8%E6%9C%BA%E7%94%BB%E9%9D%A2%E9%95%9C%E5%83%8F/">iOS 使用 OpenGLES 实现相机画面镜像</a> 差不多。</p><h1>实现思路</h1><p>输入的纹理应该有两路，一路是相机回调的 Pixel Buffer，一路是水印图片纹理。相机 Buffer 在视口中的大小始终是不变的，但水印图片 Size 和 Position 都是不固定的，不能使用相同的顶点坐标和视口大小绘制这两个纹理，目前想到的有两种方式可以实现：一种是两个纹理采用两个不同的顶点坐标，同时共享屏幕视口大小；一种是两个纹理采用同一组顶点坐标，采用不同的视口大小。此例采用第二种方式。</p><h1>代码</h1><p>顶点坐标还是与上一篇的一致，由于是将渲染结果输出到纹理，因此不需要做翻转，顶点坐标纹理坐标一一对应即可：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    GLKVector2 positionCoordinates;<br>    GLKVector2 textureCoordinates;<br>&#125; VerticesCoordinates;<br><br><span class="hljs-comment">// vertices</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> VerticesCoordinates vertices[] = &#123;<br>    &#123;&#123;<span class="hljs-number">-1.0</span>f, <span class="hljs-number">-1.0</span>f&#125;, &#123;<span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f&#125;&#125;, <span class="hljs-comment">// 左下</span><br>    &#123;&#123; <span class="hljs-number">1.0</span>f, <span class="hljs-number">-1.0</span>f&#125;, &#123;<span class="hljs-number">1.0</span>f, <span class="hljs-number">0.0</span>f&#125;&#125;, <span class="hljs-comment">// 右下</span><br>    &#123;&#123;<span class="hljs-number">-1.0</span>f,  <span class="hljs-number">1.0</span>f&#125;, &#123;<span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f&#125;&#125;, <span class="hljs-comment">// 左上</span><br>    &#123;&#123; <span class="hljs-number">1.0</span>f,  <span class="hljs-number">1.0</span>f&#125;, &#123;<span class="hljs-number">1.0</span>f, <span class="hljs-number">1.0</span>f&#125;&#125;  <span class="hljs-comment">// 右上</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>然后是着色器们，顶点着色器接受顶点坐标和纹理坐标转成 vec4 类型，赋值给 gl_Position，并将纹理坐标给到片段着色器。片段着色器拿到纹理坐标，通过纹理采样器计算像素颜色：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">// vertex shader</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* vertex_shader_string =<br><span class="hljs-string">&quot;attribute vec4 position;&quot;</span><br><span class="hljs-string">&quot;attribute vec4 texcoord;&quot;</span><br><span class="hljs-string">&quot;varying vec2 v_texcoord;&quot;</span><br><span class="hljs-string">&quot;void main() &#123;&quot;</span><br><span class="hljs-string">&quot;   gl_Position = position;&quot;</span><br><span class="hljs-string">&quot;   v_texcoord = texcoord.xy;&quot;</span><br><span class="hljs-string">&quot;&#125;&quot;</span>;<br><br><span class="hljs-comment">// fragment shader</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* fragment_shader_string =<br><span class="hljs-string">&quot;precision mediump float;&quot;</span><br><span class="hljs-string">&quot;varying vec2 v_texcoord;&quot;</span><br><span class="hljs-string">&quot;uniform sampler2D tex;&quot;</span><br><span class="hljs-string">&quot;void main() &#123;&quot;</span><br><span class="hljs-string">&quot;   gl_FragColor = texture2D(tex, v_texcoord);&quot;</span><br><span class="hljs-string">&quot;&#125;&quot;</span>;<br></code></pre></div></td></tr></table></figure><p>着色器程序的创建、编译代码跟上一篇一致，就不再贴了，接着看下初始化方法：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)setupGL &#123;<br>    <span class="hljs-comment">// eagl context  创建、绑定上下文</span><br>    _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];<br>    <span class="hljs-keyword">if</span> (!_context) &#123;<br>        _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];<br>        <span class="hljs-keyword">if</span> (!_context) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: video mirror processor, Error! Unable to create an OpenGL ES Context!&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!_context || ![EAGLContext setCurrentContext:_context]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;failed to setup EAGLContext&quot;</span>);<br>    &#125;<br>        <br>    <span class="hljs-comment">// texture cache   创建输入输出纹理缓冲区</span><br>    CVReturn ret = CVOpenGLESTextureCacheCreate(kCFAllocatorDefault, <span class="hljs-literal">NULL</span>, _context, <span class="hljs-literal">NULL</span>, &amp;_textureCache);<br>    <span class="hljs-keyword">if</span> (ret != kCVReturnSuccess) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: video mirror processor, Error! CVOpenGLESTextureCacheCreate failed %d&quot;</span>, ret);<br>    &#125;<br>        <br>    <span class="hljs-comment">// enable blend  打开 OpenGL 混合模式  用于纹理叠加</span><br>    glEnable(GL_BLEND);<br>  <br>  <span class="hljs-comment">// 用来设置源纹理和目标纹理的混合模式  此例中源纹理指水印图片  目标纹理指相机 Buffer</span><br>  <span class="hljs-comment">// 第一个参数是源因子  设置为 GL_ONE 表示当源纹理在某像素上 alpha 不为 0 时  则该像素完全使用源纹理</span><br>  <span class="hljs-comment">// 第二个参数是目标因子 设置为 GL_ONE_MINUS_SRC_ALPHA 表示在源纹理 alpha 为 0 的像素点使用目标纹理</span><br>  <span class="hljs-comment">// 如果第二个参数使用 GL_ZERO 完全关闭目标纹理通道，在源纹理 alpha 为 0 的位置会显示底色（黑色）</span><br>    glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);<br>        <br>    <span class="hljs-comment">// vbo  创建顶点缓冲</span><br>    glGenBuffers(<span class="hljs-number">1</span>, &amp;_vbo);<br>    glBindBuffer(GL_ARRAY_BUFFER, _vbo);<br>    glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br>        <br>    <span class="hljs-comment">// shader program  创建着色器程序并激活</span><br>    _program = build_program(vertex_shader_string, fragment_shader_string);<br>    glUseProgram(_program);<br>            <br>    <span class="hljs-comment">// setup fragment shader texture sampler</span><br>  <span class="hljs-comment">// 获取片段着色器中纹理采样器的 location 并绑定 GL_TEXTURE0</span><br>    GLint samplerLocation = glGetUniformLocation(_program, <span class="hljs-string">&quot;tex&quot;</span>);<br>    glUniform1i(samplerLocation, <span class="hljs-number">0</span>);<br>            <br>    <span class="hljs-comment">// setup vertex shader attributes</span><br>  <span class="hljs-comment">// 获取顶点着色器两个属性的 Location，打开顶点属性，设置顶点坐标纹理坐标的解析方式</span><br>    GLint posLocation = glGetAttribLocation(_program, <span class="hljs-string">&quot;position&quot;</span>);<br>    GLint texLocation = glGetAttribLocation(_program, <span class="hljs-string">&quot;texcoord&quot;</span>);<br>    glEnableVertexAttribArray(posLocation);<br>    glEnableVertexAttribArray(texLocation);<br>    glVertexAttribPointer(posLocation, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword">sizeof</span>(VerticesCoordinates), (<span class="hljs-type">void</span> *)offsetof(VerticesCoordinates, positionCoordinates));<br>    glVertexAttribPointer(texLocation, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword">sizeof</span>(VerticesCoordinates), (<span class="hljs-type">void</span> *)offsetof(VerticesCoordinates, textureCoordinates));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>两个纹理混合需要将 GL_BLEND 打开，通过 glBlendFunc 设置源因子和目标因子，不同的参数设置会产生不同的纹理叠加效果。FBO 和水印纹理的创建是动态的，所以放到渲染循环里处理：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (CVPixelBufferRef)process:(CVPixelBufferRef)pixelBuffer &#123;<br>  <span class="hljs-comment">// 避免多线程调用</span><br>    [_renderLock lock];<br>    <br>  <span class="hljs-comment">// 这里检查是否是后台、水印图片是否存在</span><br>    <span class="hljs-keyword">if</span> (_needStopDisplay || !_watermarkImage) &#123;<br>        [_renderLock unlock];<br>        <span class="hljs-keyword">return</span> _outputPixelBuffer;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 绑定上下文</span><br>    <span class="hljs-keyword">if</span> ([EAGLContext currentContext] != _context) &#123;<br>        [EAGLContext setCurrentContext:_context];<br>    &#125;<br>        <br>  <span class="hljs-comment">// 获取相机 Buffer 宽高</span><br>    GLsizei pixelWidth = (GLsizei)CVPixelBufferGetWidth(pixelBuffer);<br>    GLsizei pixelHeight = (GLsizei)CVPixelBufferGetHeight(pixelBuffer);<br>    <br>  <span class="hljs-comment">// 宽高为 0 返回</span><br>    <span class="hljs-keyword">if</span> (pixelWidth == <span class="hljs-number">0</span> || pixelHeight == <span class="hljs-number">0</span>) &#123;<br>        [_renderLock unlock];<br>        <span class="hljs-keyword">return</span> _outputPixelBuffer;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 与上一次渲染的 Size 做对比，如果不一致需要重新创建输出 Buffer 和 FBO</span><br>    <span class="hljs-keyword">if</span> (pixelWidth != _currentRenderSize.width || pixelHeight != _currentRenderSize.height) &#123;<br>        _currentRenderSize = <span class="hljs-built_in">CGSizeMake</span>(pixelWidth, pixelHeight);<br>        [<span class="hljs-keyword">self</span> setupCVPixelBuffer:&amp;_outputPixelBuffer];<br>        _needUpdateFBO = <span class="hljs-literal">YES</span>;<br>    &#125;<br>        <br>  <span class="hljs-comment">// 创建 FBO</span><br>    <span class="hljs-keyword">if</span> (_needUpdateFBO) &#123;<br>        [<span class="hljs-keyword">self</span> setupFBO];<br>        _needUpdateFBO = <span class="hljs-literal">NO</span>;<br>    &#125;<br>        <br>  <span class="hljs-comment">// 每次有图片传进来  会触发一次 setupWatermarkTexture 创建水印纹理</span><br>    <span class="hljs-keyword">if</span> (_needUpdateWatermark) &#123;<br>        [<span class="hljs-keyword">self</span> setupWatermarkTexture];<br>        _needUpdateWatermark = <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 清空输入纹理、输入纹理缓存</span><br>    <span class="hljs-keyword">if</span> (_inputTexture) &#123;<br>        <span class="hljs-built_in">CFRelease</span>(_inputTexture);<br>        _inputTexture = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    CVOpenGLESTextureCacheFlush(_textureCache, <span class="hljs-number">0</span>);<br>    <br>  <span class="hljs-comment">// 创建相机 Buffer 纹理</span><br>    CVPixelBufferLockBaseAddress(pixelBuffer, <span class="hljs-number">0</span>);<br>    CVReturn ret = CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault,<br>                                                                _textureCache,<br>                                                                pixelBuffer,<br>                                                                <span class="hljs-literal">NULL</span>,<br>                                                                GL_TEXTURE_2D,<br>                                                                GL_RGBA,<br>                                                                pixelWidth,<br>                                                                pixelHeight,<br>                                                                GL_BGRA,<br>                                                                GL_UNSIGNED_BYTE,<br>                                                                <span class="hljs-number">0</span>,<br>                                                                &amp;_inputTexture);<br>    <span class="hljs-keyword">if</span> (ret != kCVReturnSuccess) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: _inTexture, CVOpenGLESTextureCacheCreateTextureFromImage, failed.&quot;</span>);<br>    &#125;<br>    CVPixelBufferUnlockBaseAddress(pixelBuffer, <span class="hljs-number">0</span>);<br>    <br>  <span class="hljs-comment">// 绑定相机 Buffer 纹理，设置纹理参数</span><br>    glBindTexture(CVOpenGLESTextureGetTarget(_inputTexture), CVOpenGLESTextureGetName(_inputTexture));<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>    <br>  <span class="hljs-comment">// 激活着色器程序，绑定 FBO、VBO</span><br>    glUseProgram(_program);<br>    glBindFramebuffer(GL_FRAMEBUFFER, _fbo);<br>    glBindBuffer(GL_ARRAY_BUFFER, _vbo);<br>    <br>  <span class="hljs-comment">// 清空帧缓存区颜色缓冲</span><br>    glClearColor(<span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f);<br>    glClear(GL_COLOR_BUFFER_BIT);<br>    <br>  <span class="hljs-comment">// 调整视口大小为 Buffer 宽高，绘制相机 Buffer 纹理</span><br>    glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, _currentRenderSize.width, _currentRenderSize.height);<br>    glDrawArrays(GL_TRIANGLE_STRIP, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>    <br>  <span class="hljs-comment">// 绑定水印图片纹理</span><br>    glBindTexture(GL_TEXTURE_2D, _watermarkTexture);<br>  <br>  <span class="hljs-comment">// 调整视口大小为传入的水印 Position 和 Size，绘制水印图片纹理</span><br>    glViewport(_watermarkPosition.x, _watermarkPosition.y, _watermarkSize.width, _watermarkSize.height);<br>    glDrawArrays(GL_TRIANGLE_STRIP, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>    <br>  <span class="hljs-comment">// 刷新 OpenGL 队列</span><br>    glFlush();<br>  <br>  <span class="hljs-comment">// 绑定默认帧缓存</span><br>    glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br>    <br>    [_renderLock unlock];<br>    <span class="hljs-keyword">return</span> _outputPixelBuffer;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>process 方法实际是有两次绘制，先是渲染了相机 Buffer，然后调整视口大小为水印的 position 和 size，再渲染水印纹理。</p><p>创建输出 Buffer 代码：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)setupCVPixelBuffer:(CVPixelBufferRef *)pixelBuffer &#123;<br>    <span class="hljs-built_in">NSDictionary</span> *pixelBufferOptions = @&#123; (<span class="hljs-built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA),<br>                                          (<span class="hljs-built_in">NSString</span> *)kCVPixelBufferWidthKey : @(_currentRenderSize.width),<br>                                          (<span class="hljs-built_in">NSString</span> *)kCVPixelBufferHeightKey : @(_currentRenderSize.height),<br>                                          (<span class="hljs-built_in">NSString</span> *)kCVPixelBufferOpenGLESCompatibilityKey : @YES,<br>                                          (<span class="hljs-built_in">NSString</span> *)kCVPixelBufferIOSurfacePropertiesKey : @&#123;&#125; &#125;;<br>    <span class="hljs-keyword">if</span> (*pixelBuffer) &#123;<br>        CVPixelBufferRelease(*pixelBuffer);<br>        *pixelBuffer = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    CVReturn ret = CVPixelBufferCreate(kCFAllocatorDefault,<br>                                       _currentRenderSize.width,<br>                                       _currentRenderSize.height,<br>                                       kCVPixelFormatType_32BGRA,<br>                                       (__bridge  <span class="hljs-built_in">CFDictionaryRef</span>)pixelBufferOptions,<br>                                       pixelBuffer);<br>    <span class="hljs-keyword">if</span> (ret != kCVReturnSuccess) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: video mirror processor, Unable to create cvpixelbuffer %d&quot;</span>, ret);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>创建 FBO 代码：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)setupFBO &#123;<br>  <span class="hljs-comment">// 绑定上下文</span><br>    <span class="hljs-keyword">if</span> ([EAGLContext currentContext] != _context) &#123;<br>        [EAGLContext setCurrentContext:_context];<br>    &#125;<br>        <br>  <span class="hljs-comment">// 释放帧缓存</span><br>    <span class="hljs-keyword">if</span> (_fbo &gt; <span class="hljs-number">0</span>) &#123;<br>        glDeleteFramebuffers(<span class="hljs-number">1</span>, &amp;_fbo);<br>        _fbo = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 创建帧缓存</span><br>    glGenFramebuffers(<span class="hljs-number">1</span>, &amp;_fbo);<br>    <br>  <span class="hljs-comment">// 释放输出纹理</span><br>    <span class="hljs-keyword">if</span> (_outputTexture) &#123;<br>        <span class="hljs-built_in">CFRelease</span>(_outputTexture);<br>        _outputTexture = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 创建输出纹理</span><br>    CVReturn ret = CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault,<br>                                                                _textureCache,<br>                                                                _outputPixelBuffer,<br>                                                                <span class="hljs-literal">NULL</span>,<br>                                                                GL_TEXTURE_2D,<br>                                                                GL_RGBA,<br>                                                                _currentRenderSize.width,<br>                                                                _currentRenderSize.height,<br>                                                                GL_BGRA,<br>                                                                GL_UNSIGNED_BYTE,<br>                                                                <span class="hljs-number">0</span>,<br>                                                                &amp;_outputTexture);<br>    <span class="hljs-keyword">if</span> (ret != kCVReturnSuccess) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: _outputTexture, CVOpenGLESTextureCacheCreateTextureFromImage, failed.&quot;</span>);<br>    &#125;<br>    <br>  <span class="hljs-comment">// 绑定输出纹理，设置纹理参数</span><br>    glBindTexture(CVOpenGLESTextureGetTarget(_outputTexture), CVOpenGLESTextureGetName(_outputTexture));<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>    <br>  <span class="hljs-comment">// 绑定帧缓存</span><br>    glBindFramebuffer(GL_FRAMEBUFFER, _fbo);<br>  <span class="hljs-comment">// 将输出纹理绑定到帧缓存的颜色缓存</span><br>    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, CVOpenGLESTextureGetName(_outputTexture), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: failed to make complete framebuffer object %x&quot;</span>, glCheckFramebufferStatus(GL_FRAMEBUFFER));<br>    &#125;<br>    <br>  <span class="hljs-comment">// 绑定默认帧缓存</span><br>    glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>创建水印图片纹理代码：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)setupWatermarkTexture &#123;<br>  <span class="hljs-comment">// 判断图片文件的 Size 和传入的 watermarkSize 是否一致，不一致先将图片做缩放</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CGSizeEqualToSize</span>(_watermarkImage.size, _watermarkSize)) &#123;<br>        <span class="hljs-comment">// scale image</span><br>        <span class="hljs-built_in">UIGraphicsBeginImageContext</span>(_watermarkSize);<br>        [_watermarkImage drawInRect:<span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, _watermarkSize.width, _watermarkSize.height)];<br>        <span class="hljs-built_in">UIImage</span> *scaledImage = <span class="hljs-built_in">UIGraphicsGetImageFromCurrentImageContext</span>();<br>        <span class="hljs-built_in">UIGraphicsEndImageContext</span>();<br>        _watermarkImage = scaledImage;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 释放水印纹理缓冲</span><br>    <span class="hljs-keyword">if</span> (_watermarkTexture) &#123;<br>        glDeleteTextures(<span class="hljs-number">1</span>, &amp;_watermarkTexture);<br>        _watermarkTexture = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 使用 GLKit 将 CGImageRef 转成纹理对象</span><br>    <span class="hljs-built_in">NSError</span> *error;<br>    GLKTextureInfo *textureInfo = [GLKTextureLoader textureWithCGImage:_watermarkImage.CGImage options:<span class="hljs-literal">nil</span> error:&amp;error];<br>    <span class="hljs-keyword">if</span> (error) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: create watermark texture failed: %@&quot;</span>, error.localizedDescription);<br>    &#125;<br>    <br>  <span class="hljs-comment">// 绑定水印纹理缓冲，设置纹理参数</span><br>    glBindTexture(textureInfo.target, textureInfo.name);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br>    <br>  <span class="hljs-comment">// 保存纹理对象索引</span><br>    _watermarkTexture = textureInfo.name;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里使用 GLKTextureLoader 生成纹理对象时发现一个问题，_watermarkImage.CGImage 明明有值但 textureWithCGImage 方法一直在报错，报错信息是 <code>The operation couldn’t be completed. (GLKTextureLoaderErrorDomain error 8.)</code> 。通过在每行 OpenGL 代码后增加 <code>NSLog(@&quot;GL Error = %u&quot;, glGetError());</code> 打印错误信息，发现是在给片段着色器的纹理采样器绑定纹理单元时方法用错了 glUniform1i 写成了 glUniform1f，修改之后运行没有问题，也算了解了一种 OpenGL 报错的排查方式。</p><h1>后记</h1><p>代码完成后就可以放到相机的回调方法里使用了。最近一直在看 OpenGLES 的代码，目前工程里还有一些相关的工具需要写，比如像素格式转换，Buffer 裁剪的功能，之后也会总结到博客上。哇今天还是比较高产，写了两篇博客，晚上可以加个鸡腿了，疫情期间鸡腿可是奢侈品呐。。。</p>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 使用 OpenGLES 实现相机画面镜像</title>
    <link href="/2022/04/19/iOS-%E4%BD%BF%E7%94%A8-OpenGLES-%E5%AE%9E%E7%8E%B0%E7%9B%B8%E6%9C%BA%E7%94%BB%E9%9D%A2%E9%95%9C%E5%83%8F/"/>
    <url>/2022/04/19/iOS-%E4%BD%BF%E7%94%A8-OpenGLES-%E5%AE%9E%E7%8E%B0%E7%9B%B8%E6%9C%BA%E7%94%BB%E9%9D%A2%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>上一篇 <a href="https://pursue.top/2022/04/17/iOS-%E4%BD%BF%E7%94%A8-OpenGLES-%E6%B8%B2%E6%9F%93%E7%9B%B8%E6%9C%BA%E9%A2%84%E8%A7%88%E7%94%BB%E9%9D%A2/">使用 OpenGLES 渲染相机预览画面</a> 实现了自定义相机画面渲染，使用自定义的图层替代了 AVFoundation 默认渲染图层，但还需要考虑的是预览和编码镜像的问题。由于现在图层使用的 Buffer 数据来自 AVCaptureVideoDataOutput ，我们可以通过设置 AVCaptureVideoDataOutput 链接的 AVCaptureConnection 的  videoMirrored 属性，并关闭 automaticallyAdjustsVideoMirroring 去统一调整预览和编码的镜像，但有些场景需要预览镜像编码不镜像，或预览不镜像编码镜像，所以就需要一个工具类去处理预览和编码镜像不一致的场景。</p><h1>实现思路</h1><p>大批量的像素翻转不适合在 CPU 上处理，因此考虑使用 OpenGL 的离屏渲染，将输出纹理绑定在帧缓冲区的颜色缓冲，在输入纹理绑定上下文后，通过翻转顶点着色器 gl_Position 的 X 坐标实现纹理镜像。</p><h1>代码</h1><p>首先是顶点坐标的计算，自定义一个 VerticesCoordinates，positionCoordinates 表示顶点坐标，textureCoordinates 表示纹理坐标，vertices 中的 4 个坐标分别是矩形的 4 个顶点，这里跟上一篇的顶点坐标有点不同，上一篇的顶点坐标用于屏幕渲染，会有纹理原点和屏幕原点不一致的情况，所以纹理坐标的 Y 做了翻转，我们这次的输出也是纹理，所以不需要做翻转，一一对应就可以。我们绘制用的是 <code>glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);</code>，即 4 个顶点绘制 2 个三角形。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    GLKVector2 positionCoordinates;<br>    GLKVector2 textureCoordinates;<br>&#125; VerticesCoordinates;<br><br><span class="hljs-comment">// vertices</span><br>VerticesCoordinates vertices[] = &#123;<br>    &#123;&#123;<span class="hljs-number">-1.0</span>f, <span class="hljs-number">-1.0</span>f&#125;, &#123;<span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f&#125;&#125;, <span class="hljs-comment">// 左下</span><br>    &#123;&#123; <span class="hljs-number">1.0</span>f, <span class="hljs-number">-1.0</span>f&#125;, &#123;<span class="hljs-number">1.0</span>f, <span class="hljs-number">0.0</span>f&#125;&#125;, <span class="hljs-comment">// 右下</span><br>    &#123;&#123;<span class="hljs-number">-1.0</span>f,  <span class="hljs-number">1.0</span>f&#125;, &#123;<span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f&#125;&#125;, <span class="hljs-comment">// 左上</span><br>    &#123;&#123; <span class="hljs-number">1.0</span>f,  <span class="hljs-number">1.0</span>f&#125;, &#123;<span class="hljs-number">1.0</span>f, <span class="hljs-number">1.0</span>f&#125;&#125;  <span class="hljs-comment">// 右上</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>为了方便，顶点着色器和片段着色器保存在字符串里。顶点着色器定义两个 attribute 属性用来读取顶点坐标和纹理坐标，v_texcoord 属性将纹理坐标传递给片段着色器，在 main 函数里，将 gl_Position 的 X 坐标做了翻转来实现镜像效果。片段着色器先声明了 float 使用中等精度，v_texcoord 与顶点着色器对应，tex 声明一个纹理采样器，最后在 main 函数里使用纹理采样器计算出像素颜色。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">// vertex shader</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* vertex_shader_string =<br><span class="hljs-string">&quot;attribute vec2 position;&quot;</span><br><span class="hljs-string">&quot;attribute vec2 texcoord;&quot;</span><br><span class="hljs-string">&quot;varying vec2 v_texcoord;&quot;</span><br><span class="hljs-string">&quot;void main() &#123;&quot;</span><br><span class="hljs-string">&quot;   gl_Position = vec4(-position.x, position.y, 0.0, 1.0);&quot;</span><br><span class="hljs-string">&quot;   v_texcoord = texcoord;&quot;</span><br><span class="hljs-string">&quot;&#125;&quot;</span>;<br><br><span class="hljs-comment">// fragment shader</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* fragment_shader_string =<br><span class="hljs-string">&quot;precision mediump float;&quot;</span><br><span class="hljs-string">&quot;varying vec2 v_texcoord;&quot;</span><br><span class="hljs-string">&quot;uniform sampler2D tex;&quot;</span><br><span class="hljs-string">&quot;void main() &#123;&quot;</span><br><span class="hljs-string">&quot;   gl_FragColor = texture2D(tex, v_texcoord);&quot;</span><br><span class="hljs-string">&quot;&#125;&quot;</span>;<br></code></pre></div></td></tr></table></figure><p>着色器的创建、编译和链接，着色器程序的生成代码：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> GLuint compile_shader(GLuint type, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* source) &#123;<br>    GLuint shader = glCreateShader(type);<br>    glShaderSource(shader, <span class="hljs-number">1</span>, &amp;source, <span class="hljs-literal">NULL</span>);<br>    glCompileShader(shader);<br>    GLint compiled;<br>    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compiled);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br>    <span class="hljs-keyword">if</span> (!compiled) &#123;<br>        GLint length;<br>        <span class="hljs-type">char</span>* log;<br>        <br>        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;length);<br>                <br>        log = (<span class="hljs-type">char</span> *)malloc(length);<br>        glGetShaderInfoLog(shader, length, &amp;length, &amp;log[<span class="hljs-number">0</span>]);<br>        DLog(<span class="hljs-string">&quot;%s compilation error: %s\n&quot;</span>, (type == GL_VERTEX_SHADER ? <span class="hljs-string">&quot;GL_VERTEX_SHADER&quot;</span> : <span class="hljs-string">&quot;GL_FRAGMENT_SHADER&quot;</span>), log);<br>        free(log);<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    <span class="hljs-keyword">return</span> shader;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> GLuint build_program(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* vertex_shader_string, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* fragment_shader_string) &#123;<br>    GLuint vshad, fshad, p;<br>    GLint len;<br>    <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br>    <span class="hljs-type">char</span>* log;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    vshad = compile_shader(GL_VERTEX_SHADER, vertex_shader_string);<br>    fshad = compile_shader(GL_FRAGMENT_SHADER, fragment_shader_string);<br>    <br>    p = glCreateProgram();<br>    glAttachShader(p, vshad);<br>    glAttachShader(p, fshad);<br>    glLinkProgram(p);<br>    glGetProgramiv(p, GL_INFO_LOG_LENGTH, &amp;len);<br>    <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br>    <span class="hljs-keyword">if</span> (len) &#123;<br>        log = (<span class="hljs-type">char</span> *)malloc(len);<br>        glGetProgramInfoLog(p, len, &amp;len, log);<br>        DLog(<span class="hljs-string">&quot;program log: %s\n&quot;</span>, log);<br>        free(log);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    glDeleteShader(vshad);<br>    glDeleteShader(fshad);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>着色器和顶点坐标准备完成后，可以初始化 OpenGL 环境了：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)setupGL &#123;<br>    <span class="hljs-comment">// eagl context  创建 opengl 上下文</span><br>    _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];<br>    <span class="hljs-keyword">if</span> (!_context) &#123;<br>        _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];<br>        <span class="hljs-keyword">if</span> (!_context) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: video mirror processor, Error! Unable to create an OpenGL ES Context!&quot;</span>);<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">// 绑定当前线程</span><br>    <span class="hljs-keyword">if</span> (!_context || ![EAGLContext setCurrentContext:_context]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;failed to setup EAGLContext&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// texture cache  用于缓存输入输出的纹理数据</span><br>    CVReturn ret = CVOpenGLESTextureCacheCreate(kCFAllocatorDefault, <span class="hljs-literal">NULL</span>, _context, <span class="hljs-literal">NULL</span>, &amp;_textureCache);<br>    <span class="hljs-keyword">if</span> (ret != kCVReturnSuccess) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: video mirror processor, Error! CVOpenGLESTextureCacheCreate failed %d&quot;</span>, ret);<br>    &#125;<br>    <br>    <span class="hljs-comment">// vbo   顶点坐标缓冲</span><br>    glGenBuffers(<span class="hljs-number">1</span>, &amp;_vbo);<br>    glBindBuffer(GL_ARRAY_BUFFER, _vbo);<br>    glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br>    <br>    <span class="hljs-comment">// shader program   编译着色器程序</span><br>    _program = build_program(vertex_shader_string, fragment_shader_string);<br>    glUseProgram(_program);<br>    <br>    <span class="hljs-comment">// setup fragment shader texture sampler</span><br>  <span class="hljs-comment">// 拿到片段着色器里纹理采样器的 location，绑定 GL_TEXTURE0 的纹理单元</span><br>    GLint samplerLocation = glGetUniformLocation(_program, <span class="hljs-string">&quot;tex&quot;</span>);<br>    glUniform1f(samplerLocation, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// setup vertex shader attributes</span><br>  <span class="hljs-comment">// 拿到顶点着色器里两个坐标属性的 location，打开属性开关，指定顶点坐标解析规则</span><br>    GLint posLocation = glGetAttribLocation(_program, <span class="hljs-string">&quot;position&quot;</span>);<br>    GLint texLocation = glGetAttribLocation(_program, <span class="hljs-string">&quot;texcoord&quot;</span>);<br>    glEnableVertexAttribArray(posLocation);<br>    glEnableVertexAttribArray(texLocation);<br>    glVertexAttribPointer(posLocation, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword">sizeof</span>(VerticesCoordinates), (<span class="hljs-type">void</span> *)offsetof(VerticesCoordinates, positionCoordinates));<br>    glVertexAttribPointer(texLocation, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword">sizeof</span>(VerticesCoordinates), (<span class="hljs-type">void</span> *)offsetof(VerticesCoordinates, textureCoordinates));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于帧缓冲区输出的纹理依赖输入的 Pixel Buffer 的宽高，所以 fbo 和输出纹理放到 process 方法里动态创建。在初始化 OpenGL 环境后，就可以调用 process 来渲染了：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (CVPixelBufferRef)process:(CVPixelBufferRef)pixelBuffer &#123;<br>  <span class="hljs-comment">// 避免多线程调用  </span><br>    [_renderLock lock];<br>    <br>  <span class="hljs-comment">// 如果是后台  停止渲染</span><br>    <span class="hljs-keyword">if</span> (_needStopDisplay) &#123;<br>        [_renderLock unlock];<br>        <span class="hljs-keyword">return</span> _outputPixelBuffer;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 绑定当前线程上下文</span><br>    <span class="hljs-keyword">if</span> ([EAGLContext currentContext] != _context) &#123;<br>        [EAGLContext setCurrentContext:_context];<br>    &#125;<br>    <br>  <span class="hljs-comment">// 拿到输入纹理宽高</span><br>    GLsizei pixelWidth = (GLsizei)CVPixelBufferGetWidth(pixelBuffer);<br>    GLsizei pixelHeight = (GLsizei)CVPixelBufferGetHeight(pixelBuffer);<br>    <br>  <span class="hljs-comment">// 如果宽高是 0 直接返回</span><br>    <span class="hljs-keyword">if</span> (pixelWidth == <span class="hljs-number">0</span> || pixelHeight == <span class="hljs-number">0</span>) &#123;<br>        [_renderLock unlock];<br>        <span class="hljs-keyword">return</span> _outputPixelBuffer;<br>    &#125;<br>    <br>  <span class="hljs-comment">// _currentRenderSize 用来记录上次渲染的宽高，如果输入纹理宽高与 _currentRenderSize 不一致，需要重新分配输出 Buffer 并重新初始化 FBO</span><br>    <span class="hljs-keyword">if</span> (pixelWidth != _currentRenderSize.width || pixelHeight != _currentRenderSize.height) &#123;<br>        _currentRenderSize = <span class="hljs-built_in">CGSizeMake</span>(pixelWidth, pixelHeight);<br>        [<span class="hljs-keyword">self</span> setupCVPixelBuffer:&amp;_outputPixelBuffer];<br>        _needUpdateFBO = <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 输入纹理宽高发生变化，或 App 返回前台，重新初始化 FBO</span><br>    <span class="hljs-keyword">if</span> (_needUpdateFBO) &#123;<br>        [<span class="hljs-keyword">self</span> setupFBO];<br>        _needUpdateFBO = <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 释放输入纹理，清空输入纹理缓存</span><br>    <span class="hljs-keyword">if</span> (_inputTexture) &#123;<br>        <span class="hljs-built_in">CFRelease</span>(_inputTexture);<br>        _inputTexture = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    CVOpenGLESTextureCacheFlush(_textureCache, <span class="hljs-number">0</span>);<br>    <br>  <span class="hljs-comment">// 从 Pixel Buffer 读数据前，需要先上锁</span><br>    CVPixelBufferLockBaseAddress(pixelBuffer, <span class="hljs-number">0</span>);<br>    CVReturn ret = CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault,<br>                                                                _textureCache,<br>                                                                pixelBuffer,<br>                                                                <span class="hljs-literal">NULL</span>,<br>                                                                GL_TEXTURE_2D,<br>                                                                GL_RGBA,<br>                                                                pixelWidth,<br>                                                                pixelHeight,<br>                                                                GL_BGRA,<br>                                                                GL_UNSIGNED_BYTE,<br>                                                                <span class="hljs-number">0</span>,<br>                                                                &amp;_inputTexture);<br>    <span class="hljs-keyword">if</span> (ret != kCVReturnSuccess) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: _inTexture, CVOpenGLESTextureCacheCreateTextureFromImage, failed.&quot;</span>);<br>    &#125;<br>    CVPixelBufferUnlockBaseAddress(pixelBuffer, <span class="hljs-number">0</span>);<br>    <br>  <span class="hljs-comment">// 绑定输入纹理，设置纹理参数</span><br>    glBindTexture(CVOpenGLESTextureGetTarget(_inputTexture), CVOpenGLESTextureGetName(_inputTexture));<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>    <br>  <span class="hljs-comment">// 激活着色器程序，绑定 FBO、VBO</span><br>    glUseProgram(_program);<br>    glBindFramebuffer(GL_FRAMEBUFFER, _fbo);<br>    glBindBuffer(GL_ARRAY_BUFFER, _vbo);<br>    <br>  <span class="hljs-comment">// 清空帧缓冲区颜色缓冲</span><br>    glClearColor(<span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f);<br>    glClear(GL_COLOR_BUFFER_BIT);<br>    <br>  <span class="hljs-comment">// 调整视口大小</span><br>    glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, _currentRenderSize.width, _currentRenderSize.height);<br>  <br>  <span class="hljs-comment">// 用 4 个顶点绘制 2 个三角形</span><br>    glDrawArrays(GL_TRIANGLE_STRIP, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>    <br>  <span class="hljs-comment">// flush OpenGL 队列</span><br>    glFlush();<br>  <br>  <span class="hljs-comment">// 绑定默认帧缓冲</span><br>    glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br>    <br>    [_renderLock unlock];<br>    <span class="hljs-keyword">return</span> _outputPixelBuffer;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>27 行位置判断当前输入的 Pixel Buffer 宽高是否与上一次渲染的宽高一致，如果不一致会重新创建输出的 Pixel Buffer：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)setupCVPixelBuffer:(CVPixelBufferRef *)pixelBuffer &#123;<br>    <span class="hljs-built_in">NSDictionary</span> *pixelBufferOptions = @&#123; (<span class="hljs-built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA),<br>                                          (<span class="hljs-built_in">NSString</span> *)kCVPixelBufferWidthKey : @(_currentRenderSize.width),<br>                                          (<span class="hljs-built_in">NSString</span> *)kCVPixelBufferHeightKey : @(_currentRenderSize.height),<br>                                          (<span class="hljs-built_in">NSString</span> *)kCVPixelBufferOpenGLESCompatibilityKey : @YES,<br>                                          (<span class="hljs-built_in">NSString</span> *)kCVPixelBufferIOSurfacePropertiesKey : @&#123;&#125; &#125;;<br>    <span class="hljs-keyword">if</span> (*pixelBuffer) &#123;<br>        CVPixelBufferRelease(*pixelBuffer);<br>        *pixelBuffer = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    CVReturn ret = CVPixelBufferCreate(kCFAllocatorDefault,<br>                                       _currentRenderSize.width,<br>                                       _currentRenderSize.height,<br>                                       kCVPixelFormatType_32BGRA,<br>                                       (__bridge  <span class="hljs-built_in">CFDictionaryRef</span>)pixelBufferOptions,<br>                                       pixelBuffer);<br>    <span class="hljs-keyword">if</span> (ret != kCVReturnSuccess) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: video mirror processor, Unable to create cvpixelbuffer %d&quot;</span>, ret);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>随后会重新初始化帧缓冲区和输出纹理：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)setupFBO &#123;<br>  <span class="hljs-comment">// 绑定当前线程上下文</span><br>    <span class="hljs-keyword">if</span> ([EAGLContext currentContext] != _context) &#123;<br>        [EAGLContext setCurrentContext:_context];<br>    &#125;<br>        <br>  <span class="hljs-comment">// 清空 FBO</span><br>    <span class="hljs-keyword">if</span> (_fbo &gt; <span class="hljs-number">0</span>) &#123;<br>        glDeleteFramebuffers(<span class="hljs-number">1</span>, &amp;_fbo);<br>        _fbo = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 创建 FBO</span><br>    glGenFramebuffers(<span class="hljs-number">1</span>, &amp;_fbo);<br>    <br>  <span class="hljs-comment">// 释放输出纹理</span><br>    <span class="hljs-keyword">if</span> (_outputTexture) &#123;<br>        <span class="hljs-built_in">CFRelease</span>(_outputTexture);<br>        _outputTexture = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 创建输出纹理</span><br>    CVReturn ret = CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault,<br>                                                                _textureCache,<br>                                                                _outputPixelBuffer,<br>                                                                <span class="hljs-literal">NULL</span>,<br>                                                                GL_TEXTURE_2D,<br>                                                                GL_RGBA,<br>                                                                <br>                                                                _currentRenderSize.width,<br>                                                                _currentRenderSize.height,<br>                                                                GL_BGRA,<br>                                                                GL_UNSIGNED_BYTE,<br>                                                                <span class="hljs-number">0</span>,<br>                                                                &amp;_outputTexture);<br>    <span class="hljs-keyword">if</span> (ret != kCVReturnSuccess) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: _outputTexture, CVOpenGLESTextureCacheCreateTextureFromImage, failed.&quot;</span>);<br>    &#125;<br>    <br>  <span class="hljs-comment">// 绑定输出纹理到纹理缓冲区，设置纹理参数</span><br>    glBindTexture(CVOpenGLESTextureGetTarget(_outputTexture), CVOpenGLESTextureGetName(_outputTexture));<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>    <br>  <span class="hljs-comment">// 绑定帧缓冲</span><br>    glBindFramebuffer(GL_FRAMEBUFFER, _fbo);<br>  <span class="hljs-comment">// 将输出纹理绑定到帧缓冲的颜色缓冲</span><br>    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, CVOpenGLESTextureGetName(_outputTexture), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: failed to make complete framebuffer object %x&quot;</span>, glCheckFramebufferStatus(GL_FRAMEBUFFER));<br>    &#125;<br>    <br>  <span class="hljs-comment">// 绑定默认帧缓冲</span><br>    glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>setupFBO 创建了帧缓冲，并将输出纹理绑定到帧缓冲的颜色缓冲上，处理完成后将 _outputPixelBuffer 返回给调用者。</p><p>另外还有一些前后台的处理：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)handleApplicationDidEnterBackground:(<span class="hljs-built_in">NSNotification</span> *)notification &#123;<br>    [_renderLock lock];<br>    _needStopDisplay = <span class="hljs-literal">YES</span>;<br>  <span class="hljs-comment">// 主要是清空纹理缓存和 FBO</span><br>    [<span class="hljs-keyword">self</span> destroyGL];<br>    glFinish();<br>    [_renderLock unlock];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)handleApplicationDidBecomeActive:(<span class="hljs-built_in">NSNotification</span> *)notification &#123;<br>    [_renderLock lock];<br>    _needStopDisplay = <span class="hljs-literal">NO</span>;<br>    <span class="hljs-keyword">if</span> (!_fbo) &#123;<br>        _needUpdateFBO = <span class="hljs-literal">YES</span>;<br>    &#125;<br>    [_renderLock unlock];<br>&#125;<br></code></pre></div></td></tr></table></figure><h1>后记</h1><p>代码完成后，就可以在 didOutputSampleBuffer 回调里使用了，这样，前后置预览镜像和编码镜像就都可以单独配置了，镜像后的数据可以输入到下一级的 processor 中做处理，最终吐给编码器编码。</p>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 使用 OpenGLES 渲染相机预览画面</title>
    <link href="/2022/04/17/iOS-%E4%BD%BF%E7%94%A8-OpenGLES-%E6%B8%B2%E6%9F%93%E7%9B%B8%E6%9C%BA%E9%A2%84%E8%A7%88%E7%94%BB%E9%9D%A2/"/>
    <url>/2022/04/17/iOS-%E4%BD%BF%E7%94%A8-OpenGLES-%E6%B8%B2%E6%9F%93%E7%9B%B8%E6%9C%BA%E9%A2%84%E8%A7%88%E7%94%BB%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>上一篇有提到 <a href="https://pursue.top/2022/04/07/%E4%BD%BF%E7%94%A8-AVFoundation-%E9%87%87%E9%9B%86%E7%9B%B8%E6%9C%BA%E7%94%BB%E9%9D%A2/">使用 AVFoundation 采集相机画面</a>，并渲染到苹果内置的 AVCaptureVideoPreviewLayer 图层上，代码很简单，但使用上有很大局限性。AVCaptureSession 采集到的原始视频帧直接给到了 AVCaptureVideoPreviewLayer 用于渲染，我们没办法在中间环节处理视频帧数据，美颜滤镜也就没办法实现，所以我们需要借助 OpenGLES 自己实现画面渲染。</p><p>苹果的 GLKit 框架对 OpenGLES 的部分接口调用做了封装，使用起来非常方便。我们的需求可以直接使用 GLKView 实现，开发的代码量是比较少的，但为了熟悉 OpenGLES 的接口调用和管线渲染流程，我们还是使用最原始的方法，基于 CAEAGLLayer，自己来实现着色器代码。</p><h1>代码实现</h1><h2 id="准备工作">准备工作</h2><h3 id="使用-CAEAGLLayer">使用 CAEAGLLayer</h3><p>首先在项目中创建一个继承 UIView 的 XPGLKView，如果需要在图层上自定义 OpenGL 渲染，需要将 UIView 的 layerClass 设置为 CAEAGLLayer：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">XPGLKView</span></span><br><br>+(Class)layerClass &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">CAEAGLLayer</span> <span class="hljs-keyword">class</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="顶点数据计算">顶点数据计算</h3><p>我们需要计算两类坐标，一类是 OpenGL 顶点坐标，一类是纹理贴图的坐标，先定义一个结构体类型，包含两类坐标：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    GLKVector2 positionCoordinates;<br>    GLKVector2 textureCoordinates;<br>&#125; VerticesCoordinates;<br></code></pre></div></td></tr></table></figure><p>我们的场景只需要 4 个顶点，使用  <code>glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);</code> 即可绘制两个三角形，按照顶点坐标和纹理坐标一一对应的关系，可以得到一个初步的顶点数据：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">VerticesCoordinates vertices[] = &#123;<br>    &#123;&#123;<span class="hljs-number">-1.0</span>f, <span class="hljs-number">-1.0</span>f&#125;, &#123;<span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f&#125;&#125;, <span class="hljs-comment">// 左下</span><br>    &#123;&#123; <span class="hljs-number">1.0</span>f, <span class="hljs-number">-1.0</span>f&#125;, &#123;<span class="hljs-number">1.0</span>f, <span class="hljs-number">0.0</span>f&#125;&#125;, <span class="hljs-comment">// 右下</span><br>    &#123;&#123;<span class="hljs-number">-1.0</span>f,  <span class="hljs-number">1.0</span>f&#125;, &#123;<span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f&#125;&#125;, <span class="hljs-comment">// 左上</span><br>    &#123;&#123; <span class="hljs-number">1.0</span>f,  <span class="hljs-number">1.0</span>f&#125;, &#123;<span class="hljs-number">1.0</span>f, <span class="hljs-number">1.0</span>f&#125;&#125;  <span class="hljs-comment">// 右上</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>上面看着没什么问题，但实际渲染发现图像上下颠倒了，原因是使用 CoreVideo 框架读取 Pixel Buffer 数据时是按照屏幕坐标原点（左上角）开始的，而纹理坐标正好相反，所以我们需要翻转一下纹理坐标的 Y 轴，得到最终的顶点数据：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">VerticesCoordinates vertices[] = &#123;<br>    &#123;&#123;<span class="hljs-number">-1.0</span>f, <span class="hljs-number">-1.0</span>f&#125;, &#123;<span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f&#125;&#125;, <span class="hljs-comment">// 左下</span><br>    &#123;&#123; <span class="hljs-number">1.0</span>f, <span class="hljs-number">-1.0</span>f&#125;, &#123;<span class="hljs-number">1.0</span>f, <span class="hljs-number">1.0</span>f&#125;&#125;, <span class="hljs-comment">// 右下</span><br>    &#123;&#123;<span class="hljs-number">-1.0</span>f,  <span class="hljs-number">1.0</span>f&#125;, &#123;<span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f&#125;&#125;, <span class="hljs-comment">// 左上</span><br>    &#123;&#123; <span class="hljs-number">1.0</span>f,  <span class="hljs-number">1.0</span>f&#125;, &#123;<span class="hljs-number">1.0</span>f, <span class="hljs-number">0.0</span>f&#125;&#125;  <span class="hljs-comment">// 右上</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="着色器程序">着色器程序</h3><p>为了代码整洁，我们封装一个着色器程序，包含着色器的初始化、编译和链接功能：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">// 初始化方法接受顶点着色器和片段着色器的代码字符串，创建着色器程序后，调用 compileShader 编译着色器，最后将着色器绑定在当前着色器程序上</span><br>- (<span class="hljs-keyword">instancetype</span>)initWithVertexShaderString:(<span class="hljs-built_in">NSString</span> *)vShaderString fragmentShaderString:(<span class="hljs-built_in">NSString</span> *)fShaderString &#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        _attributes = [<span class="hljs-built_in">NSMutableArray</span> array];<br>        _ID = glCreateProgram();<br>        <br>        <span class="hljs-keyword">if</span> (![<span class="hljs-keyword">self</span> compileShader:&amp;_vertexShader type:GL_VERTEX_SHADER string:vShaderString]) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Failed to compile vertex shader&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (![<span class="hljs-keyword">self</span> compileShader:&amp;_fragmentShader type:GL_FRAGMENT_SHADER string:fShaderString]) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Failed to compile fragment shader&quot;</span>);<br>        &#125;<br>        <br>        glAttachShader(_ID, _vertexShader);<br>        glAttachShader(_ID, _fragmentShader);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-comment">// 释放</span><br>- (<span class="hljs-type">void</span>)dealloc &#123;<br>    <span class="hljs-keyword">if</span> (_vertexShader) &#123;<br>        glDeleteShader(_vertexShader);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (_fragmentShader) &#123;<br>        glDeleteShader(_fragmentShader);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (_ID) &#123;<br>        glDeleteProgram(_ID);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建、编译着色器</span><br>- (<span class="hljs-type">BOOL</span>)compileShader:(GLuint *)shader type:(GLenum)type string:(<span class="hljs-built_in">NSString</span> *)shaderString &#123;<br>    GLint status;<br>    <span class="hljs-keyword">const</span> GLchar *source = (GLchar *)[shaderString UTF8String];<br>    <span class="hljs-keyword">if</span> (!source) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Failed to load shader string&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 创建着色器</span><br>    *shader = glCreateShader(type);<br>  <span class="hljs-comment">// 绑定着色器代码</span><br>    glShaderSource(*shader, <span class="hljs-number">1</span>, &amp;source, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-comment">// 编译着色器</span><br>    glCompileShader(*shader);<br>    <br>  <span class="hljs-comment">// 检查着色器编译状态</span><br>    glGetShaderiv(*shader, GL_COMPILE_STATUS, &amp;status);<br>    <span class="hljs-keyword">if</span> (status != GL_TRUE) &#123;<br>        GLint logLength;<br>        glGetShaderiv(*shader, GL_INFO_LOG_LENGTH, &amp;logLength);<br>        <span class="hljs-keyword">if</span> (logLength) &#123;<br>            GLchar *log = (GLchar *)malloc(logLength);<br>            glGetShaderInfoLog(*shader, logLength, &amp;logLength, log);<br>            <span class="hljs-keyword">if</span> (shader == &amp;_vertexShader) &#123;<br>                <span class="hljs-keyword">self</span>.vertexShaderLog = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%s&quot;</span>, log];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">self</span>.fragmentShaderLog = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%s&quot;</span>, log];<br>            &#125;<br>            free(log);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> status == GL_TRUE;<br>&#125;<br><br><span class="hljs-comment">// 链接着色器</span><br>- (<span class="hljs-type">BOOL</span>)link &#123;<br>    GLint status;<br>    glLinkProgram(_ID);<br>    glGetProgramiv(_ID, GL_LINK_STATUS, &amp;status);<br>    <span class="hljs-keyword">if</span> (status == GL_FALSE) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (_vertexShader) &#123;<br>        glDeleteShader(_vertexShader);<br>        _vertexShader = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (_fragmentShader) &#123;<br>        glDeleteShader(_fragmentShader);<br>        _fragmentShader = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br><span class="hljs-comment">// 使用着色器程序</span><br>- (<span class="hljs-type">void</span>)use &#123;<br>    glUseProgram(_ID);<br>&#125;<br><br><span class="hljs-comment">// 给顶点着色器属性绑定 location</span><br>- (<span class="hljs-type">void</span>)addAttribute:(<span class="hljs-built_in">NSString</span> *)attributeName &#123;<br>    <span class="hljs-keyword">if</span> (![_attributes containsObject:attributeName]) &#123;<br>        [_attributes addObject:attributeName];<br>        glBindAttribLocation(_ID, (GLuint)[_attributes indexOfObject:attributeName], [attributeName UTF8String]);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 获取顶点着色器属性 location</span><br>- (GLuint)getAttributeLocation:(<span class="hljs-built_in">NSString</span> *)attributeName &#123;<br>    <span class="hljs-keyword">return</span> (GLuint)[_attributes indexOfObject:attributeName];<br>&#125;<br><br><span class="hljs-comment">// 获取 uniform 属性 localtion</span><br>- (GLuint)getUniformLocation:(<span class="hljs-built_in">NSString</span> *)uniformName &#123;<br>    <span class="hljs-keyword">return</span> glGetUniformLocation(_ID, [uniformName UTF8String]);<br>&#125;<br><br><span class="hljs-comment">// 打印错误信息</span><br>- (<span class="hljs-type">void</span>)showError &#123;<br>    <span class="hljs-built_in">NSString</span> *progLog = [<span class="hljs-keyword">self</span> programLog];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Program link log: %@&quot;</span>, progLog);<br>    <span class="hljs-built_in">NSString</span> *fragLog = [<span class="hljs-keyword">self</span> fragmentShaderLog];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Fragment shader compile log: %@&quot;</span>, fragLog);<br>    <span class="hljs-built_in">NSString</span> *vertLog = [<span class="hljs-keyword">self</span> vertexShaderLog];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Vertex shader compile log: %@&quot;</span>, vertLog);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>有了着色器程序，再来看下顶点着色器和片段着色器的代码：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">// 顶点着色器</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *XP_GLK_VSH = <span class="hljs-string">@&quot; \</span><br><span class="hljs-string">attribute vec4 position; \</span><br><span class="hljs-string">attribute vec4 inputTextureCoordinate; \</span><br><span class="hljs-string">varying vec2 textureCoordinate; \</span><br><span class="hljs-string">\</span><br><span class="hljs-string">void main() \</span><br><span class="hljs-string">&#123; \</span><br><span class="hljs-string">gl_Position = position; \</span><br><span class="hljs-string">textureCoordinate = inputTextureCoordinate.xy; \</span><br><span class="hljs-string">&#125; \</span><br><span class="hljs-string">&quot;</span>;<br><br><span class="hljs-comment">// 顶点着色器有两个 attribute 的属性，position 是从顶点缓冲区获取的顶点坐标</span><br><span class="hljs-comment">// inputTextureCoordinate 则是纹理坐标，这两个属性的类型是 vec4，是一个四维的坐标</span><br><span class="hljs-comment">// 而我们创建的顶点、纹理坐标是二维的，opengl 会使用默认自动转成 vec4 类型</span><br><span class="hljs-comment">// textureCoordinate 是顶点着色器传递给片段着色器的属性，片段着色器使用 textureCoordinate 计算纹理颜色</span><br><br><span class="hljs-comment">// ************************************************************************</span><br><br><span class="hljs-comment">// 片段着色器</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *XP_GLK_FSH = <span class="hljs-string">@&quot; \</span><br><span class="hljs-string">varying highp vec2 textureCoordinate; \</span><br><span class="hljs-string">uniform sampler2D inputImageTexture; \</span><br><span class="hljs-string">\</span><br><span class="hljs-string">void main() \</span><br><span class="hljs-string">&#123; \</span><br><span class="hljs-string">gl_FragColor = texture2D(inputImageTexture, textureCoordinate); \</span><br><span class="hljs-string">&#125; \</span><br><span class="hljs-string">&quot;</span>;<br><br><span class="hljs-comment">// textureCoordinate 是从顶点着色器传过来的顶点坐标，inputImageTexture 是纹理采样器</span><br><span class="hljs-comment">// texture2D()方法计算纹理在该点的颜色值，输出给 gl_FragColor</span><br><span class="hljs-comment">// 纹理采样器需要在使用前先绑定到纹理单元，稍后代码会有提到</span><br></code></pre></div></td></tr></table></figure><p>有了顶点数据和着色器程序，接下来看一下 XPGLKView 的初始化代码。</p><h2 id="初始化">初始化</h2><p>初始化方法中设置一些变量的默认值，主要还是配置 OpenGL 环境：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)commonInit &#123;<br>  <span class="hljs-comment">// 标志位用于控制后台停止渲染</span><br>    _needStopDisplay = <span class="hljs-literal">NO</span>;<br>    <span class="hljs-comment">// 填充模式</span><br>    _fillMode = XPVideoFillModeAspectFill;<br>  <span class="hljs-comment">// 递归锁 用来控制 openGL 的 API </span><br>    _renderLock = [[<span class="hljs-built_in">NSRecursiveLock</span> alloc] init];<br>    <br>    <span class="hljs-comment">// add observer</span><br>    [<span class="hljs-keyword">self</span> addObservers];<br>    <br>    <span class="hljs-comment">// layer</span><br>  <span class="hljs-comment">// 首先是拿到 UIView 上的 CAEAGLLayer 图层做一些设置，opaque 属性设置为 YES 可以提升渲染效率</span><br>  <span class="hljs-comment">// contentsScale 比例因子设置为屏幕的比例因子，是为了适配 Retina 这类高分辨率的屏幕</span><br>  <span class="hljs-comment">// drawableProperties 设置的两个 Key &amp; Value，kEAGLDrawablePropertyRetainedBacking 设置为 NO 表示当前帧绘制后就清空其内容</span><br>  <span class="hljs-comment">// kEAGLDrawablePropertyColorFormat 设置为 kEAGLColorFormatRGBA8 设置 renderBuffer 按 32位存储</span><br>    <span class="hljs-built_in">CAEAGLLayer</span> *layer = (<span class="hljs-built_in">CAEAGLLayer</span> *)<span class="hljs-keyword">self</span>.layer;<br>    layer.opaque = <span class="hljs-literal">YES</span>;<br>    layer.contentsScale = [[<span class="hljs-built_in">UIScreen</span> mainScreen] scale];<br>    layer.drawableProperties = [<span class="hljs-built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:[<span class="hljs-built_in">NSNumber</span> numberWithBool:<span class="hljs-literal">NO</span>], kEAGLDrawablePropertyRetainedBacking, kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, <span class="hljs-literal">nil</span>];<br>        <br>    <span class="hljs-comment">// EAGLContext</span><br>  <span class="hljs-comment">// 创建 OpenGL 上下文，如果不支持 OpenGLES 3.0 则使用 2.0 版本，创建好后将上下文绑定到当前线程。</span><br>    <span class="hljs-keyword">if</span> (!_context) &#123;<br>        _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];<br>        <span class="hljs-keyword">if</span> (!_context) &#123;<br>            _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!_context || ![EAGLContext setCurrentContext:_context]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;failed to setup EAGLContext&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// clear color - black</span><br>  <span class="hljs-comment">// 默认填充颜色 - 黑色</span><br>    _backgroundColor = GLKVector4Make(<span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f);<br>    <br>    <span class="hljs-comment">// texture cache</span><br>  <span class="hljs-comment">// 创建纹理数据缓冲区，CVOpenGLESTextureRef 和 CVOpenGLESTextureCacheRef 来自 CoreVideo 框架</span><br>  <span class="hljs-comment">// 此例中用于将相机回调的 Pixel Buffer 转换成 OpenGL 的纹理缓存</span><br>    CVReturn ret = CVOpenGLESTextureCacheCreate(kCFAllocatorDefault, <span class="hljs-literal">NULL</span>, _context, <span class="hljs-literal">NULL</span>, &amp;_textureCache);<br>    <span class="hljs-keyword">if</span> (ret != kCVReturnSuccess) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;CVOpenGLESTextureCacheCreate: %d&quot;</span>, ret);<br>    &#125;<br>    <br>    <span class="hljs-comment">// program</span><br>  <span class="hljs-comment">// 创建着色器程序，编译链接顶点着色器和片段着色器，并给顶端着色器绑定两个属性，顶点坐标和纹理坐标</span><br>    _program = [[XPGLKProgram alloc] initWithVertexShaderString:XP_GLK_VSH fragmentShaderString:XP_GLK_FSH];<br>    [_program addAttribute:<span class="hljs-string">@&quot;position&quot;</span>];<br>    [_program addAttribute:<span class="hljs-string">@&quot;inputTextureCoordinate&quot;</span>];<br>    <span class="hljs-keyword">if</span> (![_program link]) &#123;<br>        [_program showError];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Filter shader link failed&quot;</span>);<br>        _program = <span class="hljs-literal">nil</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// create FBO</span><br>  <span class="hljs-comment">// 创建帧缓存</span><br>    glGenFramebuffers(<span class="hljs-number">1</span>, &amp;_frameBuffer);<br>    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);<br>    <br>  <span class="hljs-comment">// 创建颜色渲染缓存</span><br>    glGenRenderbuffers(<span class="hljs-number">1</span>, &amp;_renderBuffer);<br>    glBindRenderbuffer(GL_RENDERBUFFER, _renderBuffer);<br>    <br>  <span class="hljs-comment">// 借助 layer 给 renderBuffer 分配空间（像素点个数、每个像素点占多少位）</span><br>    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(<span class="hljs-built_in">CAEAGLLayer</span> *)<span class="hljs-keyword">self</span>.layer];<br>    <br>  <span class="hljs-comment">// 获取初始化后的 renderBuffer 宽高</span><br>    GLint backingWidth, backingHeight;<br>    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;backingWidth);<br>    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;backingHeight);<br>    <br>  <span class="hljs-comment">// 如果是 0，直接销毁返回</span><br>    <span class="hljs-keyword">if</span> (backingWidth == <span class="hljs-number">0</span> || backingHeight == <span class="hljs-number">0</span>) &#123;<br>        [<span class="hljs-keyword">self</span> destroyFrameBuffer];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 记录下来，用于调整视口大小</span><br>    _viewportSize.width = (<span class="hljs-built_in">CGFloat</span>)backingWidth;<br>    _viewportSize.height = (<span class="hljs-built_in">CGFloat</span>)backingHeight;<br>    <br>  <span class="hljs-comment">// 将 renderBuffer 绑定到帧缓存的颜色缓冲区</span><br>    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _renderBuffer);<br>  <span class="hljs-comment">// 检查帧缓存状态</span><br>    GLuint framebufferStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);<br>    <span class="hljs-keyword">if</span> (framebufferStatus != GL_FRAMEBUFFER_COMPLETE) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Fail setup GL framebuffer %d:%d&quot;</span>, backingWidth, backingHeight);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Success setup GL framebuffer %d:%d&quot;</span>, backingWidth, backingHeight);<br>    &#125;<br>    <br>    <span class="hljs-comment">// create VBO</span><br>  <span class="hljs-comment">// 创建顶点数据缓存</span><br>    glGenBuffers(<span class="hljs-number">1</span>, &amp;_vertexBuffer);<br>    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);<br>    glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(_vertices), _vertices, GL_DYNAMIC_DRAW);<br>    <br>    <span class="hljs-comment">// attributes、uniforms</span><br>  <span class="hljs-comment">// 获取顶点着色器定义的属性的 location</span><br>    _positionAttribute = [_program getAttributeLocation:<span class="hljs-string">@&quot;position&quot;</span>];<br>    _textureCoordinateAttribute = [_program getAttributeLocation:<span class="hljs-string">@&quot;inputTextureCoordinate&quot;</span>];<br>  <br>  <span class="hljs-comment">// 获取片段着色器定义的纹理采样器的 location</span><br>    _inputTextureUniform = [_program getUniformLocation:<span class="hljs-string">@&quot;inputImageTexture&quot;</span>];<br>    <br>  <span class="hljs-comment">// 打开顶点着色器属性</span><br>    glEnableVertexAttribArray(_positionAttribute);<br>    glEnableVertexAttribArray(_textureCoordinateAttribute);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先通过 layer 配置帧缓冲区的一些属性，随后初始化并绑定上下文，创建我们封装过的着色器程序，创建帧缓存、顶点缓存，最后将顶点着色器属性打开。</p><h2 id="渲染">渲染</h2><p>初始化之后，就可以准备渲染画面了，渲染方法触发的时机是 AVCaptureSession 的相机数据帧回调，我们在回调里切换渲染线程，调用 displayPixelBuffer 方法：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - AVCaptureVideoDataOutputSampleBufferDelegate</span><br>- (<span class="hljs-type">void</span>)captureOutput:(<span class="hljs-built_in">AVCaptureOutput</span> *)captureOutput didOutputSampleBuffer:(<span class="hljs-built_in">CMSampleBufferRef</span>)sampleBuffer fromConnection:(<span class="hljs-built_in">AVCaptureConnection</span> *)connection &#123;<br>    CVPixelBufferRef originPixelBuffer = <span class="hljs-built_in">CMSampleBufferGetImageBuffer</span>(sampleBuffer);<br>    XPDispatchSync(<span class="hljs-keyword">self</span>.renderQueue, cameraSourceRenderQueueKey, ^&#123;<br>        [<span class="hljs-keyword">self</span>.previewView displayPixelBuffer:originPixelBuffer];<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>渲染的方法实现：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)displayPixelBuffer:(CVPixelBufferRef)pixelBuffer &#123;<br>  <span class="hljs-comment">// 避免在当前上下文使用多线程调用 opengl 接口  这里用了递归锁</span><br>    [_renderLock lock];<br>    <br>    <span class="hljs-comment">// check needStopDisplay</span><br>  <span class="hljs-comment">// 后台不渲染</span><br>    <span class="hljs-keyword">if</span> (_needStopDisplay) &#123;<br>        [_renderLock unlock];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// checkout eagl context</span><br>  <span class="hljs-comment">// 校验上下文</span><br>    <span class="hljs-keyword">if</span> ([EAGLContext currentContext] != _context) &#123;<br>        [EAGLContext setCurrentContext:_context];<br>    &#125;<br>    <br>    <span class="hljs-comment">// use program</span><br>  <span class="hljs-comment">// 使用着色器程序</span><br>    [_program use];<br>    <br>    <span class="hljs-comment">// bind frame buffer</span><br>  <span class="hljs-comment">// 绑定帧缓冲  根据颜色渲染缓冲的 buffer 大小更新视口</span><br>    glBindFramebuffer(GL_FRAMEBUFFER, _frameBuffer);<br>    glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (GLint)_viewportSize.width, (GLint)_viewportSize.height);<br>    <br>    <span class="hljs-comment">// clean cache</span><br>  <span class="hljs-comment">// 刷新深度缓冲、颜色缓冲</span><br>    glClearColor(_backgroundColor.r, _backgroundColor.g, _backgroundColor.b, _backgroundColor.a);<br>    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>    <br>    <span class="hljs-comment">// clean texture and texture cache</span><br>  <span class="hljs-comment">// 清理纹理缓冲</span><br>    <span class="hljs-keyword">if</span> (_texture) &#123;<br>        <span class="hljs-built_in">CFRelease</span>(_texture);<br>        _texture = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    CVOpenGLESTextureCacheFlush(_textureCache, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// create a CVOpenGLESTexture from the CVImageBuffer</span><br>  <span class="hljs-comment">// pixel buffer 转换成纹理数据</span><br>    size_t frameWidth = CVPixelBufferGetWidth(pixelBuffer);<br>    size_t frameHeight = CVPixelBufferGetHeight(pixelBuffer);<br>    CVPixelBufferLockBaseAddress(pixelBuffer, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 相当于 glTexImage2D()</span><br>    CVReturn ret = CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault,<br>                                                                _textureCache,<br>                                                                pixelBuffer,<br>                                                                <span class="hljs-literal">NULL</span>,<br>                                                                GL_TEXTURE_2D,<br>                                                                GL_RGBA,  <span class="hljs-comment">// 颜色分量数量</span><br>                                                                (GLsizei)frameWidth,<br>                                                                (GLsizei)frameHeight,<br>                                                                GL_BGRA,  <span class="hljs-comment">// 像素数据格式</span><br>                                                                GL_UNSIGNED_BYTE,<br>                                                                <span class="hljs-number">0</span>,<br>                                                                &amp;_texture);<br>    <span class="hljs-keyword">if</span> (!_texture || ret != kCVReturnSuccess) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error: Mapping texture:%d&quot;</span>, ret);<br>    &#125;<br>    CVPixelBufferUnlockBaseAddress(pixelBuffer, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// handle texture</span><br>  <span class="hljs-comment">// 激活纹理单元（一般 GL_TEXTURE0 这个纹理单元默认会被激活，不需要手动调用）</span><br>    glActiveTexture(GL_TEXTURE0);<br>  <span class="hljs-comment">// 将刚生成的纹理到纹理缓冲区</span><br>    glBindTexture(CVOpenGLESTextureGetTarget(_texture), CVOpenGLESTextureGetName(_texture));<br>  <span class="hljs-comment">// 配置纹理参数</span><br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br>  <span class="hljs-comment">// 将纹理单元 0 绑定到片段着色器的 inputImageTexture 纹理采样器</span><br>    glUniform1i(_inputTextureUniform, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// update vertices</span><br>  <span class="hljs-comment">// 通过比对当前帧的宽高和前一帧的宽高，决定是否需要更新顶点坐标</span><br>    [<span class="hljs-keyword">self</span> updateInputImageSize:<span class="hljs-built_in">CGSizeMake</span>(frameWidth, frameHeight)];<br>    <br>    <span class="hljs-comment">// bind vertex buffer and handle vertex shader attribute pointer</span><br>  <span class="hljs-comment">// 绑定顶点缓冲</span><br>    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);<br>  <span class="hljs-comment">// 告知顶点着色器如何解析顶点数据，即先解析两个 float 给 position 属性，再解析两个 float 给inputTextureCoordinate 属性。</span><br>    glVertexAttribPointer(_positionAttribute, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword">sizeof</span>(VerticesCoordinates), (<span class="hljs-type">void</span> *)offsetof(VerticesCoordinates, positionCoordinates));<br>    glVertexAttribPointer(_textureCoordinateAttribute, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword">sizeof</span>(VerticesCoordinates), (<span class="hljs-type">void</span> *)offsetof(VerticesCoordinates, textureCoordinates));<br>    <br>    <span class="hljs-comment">// draw two triangle with 4 vertices</span><br>  <span class="hljs-comment">// 根据给的 4 个顶点绘制两个三角形</span><br>    glDrawArrays(GL_TRIANGLE_STRIP, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>    <br>  <span class="hljs-comment">// 绑定 renderBuffer 并提交给 Core Animation</span><br>    glBindRenderbuffer(GL_RENDERBUFFER, _renderBuffer);<br>    [_context presentRenderbuffer:GL_RENDERBUFFER];<br>    <br>    [_renderLock unlock];<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="适配填充模式">适配填充模式</h2><p>按目前的顶点和纹理坐标，渲染内容默认会铺满整个图层，如果相机回调的 Pixel Buffer 宽高与图层宽高不一致，会产生拉伸的现象，因此需要适配不同的填充模式，我们定义了三种填充模式：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_ENUM</span>(<span class="hljs-built_in">NSUInteger</span>, XPVideoFillMode) &#123;<br>    XPVideoFillModeStretch,   <span class="hljs-comment">// 拉伸以填满屏幕</span><br>    XPVideoFillModeAspectFit, <span class="hljs-comment">// 保持宽高比，长边铺满屏幕，短边填充黑边</span><br>    XPVideoFillModeAspectFill,<span class="hljs-comment">// 保持宽高比，短边铺满屏幕，长边裁剪</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>每种填充模式的顶点坐标计算方式：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)recalculateVerticesCoordinates &#123;<br>  <span class="hljs-comment">// 当前图层尺寸</span><br>    <span class="hljs-built_in">CGSize</span> currentViewSize = _currentBoundsSize;<br>    <span class="hljs-built_in">CGRect</span> currentViewBounds = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, currentViewSize.width, currentViewSize.height);<br>  <span class="hljs-comment">// 计算视频帧以 AspectRatio 方式填充在当前图层时，视频帧的 frame</span><br>    <span class="hljs-built_in">CGRect</span> insetRect = <span class="hljs-built_in">AVMakeRectWithAspectRatioInsideRect</span>(_inputImageSize, currentViewBounds);<br>    <br>    <span class="hljs-built_in">CGFloat</span> heightScaling, widthScaling;<br>    <span class="hljs-keyword">switch</span> (_fillMode) &#123;<br>        <span class="hljs-keyword">case</span> XPVideoFillModeStretch:<br>            widthScaling = <span class="hljs-number">1.0</span>f;<br>            heightScaling = <span class="hljs-number">1.0</span>f;<br>            <span class="hljs-keyword">break</span>;<br>            <br>        <span class="hljs-keyword">case</span> XPVideoFillModeAspectFit:<br>            widthScaling = insetRect.size.width / currentViewSize.width;<br>            heightScaling = insetRect.size.height / currentViewSize.height;<br>            <span class="hljs-keyword">break</span>;<br>            <br>        <span class="hljs-keyword">case</span> XPVideoFillModeAspectFill: &#123;<br>            widthScaling = currentViewSize.height / insetRect.size.height;<br>            heightScaling = currentViewSize.width / insetRect.size.width;<br>        &#125;<br>            <span class="hljs-keyword">break</span>;<br>            <br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 顶点坐标</span><br>    _vertices[<span class="hljs-number">0</span>].positionCoordinates = GLKVector2Make(-widthScaling, -heightScaling);<br>    _vertices[<span class="hljs-number">1</span>].positionCoordinates = GLKVector2Make(widthScaling, -heightScaling);<br>    _vertices[<span class="hljs-number">2</span>].positionCoordinates = GLKVector2Make(-widthScaling, heightScaling);<br>    _vertices[<span class="hljs-number">3</span>].positionCoordinates = GLKVector2Make(widthScaling, heightScaling);<br><br>  <span class="hljs-comment">// 纹理坐标</span><br>    _vertices[<span class="hljs-number">0</span>].textureCoordinates = GLKVector2Make(<span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f);<br>    _vertices[<span class="hljs-number">1</span>].textureCoordinates = GLKVector2Make(<span class="hljs-number">1.0</span>f, <span class="hljs-number">1.0</span>f);<br>    _vertices[<span class="hljs-number">2</span>].textureCoordinates = GLKVector2Make(<span class="hljs-number">0.0</span>f, <span class="hljs-number">0.0</span>f);<br>    _vertices[<span class="hljs-number">3</span>].textureCoordinates = GLKVector2Make(<span class="hljs-number">1.0</span>f, <span class="hljs-number">0.0</span>f);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在渲染过程中，将顶点数据更新同步到 GPU：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">glBufferSubData(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(_vertices), _vertices);<br></code></pre></div></td></tr></table></figure><h1>后记</h1><p>相机画面的自定义渲染没有用到 OpenGL 的高级功能，主要是对 OpenGL 对象、纹理、管线概念的理解，和 Core Animation、Core Video 的交互。下面贴一些文档可以用来参考：</p><blockquote><p>1.OpenGL 中文手册 <a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a></p><p>2.iOS 核心动画高级技巧 <a href="https://zsisme.gitbooks.io/ios-/content/index.html">https://zsisme.gitbooks.io/ios-/content/index.html</a></p><p>3.OpenGLES 苹果官网文档 <a href="https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1">https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1</a></p><p>4.《OpenGL ES应用开发实践 指南 iOS卷》</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVFoundation</tag>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 使用 AVFoundation 采集相机画面</title>
    <link href="/2022/04/07/iOS-%E4%BD%BF%E7%94%A8-AVFoundation-%E9%87%87%E9%9B%86%E7%9B%B8%E6%9C%BA%E7%94%BB%E9%9D%A2/"/>
    <url>/2022/04/07/iOS-%E4%BD%BF%E7%94%A8-AVFoundation-%E9%87%87%E9%9B%86%E7%9B%B8%E6%9C%BA%E7%94%BB%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>需求是从 iOS 内置相机采集视频画面，在手机屏幕上预览并获取视频原始数据，使用的是苹果自带框架 AVFoundation。</p><h1>相机权限获取</h1><h2 id="配置-Info-plist-权限描述">配置 Info.plist 权限描述</h2><p>根据苹果官方文档建议，如果 App 需要使用到系统硬件采集，需要在 <code>Info.plist</code> 文件添加相关权限使用的描述：</p><blockquote><p><strong>Configure Your App’s Info.plist File</strong></p><p>iOS requires that your app provide static messages to display to the user when the system asks for camera or microphone permission:</p><ul><li>If your app uses device cameras, include the <a href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/plist/info/NSCameraUsageDescription">NSCameraUsageDescription</a> key in your app’s Info.plist file.</li><li>If your app uses device microphones, include the <a href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW25">NSMicrophoneUsageDescription</a> key in your app’s Info.plist file.</li></ul><p>For each key, provide a message that explains to the user why your app needs to capture media, so that the user can feel confident granting permission to your app.</p></blockquote><p>如果没有添加权限描述就调用了采集的 API，App 会被异常终止：</p><div class="note note-warning">            <p><strong>Important</strong></p><p>If the appropriate key is not present in your app’s <code>Info.plist</code> file when your app requests authorization or attempts to use a capture device, the system terminates your app.</p>          </div><h2 id="验证和请求设备权限">验证和请求设备权限</h2><p>确保在每次使用设备采集前，先对设备权限状态做验证：</p><blockquote><p>Always test the <a href="https://developer.apple.com/documentation/avfoundation/avcapturedevice?language=objc"><code>AVCaptureDevice</code></a> <a href="https://developer.apple.com/documentation/avfoundation/avcapturedevice/1624613-authorizationstatusformediatype?language=objc"><code>authorizationStatusForMediaType:</code></a> method before setting up a capture session. If the user has not yet granted or denied capture permission, the authorization status is <a href="https://developer.apple.com/documentation/avfoundation/avauthorizationstatus/avauthorizationstatusnotdetermined?language=objc"><code>AVAuthorizationStatusNotDetermined</code></a>. In this case, use the <a href="https://developer.apple.com/documentation/avfoundation/avcapturedevice/1624584-requestaccessformediatype?language=objc"><code>requestAccessForMediaType:completionHandler:</code></a> method to tell iOS to prompt the user:</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">switch</span> <span class="hljs-built_in">AVCaptureDevice</span>.authorizationStatus(<span class="hljs-keyword">for</span>: .video) &#123;<br>    <span class="hljs-keyword">case</span> .authorized: <span class="hljs-comment">// The user has previously granted access to the camera.</span><br>        <span class="hljs-keyword">self</span>.setupCaptureSession()<br>    <br>    <span class="hljs-keyword">case</span> .notDetermined: <span class="hljs-comment">// The user has not yet been asked for camera access.</span><br>        <span class="hljs-built_in">AVCaptureDevice</span>.requestAccess(<span class="hljs-keyword">for</span>: .video) &#123; granted <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">if</span> granted &#123;<br>                <span class="hljs-keyword">self</span>.setupCaptureSession()<br>            &#125;<br>        &#125;<br>    <br>    <span class="hljs-keyword">case</span> .denied: <span class="hljs-comment">// The user has previously denied access.</span><br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">case</span> .restricted: <span class="hljs-comment">// The user can&#x27;t grant access due to restrictions.</span><br>        <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="核心类">核心类</h2><p>首先需要搞清楚几个核心类的关系，参考苹果官网给出的这张图，图中展示的是一个既能拍照也能拍视频的相机会话的创建流程：</p><p><img src="/resources/image/avcapture.png" alt="Setting Up A Capture Session"></p><ul><li><strong>AVCaptureDevice</strong></li></ul><p>设备硬件的抽象类，iPhone 内置的采集设备包括前后置摄像头和麦克风，AVCaptureDevice 提供了这些硬件设备的参数信息和配置方法。</p><ul><li><strong>AVCaptureDeviceInput</strong></li></ul><p>将硬件设备采集到的数据提供给采集会话的媒介，可以想象它是硬件设备的数据接口。</p><ul><li><strong>AVCapturePhotoOutput</strong></li></ul><p>继承自 AVCaptureOutput。AVCaptureOutput 是控制数据输出的抽象父类，其子类有很多，各有各的用处，AVCapturePhotoOutput 一般用于输出照片。</p><ul><li><strong>AVCaptureMovieFileOutput</strong></li></ul><p>同样继承自 AVCaptureOutput，一般用于输出视频。</p><ul><li><strong>AVCaptureVideoPreviewLayer</strong></li></ul><p>继承自 CALayer，一般用于图像预览。</p><ul><li><strong>AVCaptureConnection</strong></li></ul><p>用于连接 Input 和 Output，是采集会话 AVCaptureSession 控制的数据流通管线。</p><ul><li><strong>AVCaptureSession</strong></li></ul><p>采集会话类，控制着输入和输出以及数据流通管线，是整个流程的核心。</p><hr><p>我们来简单分析下苹果的设计，首先将所有硬件设备抽象成 AVCaptureDevice 一个类，提供统一的 API 接口，在 AVCaptureDevice 之上提供了一层 AVCaptureDeviceInput 负责和 AVCaptureSession 交互数据。</p><p>而在数据输出端，苹果提供了几个常用场景的输出子类，方便开发者直接拿到想要的数据而不需要对原始数据做处理，当然如果苹果提供的定制化输出子类不能满足开发需要，可以使用 AVCaptureVideoDataOutput 直接处理回调数据。</p><p>比较重要的是 AVCaptureConnection 这个类，虽然我们平时的需求可能就是拍个照录个视频，不太用的到这个类，但确是相当重要的，它让整个 AVCaptureSession 框架变的灵活。当我们通过 <code>addInput</code> 和 <code>addOutput</code> 给采集会话添加输入输出时，AVCaptureSession 会默认给每一个 Output 和对应 Input 创建 Connection，使得 Input 的数据可以给到 Output，如果是多个 Input 和多个 Output 的复杂场景，可以使用 <code>addInputWithNoConnections</code> 和 <code>addOutputWithNoConnections</code> 在不创建 Connection 的情况下添加输入输出，然后手动创建 AVCaptureConnection 给到 AVCaptureSession，这样可以在多输入输出的情况下保证数据流向，让数据消费者拿到预期设备的数据。</p><p>AVCaptureVideoPreviewLayer 这个类可以把它看成是一个特殊的 AVCaptureOutput，在初始化时同样会创建一个 Connection 连接输入源 Input，它的作用只有一个就是将输入源采集的视频画面渲染在图层上。</p><p>多输入输出的场景可以参考苹果官网同时采集前后置摄像头数据并渲染在两个图层上的 Demo：</p><p><a href="https://developer.apple.com/documentation/avfoundation/cameras_and_media_capture/avmulticampip_capturing_from_multiple_cameras?language=objc">https://developer.apple.com/documentation/avfoundation/cameras_and_media_capture/avmulticampip_capturing_from_multiple_cameras?language=objc</a></p><p>现在来评估下我们的需求，首先这个相机模块是集成到推流 SDK 中的，需要采集内置相机的数据，所以我们需要获取相机的 AVCaptureDevice，并创建对应的输入流 AVCaptureDeviceInput。再看输出端我们期望用采集到的数据做什么，推流 SDK 需要有预览的功能，让主播可以实时看到自己的画面，所以我们需要一个 AVCaptureVideoPreviewLayer。相机采集到的画面我们需要做美颜滤镜等效果，之后还需要实时推送到云服务器做分发，所以我们需要相机的原始数据回调，因此还需要一个 AVCaptureVideoDataOutput。我们目前有一个输入和两个输出，这种情况不需要手动创建 Connection，使用 AVCaptureSession 给我们默认创建的就好，下面我们来实现一下。</p><h1>初始化</h1><h2 id="获取采集设备">获取采集设备</h2><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">+ (<span class="hljs-built_in">AVCaptureDevice</span> *)getCaptureDevice:(<span class="hljs-built_in">AVCaptureDevicePosition</span>)captureDevicePosition &#123;<br>    <span class="hljs-built_in">AVCaptureDevice</span> *captureDevice = <span class="hljs-literal">nil</span>;<br>    <br>    <span class="hljs-comment">// find capture device</span><br>    <span class="hljs-keyword">if</span> (@available(iOS <span class="hljs-number">10.0</span>, *)) &#123;<br>        <span class="hljs-built_in">NSMutableArray</span> *captureDevices = [<span class="hljs-built_in">NSMutableArray</span> array];<br>        <span class="hljs-keyword">if</span> (captureDevicePosition == <span class="hljs-built_in">AVCaptureDevicePositionBack</span>) &#123;<br>            <span class="hljs-built_in">NSMutableArray</span> &lt;<span class="hljs-built_in">AVCaptureDeviceType</span>&gt; *tripleCameras = [<span class="hljs-built_in">NSMutableArray</span> array];<br>            <span class="hljs-built_in">NSMutableArray</span> &lt;<span class="hljs-built_in">AVCaptureDeviceType</span>&gt; *dualCameras = [<span class="hljs-built_in">NSMutableArray</span> array];<br>            <span class="hljs-built_in">NSMutableArray</span> &lt;<span class="hljs-built_in">AVCaptureDeviceType</span>&gt; *singleCameras = [<span class="hljs-built_in">NSMutableArray</span> array];<br><br>            <span class="hljs-keyword">if</span> (@available(iOS <span class="hljs-number">13.0</span>, *)) &#123;<br>                [tripleCameras addObject:<span class="hljs-built_in">AVCaptureDeviceTypeBuiltInTripleCamera</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (@available(iOS <span class="hljs-number">10.2</span>, *)) &#123;<br>                [dualCameras addObject:<span class="hljs-built_in">AVCaptureDeviceTypeBuiltInDualCamera</span>];<br>            &#125;<br>            [singleCameras addObject:<span class="hljs-built_in">AVCaptureDeviceTypeBuiltInWideAngleCamera</span>];<br>            <br>            [captureDevices addObjectsFromArray:tripleCameras];<br>            [captureDevices addObjectsFromArray:dualCameras];<br>            [captureDevices addObjectsFromArray:singleCameras];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            [captureDevices addObject:<span class="hljs-built_in">AVCaptureDeviceTypeBuiltInWideAngleCamera</span>];<br>        &#125;<br>        <span class="hljs-built_in">AVCaptureDeviceDiscoverySession</span> *discoverySession = [<span class="hljs-built_in">AVCaptureDeviceDiscoverySession</span> discoverySessionWithDeviceTypes:captureDevices mediaType:<span class="hljs-built_in">AVMediaTypeVideo</span> position:captureDevicePosition];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">AVCaptureDevice</span> *device <span class="hljs-keyword">in</span> discoverySession.devices) &#123;<br>            <span class="hljs-keyword">if</span> (device.position == captureDevicePosition) &#123;<br>                captureDevice = device;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;device type: %@&quot;</span>, device.deviceType);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">NSArray</span> *devices = [<span class="hljs-built_in">AVCaptureDevice</span> devices];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">AVCaptureDevice</span> *device <span class="hljs-keyword">in</span> devices) &#123;<br>            <span class="hljs-keyword">if</span> ([device hasMediaType:<span class="hljs-built_in">AVMediaTypeVideo</span>] &amp;&amp; device.position == captureDevicePosition) &#123;<br>                captureDevice = device;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> captureDevice;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>iOS 10 之前可以调用 AVCaptureDevice 的 <code>devices</code> 获取设备列表，iOS 10 之后稍微复杂一些，要用 AVCaptureDeviceDiscoverySession 这个类，并且需要传预期获取的设备类型，这里通过系统版本判断给后置增加了三摄、双摄、单摄的选项，前置一般只有单摄。</p><h2 id="创建采集会话">创建采集会话</h2><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">// Setup AVCaptureSession</span><br>_captureSession = [[<span class="hljs-built_in">AVCaptureSession</span> alloc] init];<br><span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.captureSession canSetSessionPreset:<span class="hljs-keyword">self</span>.videoCaptureConfig.sessionPreset]) &#123;<br>    <span class="hljs-keyword">self</span>.captureSession.sessionPreset = <span class="hljs-keyword">self</span>.videoCaptureConfig.sessionPreset;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里创建 AVCaptureSession，设置预设值 <code>sessionPreset</code>，设置前需要校验是否能设置这个值。</p><div class="note note-info">            <p><strong>Tips:</strong></p><p>AVCaptureSession 可以给 Inputs 下的 AVCaptureDevice 设置预设 <code>sessionPreset</code>，AVCaptureDevice 根据预设值调整相应的参数，有些特殊配置需要直接设置 AVCaptureDevice 的 <code>activeFormat</code> ，比如 iPhone 的高帧率采集。如果手动设置了 <code>activeFormat</code>，AVCaptureSession 的 <code>sessionPreset</code> 会被置成 <code>AVCaptureSessionPresetInputPriority</code>，之后再配置 <code>sessionPreset</code> 将无效。</p>          </div><h2 id="创建设备输入">创建设备输入</h2><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">// Setup AVCaptureDeviceInput</span><br>_captureDeviceInput = [[<span class="hljs-built_in">AVCaptureDeviceInput</span> alloc] initWithDevice:captureDevice error:<span class="hljs-literal">nil</span>];<br><span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.captureSession canAddInput:<span class="hljs-keyword">self</span>.captureDeviceInput]) &#123;<br>    [<span class="hljs-keyword">self</span>.captureSession addInput:<span class="hljs-keyword">self</span>.captureDeviceInput];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>用获取到的设备创建设备输入，并加入到采集会话的输入队列。</p><h2 id="创建原始数据输出">创建原始数据输出</h2><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">// Setup AVCaptureOutput</span><br>_captureVideoDataOutput = [[<span class="hljs-built_in">AVCaptureVideoDataOutput</span> alloc] init];<br>[<span class="hljs-keyword">self</span>.captureVideoDataOutput setAlwaysDiscardsLateVideoFrames:<span class="hljs-literal">YES</span>];<br><span class="hljs-keyword">self</span>.captureVideoDataOutput.videoSettings = @&#123;(<span class="hljs-built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_32BGRA)&#125;;<br>[<span class="hljs-keyword">self</span>.captureVideoDataOutput setSampleBufferDelegate:<span class="hljs-keyword">self</span> queue:<span class="hljs-keyword">self</span>.operationQueue];<br><span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.captureSession canAddOutput:<span class="hljs-keyword">self</span>.captureVideoDataOutput]) &#123;<br>    [<span class="hljs-keyword">self</span>.captureSession addOutput:<span class="hljs-keyword">self</span>.captureVideoDataOutput];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>创建原始数据输出，我们的业务场景要保证实时性，所以将延迟丢帧开启，采集的原始数据格式设置为 32BGRA，设置好代理后，将输出加入到采集会话的输出队列。这一步完成后，AVCaptureSession 会自动创建一个 Connection 连接设备输入和原始数据输出。</p><h2 id="获取数据连接">获取数据连接</h2><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">// Get AVCaptureConnection</span><br>_dataOutputConnection = [<span class="hljs-keyword">self</span>.captureVideoDataOutput connectionWithMediaType:<span class="hljs-built_in">AVMediaTypeVideo</span>];<br><span class="hljs-keyword">self</span>.dataOutputConnection.automaticallyAdjustsVideoMirroring = <span class="hljs-literal">NO</span>;<br><span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.dataOutputConnection isVideoOrientationSupported]) &#123;<br>    <span class="hljs-keyword">self</span>.dataOutputConnection.videoOrientation = <span class="hljs-keyword">self</span>.videoCaptureConfig.videoOrientation;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>获取自动创建好的原始数据输出连接管线，设置视频数据是否自动调整镜像以及设置视频数据旋转方向。</p><h2 id="创建预览图层">创建预览图层</h2><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">XPCameraSourcePreviewView</span> ()</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVCaptureVideoPreviewLayer</span> *previewLayer;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">XPCameraSourcePreviewView</span></span><br>- (<span class="hljs-type">void</span>)setupCaptureSession:(<span class="hljs-built_in">AVCaptureSession</span> *)captureSession &#123;<br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.previewLayer) &#123;<br>            [<span class="hljs-keyword">self</span>.previewLayer removeFromSuperlayer];<br>            <span class="hljs-keyword">self</span>.previewLayer = <span class="hljs-literal">nil</span>;<br>        &#125;<br>        <span class="hljs-keyword">self</span>.previewLayer = [[<span class="hljs-built_in">AVCaptureVideoPreviewLayer</span> alloc] initWithSession:captureSession];<br>        <span class="hljs-keyword">self</span>.previewLayer.frame = <span class="hljs-keyword">self</span>.bounds;<br>        <span class="hljs-keyword">self</span>.previewLayer.videoGravity = <span class="hljs-built_in">AVLayerVideoGravityResizeAspectFill</span>;<br>        <span class="hljs-keyword">self</span>.previewLayer.connection.automaticallyAdjustsVideoMirroring = <span class="hljs-literal">NO</span>;<br>        [<span class="hljs-keyword">self</span>.layer addSublayer:<span class="hljs-keyword">self</span>.previewLayer];<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以直接在 View 子类中重写 <code>layerClass</code> 方法指定 AVCaptureVideoPreviewLayer，也可以像上图这样持有一个 AVCaptureVideoPreviewLayer 对象，初始化完成后添加到 layer 上，此时会自动创建一个 AVCaptureVideoPreviewLayer 和相机输入的 Connection。</p><h1>开始采集</h1><p>初始化完成后，可以直接调用 AVCaptureSession 的 <code>startRunning</code> 开始采集。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)startRunning &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;CameraSource: startRunning&quot;</span>);<br>    [<span class="hljs-keyword">self</span>.captureSession startRunning];<br>    _running = <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1>停止采集</h1><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)stopRunning &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;CameraSource: stopRunning&quot;</span>);<br>    [<span class="hljs-keyword">self</span>.captureSession stopRunning];<br>    _running = <span class="hljs-literal">NO</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1>后记</h1><p>写完 webSocket 那篇之后，就开始准备推流 SDK 了，视频采集是第一个要完成的模块，自己也是破天荒的看了苹果官方文档，有了一个大致的了解。后续要做的事情还很多，下一步是要把原生的渲染拿掉，使用 OpenGL，又是一大姿势要去啃，加油吧骚年！</p>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVFoundation</tag>
      
      <tag>采集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SRWebSocket源码分析记录</title>
    <link href="/2022/04/03/SRWebSocket%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/04/03/SRWebSocket%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>今天是 2022 年 4 月 3 日，博客搭建完成后已经大半年没有记录过了，上次是去年 9 月份，接着 10 月初转岗到 SDK 部门，到今年 3 月底离职，刚好半年时间。这半年好像忙的也没有什么时间静下来写写博客，借着疫情居家这段时间，重新搭了下博客页面，打算好好记录一下，学到的技术和日常生活。说到 webSocket，其实背景是七牛的实时音视频 SDK 使用了 SRWebSocket 与服务端交互信令，由于业务需求需要给 SRWebSocket 添加一些功能，比如 DNS 预解析、重连策略、webSocket 各阶段打点，所以就详细读了 SRWebSocket 源码，了解了 webSocket 协议。</p><h1>webSocket 协议简介</h1><p>webSocket 诞生前，如果要在客户端和服务端之间实现双向通信，通常的做法是客户端 HTTP 轮询服务端接口，这样不仅效率低，会消耗大量流量，而且也不能保证服务端消息第一时间传递给客户端，算不上是真正意义的双向通信，而这也是 webSocket 出现的原因。webSocket 协议被设计来取代现有 HTTP 轮询方式实现双向通信，它和 HTTP 的区别在于，webSocket 不再遵循客户端主动发起请求，服务端回复响应的 Request-Response 机制，而是可以在客户端没有发送请求的情况下，服务端也可以主动发送数据给客户端，仅使用一个 TCP 连接就实现真正意义的双向通讯。同时，webSocket 将消息打包成一个个帧序列，与冗长的 HTTP 请求体相比消耗更少的流量。</p><p><img src="/resources/image/websocket-http.webp" alt="http 轮询和 websocket 对比"></p><p>webSocket 和 HTTP 一样属于应用层协议，协议 scheme 是  <code>ws://</code> 和 <code>wss://</code> ，默认端口是 80 和 443，其交互过程包含以下阶段：</p><p>建立 TCP 连接、SSL 握手（如果有）、webSocket 握手、发送数据帧和关闭连接。</p><h2 id="建立-TCP-连接">建立 TCP 连接</h2><p>上面提到 webSocket 只使用了一个 TCP 连接，那首先是要与服务端建立这个 TCP 连接。</p><p><img src="/resources/image/tcp-connect.png" alt="TCP 连接"></p><h2 id="SSL-握手（如果有）">SSL 握手（如果有）</h2><p>如果协议头是 <code>wss://</code>，默认会在建立 TCP 连接后，webSocket 握手前，获取服务端证书并校验，SSL 握手完成后后续请求会使用协商后的加密算法。SRWebSocket 源码支持未授信证书和自签证书的导入验证。</p><p><img src="/resources/image/ssl-handshake" alt="SSL 握手"></p><h2 id="webSocket-握手">webSocket 握手</h2><p>webSocket 握手实际是一个 HTTP Upgrade 请求，使用 HTTP 的原因与 webSocket 默认端口设置为 80 或 443 是一样的，为了确保兼容性，80 和 443 是 HTTP 和 HTTPS 使用的端口，服务器一般都会开放，不至于被防火墙挡掉，而使用 HTTP 也好理解，就是使用一个大家通用的协议去协商一个不太通用的协议，方便协商过程中字段属性的传递，也便于解析协商结果。</p><h3 id="来自客户端的握手请求">来自客户端的握手请求</h3><figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/chat</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>server.example.com<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Sec-WebSocket-Key</span><span class="hljs-punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://example.com<br><span class="hljs-attribute">Sec-WebSocket-Protocol</span><span class="hljs-punctuation">: </span>chat, superchat<br><span class="hljs-attribute">Sec-WebSocket-Version</span><span class="hljs-punctuation">: </span>13<br></code></pre></div></td></tr></table></figure><ul><li><strong>GET /chat HTTP/1.1</strong></li></ul><p>握手使用的 HTTP 版本至少是 1.1，请求方式是 GET，这里的 Path 可能需要解释下，一般客户端传入的 webSocket 地址可能会是 <code>ws://aaa.bbb.ccc/path</code>，实际用来建立 TCP 连接只需要 host 解析出的 IP 和根据协议名选取的默认端口号，<code>/path</code> 一般表示握手服务所在路径。</p><ul><li><strong>Host: <a href="http://server.example.com">server.example.com</a></strong></li></ul><p>握手服务域名。</p><ul><li><strong>Upgrade: websocket</strong></li></ul><p>Upgrade 是 HTTP 协议中用于定义转换协议的 Header 域，它表示如果服务器支持的话，客户端希望从已建立好的连接协议，切换到另外一个应用层协议，这里是希望将协议切换成 webSocket。</p><ul><li><strong>Connection: Upgrade</strong></li></ul><p>需要将 Connection 设置为 Upgrade，指示该请求用于协议升级。</p><ul><li><strong>Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</strong></li></ul><p>Sec-WebSocket-Key 是客户端在请求前生成 16 位随机字符经过 Base64 编码后生成的24位字符，服务端收到后会对该字符串做处理后，通过头部字段 Sec-WebSocket-Accept 返回给客户端。</p><ul><li><strong>Origin: <a href="http://example.com">http://example.com</a></strong></li></ul><p>用于标识原始域名，防止跨域攻击。</p><ul><li><strong>Sec-WebSocket-Protocol: chat, superchat</strong></li></ul><p>客户端支持的子协议列表，服务端需从数组中选择支持的协议并返回，如果都不支持，会导致握手失败。客户端也可不发送子协议，但一旦发送，需两端一致才能成功握手。</p><ul><li><strong>Sec-WebSocket-Version</strong></li></ul><p>客户端支持的协议版本，如果该版本没有匹配服务端理解的任何一个版本，需要握手失败。</p><p><img src="/resources/image/handshake-req.png" alt="handshake 请求"></p><h3 id="来自服务端的握手返回">来自服务端的握手返回</h3><figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Sec-WebSocket-Accept</span><span class="hljs-punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=<br></code></pre></div></td></tr></table></figure><ul><li><strong>HTTP/1.1 101 Switching Protocols</strong></li></ul><p>服务端返回 101 表示收到并同意将协议切换到 webSocket。</p><ul><li><strong>Upgrade: websocket</strong></li></ul><p>与客户端请求头一致。</p><ul><li><strong>Connection: Upgrade</strong></li></ul><p>与客户端请求头一致。</p><ul><li><strong>Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</strong></li></ul><p>服务端在收到客户端的 Sec-WebSocket-Key 之后，将 Sec-WebSocket-Key 拼接协议规定的字符串 <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code> 后，做一次 Sha-1 散列，接着 Base64 编码，得到的字符串作为 Sec-WebSocket-Accept 返回给客户端，而客户端要做的是将之前请求使用的 Sec-WebSocket-Key 按照服务端的流程做字符串处理后，与 Sec-WebSocket-Accept 比对，如果不匹配，需要握手失败。</p><p><img src="/resources/image/handshake-resp.png" alt="handshake 返回"></p><h2 id="数据帧">数据帧</h2><p>协议规定的 webSocket 帧组成部分：</p><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin"> 0                   1                   2                   3<br> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br>+-+-+-+-+-------+-+-------------+-------------------------------+<br>|<span class="hljs-string">F</span>|<span class="hljs-string">R</span>|<span class="hljs-string">R</span>|<span class="hljs-string">R</span>|<span class="hljs-string"> opcode</span>|<span class="hljs-string">M</span>|<span class="hljs-string"> Payload len </span>|<span class="hljs-string">    Extended payload length    </span>|<br>|<span class="hljs-string">I</span>|<span class="hljs-string">S</span>|<span class="hljs-string">S</span>|<span class="hljs-string">S</span>|<span class="hljs-string">  (4)  </span>|<span class="hljs-string">A</span>|<span class="hljs-string">     (7)     </span>|<span class="hljs-string">             (16/64)           </span>|<br>|<span class="hljs-string">N</span>|<span class="hljs-string">V</span>|<span class="hljs-string">V</span>|<span class="hljs-string">V</span>|<span class="hljs-string">       </span>|<span class="hljs-string">S</span>|<span class="hljs-string">             </span>|<span class="hljs-string">   (if payload len==126/127)   </span>|<br>|<span class="hljs-string"> </span>|<span class="hljs-string">1</span>|<span class="hljs-string">2</span>|<span class="hljs-string">3</span>|<span class="hljs-string">       </span>|<span class="hljs-string">K</span>|<span class="hljs-string">             </span>|<span class="hljs-string">                               </span>|<br>+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +<br>|<span class="hljs-string">     Extended payload length continued, if payload len == 127  </span>|<br>+ - - - - - - - - - - - - - - - +-------------------------------+<br>|<span class="hljs-string">                               </span>|<span class="hljs-string">Masking-key, if MASK set to 1  </span>|<br>+-------------------------------+-------------------------------+<br>|<span class="hljs-string"> Masking-key (continued)       </span>|<span class="hljs-string">          Payload Data         </span>|<br>+-------------------------------- - - - - - - - - - - - - - - - +<br>:                     Payload Data continued ...                :<br>+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +<br>|<span class="hljs-string">                     Payload Data continued ...                </span>|<br>+---------------------------------------------------------------+<br></code></pre></div></td></tr></table></figure><p>webSocket 的消息类型大致分为两种：数据类型和控制类型，数据类型的消息由于长度取决于消息内容本身，所以较长的数据消息会采取分帧策略，将一个数据消息拆分成若干个上述格式的数据帧，而控制类型的消息一般内容比较少，单帧就可以负载所有内容，不需要分帧。有些文档上解释成帧和片，为了避免混淆，本篇将指令单元用“消息”表示，发送单元用“帧”表示。下面看下帧内容：</p><ul><li>FIN</li></ul><p>1 bit，用于指使此帧是否是消息的最后片段，如果消息没有分帧，FIN 一定是 1。SRWebSocket 在解析消息的时候会使用 FIN 判断消息的结束。</p><ul><li>RSV1、RSV2、RSV3</li></ul><p>每个 1 bit，必须是 0，除非一个扩展协议将非0值定义含义。如果收到一个非 0 值且没有协商的扩展协议定义这个非 0 值的含义，接收端必须将 webSocket 连接视为失败。</p><ul><li>opcode</li></ul><p>4 bit，定义了该帧负载数据的类型，字段值和消息类型的对应关系如下：</p><figure class="highlight haml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">x0</span></span> 代表一个继续帧<br><span class="hljs-tag">%<span class="hljs-selector-tag">x1</span></span> 代表一个文本帧<br><span class="hljs-tag">%<span class="hljs-selector-tag">x2</span></span> 代表一个二进制帧<br><span class="hljs-tag">%<span class="hljs-selector-tag">x3</span></span>-7 保留用于未来的非控制帧<br><span class="hljs-tag">%<span class="hljs-selector-tag">x8</span></span> 代表连接关闭<br><span class="hljs-tag">%<span class="hljs-selector-tag">x9</span></span> 代表ping<br><span class="hljs-tag">%<span class="hljs-selector-tag">xA</span></span> 代表pong<br><span class="hljs-tag">%<span class="hljs-selector-tag">xB</span></span>-F 保留用于未来的控制帧<br></code></pre></div></td></tr></table></figure><ul><li>MASK</li></ul><p>1 bit，定义了此帧负载数据是否是经过掩码的。如果设置为 1，会有 4 字节的 Masking-key 出现在 Payload 数据前面，如上图。客户端收到 MASK 为 1 的帧，需要解析 Masking-key 并按位对 Payload 做异或运算拿到掩码前的真实数据。另外协议规定从客户端发送到服务器的所有帧需要将 MASK 设置为 1，使用掩码。</p><ul><li>Payload len</li></ul><p>7 bit，定义了负载数据的长度，如果是 0 - 125，表示是真实的负载数据长度。如果是 126，之后的2字节（Extended payload length）是用来表示负载长度的 16 位无符号整数。如果是 127，之后的 8 字节（Extended payload length）是用来表示负载长度的 64 位无符号整数。这里遵循用最小字节数表示负载长度的原则。</p><ul><li>Extended payload length</li></ul><p>16 bit / 64 bit，如上所述，该字段是用在 Payload len 的 7 bit 不足以表示负载长度时，所占字节数依赖 Payload len 的值。</p><ul><li>Masking-key</li></ul><p>32 bit，当 MASK 为 1 时，该字段存在，MASK 为 0 时，该字段缺失。</p><ul><li>Payload Data</li></ul><p>负载数据。</p><h3 id="看个例子">看个例子</h3><p><img src="/resources/image/websocket-wire.png" alt="websocket 抓包"></p><p>这是一条服务端给客户端发送的 webSocket 消息，首先看它的 Opcode 是 1 并且 Fin 是 1，说明这条数据消息没有使用分帧策略。Mask 为 0 说明没有使用掩码，字段里也就没有 Masking key。Payload length 是 126，说明在 Payload length 之后有 2 字节的 Extended Payload Length 用来标识负载的真实长度。Extended Payload Length 标识负载长度是 277，我们用这个长度去解析 Payload。由于这条数据消息只有一个数据帧，因此我们解析完成后可以将消息直接回调给上层。</p><h2 id="关闭连接">关闭连接</h2><p>webSocket 的关闭并不只是简单的一端主动断开 TCP 连接，需要考虑本端和对端缓存里是否有未及时处理的数据，需要区分具体的情况，详细的可以参考官方文档：<a href="https://chenjianlong.gitbooks.io/rfc-6455-websocket-protocol-in-chinese/content/section7/section7.html">关于如何关闭连接</a></p><h1>SRWebSocket 源码分析记录</h1><div class="note note-info">            <p><a href="https://github.com/facebookincubator/SocketRocket">SRWebSocket</a> 是 Facebook 提供的根据 webSocket 协议标准实现的 iOS 平台库，之前七牛 RTC 项目使用的是 0.5.1 版本，比较稳定，本篇也针对这一版本的代码做下基础分析。</p>          </div><h2 id="外层调用">外层调用</h2><p>源码只有一个类 SRWebSocket，头文件里定义了一系列属性、初始化方法和回调，可以按需配置，我们引入这个头文件，使用姿势也很简单：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-comment">// Do any additional setup after loading the view.</span><br>        <br>    <span class="hljs-built_in">NSURLRequest</span> *request = [<span class="hljs-built_in">NSURLRequest</span> requestWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;ws://%@:%@&quot;</span>, server, port]]];<br>    _webSocket = [[SRWebSocket alloc] initWithURLRequest:request];<br>    _webSocket.delegate = <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">IBAction</span>)open:(<span class="hljs-built_in">UIButton</span> *)sender &#123;<br>    [_webSocket open];<br>&#125;<br><br>- (<span class="hljs-keyword">IBAction</span>)close:(<span class="hljs-built_in">UIButton</span> *)sender &#123;<br>    [_webSocket close];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - SRWebSocketDelegate</span><br>- (<span class="hljs-type">void</span>)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(<span class="hljs-type">id</span>)message &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;SRWebSocket didReceiveMessage: %@&quot;</span>, message);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)webSocketDidOpen:(SRWebSocket *)webSocket&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;SRWebSocket webSocketDidOpen&quot;</span>);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)webSocket:(SRWebSocket *)webSocket didFailWithError:(<span class="hljs-built_in">NSError</span> *)error &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;SRWebSocket didFailWithError: %@&quot;</span>, error);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)webSocket:(SRWebSocket *)webSocket didCloseWithCode:(<span class="hljs-built_in">NSInteger</span>)code reason:(<span class="hljs-built_in">NSString</span> *)reason wasClean:(<span class="hljs-type">BOOL</span>)wasClean &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;SRWebSocket didCloseWithCode: %ld  reason: %@&quot;</span>, code, reason);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来我们看下源码内部。</p><h2 id="初始化-v2">初始化</h2><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">id</span>)initWithURLRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request protocols:(<span class="hljs-built_in">NSArray</span> *)protocols allowsUntrustedSSLCertificates:(<span class="hljs-type">BOOL</span>)allowsUntrustedSSLCertificates;<br>&#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        assert(request.URL);<br>        _url = request.URL;<br>        _urlRequest = request;<br>        _allowsUntrustedSSLCertificates = allowsUntrustedSSLCertificates;<br>        <br>        _requestedProtocols = [protocols <span class="hljs-keyword">copy</span>];<br>        <br>        [<span class="hljs-keyword">self</span> _SR_commonInit];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Init 方法初始化一些属性变量，url 保存 webSocket 地址，requestedProtocols 保存客户端定义的子协议，allowsUntrustedSSLCertificates 标识是否允许未授信的证书，如果设置为 YES，会在连接中忽略证书链的校验。接下来调用了 SR_commonInit 方法做进一步初始化。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_SR_commonInit;<br>&#123;<br>  <span class="hljs-comment">// 如果协议不是 ws、http、wss、https，assert</span><br>    <span class="hljs-built_in">NSString</span> *scheme = _url.scheme.lowercaseString;<br>    assert([scheme isEqualToString:<span class="hljs-string">@&quot;ws&quot;</span>] || [scheme isEqualToString:<span class="hljs-string">@&quot;http&quot;</span>] || [scheme isEqualToString:<span class="hljs-string">@&quot;wss&quot;</span>] || [scheme isEqualToString:<span class="hljs-string">@&quot;https&quot;</span>]);<br>    <br>  <span class="hljs-comment">// 判断是否是安全连接</span><br>    <span class="hljs-keyword">if</span> ([scheme isEqualToString:<span class="hljs-string">@&quot;wss&quot;</span>] || [scheme isEqualToString:<span class="hljs-string">@&quot;https&quot;</span>]) &#123;<br>        _secure = <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 更新状态 - 连接中</span><br>    _readyState = SR_CONNECTING;<br>  <br>  <span class="hljs-comment">// 消费者是否都已停止   该字段未使用</span><br>    _consumerStopped = <span class="hljs-literal">YES</span>;<br>  <br>  <span class="hljs-comment">// 标识客户端使用的 webSocket 版本</span><br>    _webSocketVersion = <span class="hljs-number">13</span>;<br>    <br>  <span class="hljs-comment">// 初始化读写控制队列  串行</span><br>    _workQueue = dispatch_queue_create(<span class="hljs-literal">NULL</span>, DISPATCH_QUEUE_SERIAL);<br>    <br>    <span class="hljs-comment">// Going to set a specific on the queue so we can validate we&#x27;re on the work queue</span><br>    dispatch_queue_set_specific(_workQueue, (__bridge <span class="hljs-type">void</span> *)<span class="hljs-keyword">self</span>, maybe_bridge(_workQueue), <span class="hljs-literal">NULL</span>);<br>    <br>  <span class="hljs-comment">// 获取回调队列  主线程</span><br>    _delegateDispatchQueue = dispatch_get_main_queue();<br>    sr_dispatch_retain(_delegateDispatchQueue);<br>    <br>  <span class="hljs-comment">// 初始化读写缓存</span><br>    _readBuffer = [[<span class="hljs-built_in">NSMutableData</span> alloc] init];<br>    _outputBuffer = [[<span class="hljs-built_in">NSMutableData</span> alloc] init];<br>    <br>  <span class="hljs-comment">// 初始化当前 opcode 下的 payload 缓存  一般只存放文本帧和二进制帧的 payload  拼接成完整消息后回调出去</span><br>    _currentFrameData = [[<span class="hljs-built_in">NSMutableData</span> alloc] init];<br><br>  <span class="hljs-comment">// 初始化消费者工作队列</span><br>    _consumers = [[<span class="hljs-built_in">NSMutableArray</span> alloc] init];<br>    <br>  <span class="hljs-comment">// 初始化消费者缓存池</span><br>    _consumerPool = [[SRIOConsumerPool alloc] init];<br>    <br>  <span class="hljs-comment">// 初始化 runloop 缓存池</span><br>    _scheduledRunloops = [[<span class="hljs-built_in">NSMutableSet</span> alloc] init];<br>    <br>    [<span class="hljs-keyword">self</span> _initializeStreams];<br>    <br>    <span class="hljs-comment">// default handlers</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>SR_commonInit 方法里首先是校验了 Url 的协议是否是预期，判断是否是安全连接，初始化一些队列和线程，接着调用 initializeStreams 初始化输入输出的 stream。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_initializeStreams;<br>&#123;<br>  <span class="hljs-comment">// 判断端口号是否超过 32 位 unsigned int 大小</span><br>    assert(_url.port.unsignedIntValue &lt;= <span class="hljs-built_in">UINT32_MAX</span>);<br>    uint32_t port = _url.port.unsignedIntValue;<br>  <br>  <span class="hljs-comment">// 如果端口没传，通过之前判断的 _secure 字段设置端口 80 或 443</span><br>    <span class="hljs-keyword">if</span> (port == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!_secure) &#123;<br>            port = <span class="hljs-number">80</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            port = <span class="hljs-number">443</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">NSString</span> *host = _url.host;<br>    <br>    <span class="hljs-built_in">CFReadStreamRef</span> readStream = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">CFWriteStreamRef</span> writeStream = <span class="hljs-literal">NULL</span>;<br>    <br>  <span class="hljs-comment">// 通过 host 和 port 创建输入输出流</span><br>    <span class="hljs-built_in">CFStreamCreatePairWithSocketToHost</span>(<span class="hljs-literal">NULL</span>, (__bridge <span class="hljs-built_in">CFStringRef</span>)host, port, &amp;readStream, &amp;writeStream);<br>    <br>  <span class="hljs-comment">// 将 CFReadStreamRef、CFWriteStreamRef 转成 oc 的 NSInputStream 和 NSOutputStream，释放所有权</span><br>    _outputStream = <span class="hljs-built_in">CFBridgingRelease</span>(writeStream);<br>    _inputStream = <span class="hljs-built_in">CFBridgingRelease</span>(readStream);<br>    <br>  <span class="hljs-comment">// 设置输入输出流的代理</span><br>    _inputStream.delegate = <span class="hljs-keyword">self</span>;<br>    _outputStream.delegate = <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>initializeStreams 方法先是做了端口号校验，如果 Url 没传端口号，那么默认使用 80 或 443 端口，接着通过域名和端口号创建输入输出流，将 CoreFoundation 指针转成 OC 的对象，设置代理，输入输出流的事件会回调 handleEvent 方法。</p><h2 id="建立-TCP-连接、SSL-握手（如果有）">建立 TCP 连接、SSL 握手（如果有）</h2><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)open;<br>&#123;<br>    assert(_url);<br>  <br>  <span class="hljs-comment">// 防止在 connecting 状态下多次 open</span><br>    <span class="hljs-built_in">NSAssert</span>(_readyState == SR_CONNECTING, <span class="hljs-string">@&quot;Cannot call -(void)open on SRWebSocket more than once&quot;</span>);<br><br>  <span class="hljs-comment">// retain self 防止被释放造成野指针异常</span><br>    _selfRetain = <span class="hljs-keyword">self</span>;<br><br>  <span class="hljs-comment">// 如果 _urlRequest 设置了超时时间，sr 内部是用 GCD 的 after 去计算超时时间，如果超过了 _urlRequest.timeoutInterval 之后 self.readyState 依然是 未连接成功 就会主动断开</span><br>    <span class="hljs-keyword">if</span> (_urlRequest.timeoutInterval &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, _urlRequest.timeoutInterval * <span class="hljs-built_in">NSEC_PER_SEC</span>);<br>        dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="hljs-type">void</span>)&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.readyState == SR_CONNECTING)<br>                [<span class="hljs-keyword">self</span> _failWithError:[<span class="hljs-built_in">NSError</span> errorWithDomain:<span class="hljs-string">@&quot;com.squareup.SocketRocket&quot;</span> code:<span class="hljs-number">504</span> userInfo:@&#123;<span class="hljs-built_in">NSLocalizedDescriptionKey</span>: <span class="hljs-string">@&quot;Timeout Connecting to Server&quot;</span>&#125;]];<br>        &#125;);<br>    &#125;<br><br>    [<span class="hljs-keyword">self</span> openConnection];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的初始化方法完成后，外层就可以主动调用 open 打开连接了。可以看到 open 方法里使用 GCD 对超时时间做控制，如果需要定义超时时间，需要在初始化时的 NSURLRequest 对象里设置 timeoutInterval。open 方法最后调用 openConnection 去打开连接。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)openConnection;<br>&#123;<br>  <span class="hljs-comment">// 给输入输出流配置安全设置和网络类型</span><br>    [<span class="hljs-keyword">self</span> _updateSecureStreamOptions];<br>    <br>  <span class="hljs-comment">// 给输入输出流绑定 runloop</span><br>    <span class="hljs-keyword">if</span> (!_scheduledRunloops.count) &#123;<br>        [<span class="hljs-keyword">self</span> scheduleInRunLoop:[<span class="hljs-built_in">NSRunLoop</span> SR_networkRunLoop] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 打开输入输出流   这里会与服务端做 tcp 连接  完成会回调 handleEvent 方法 NSStreamEventOpenCompleted 事件</span><br>    [_outputStream open];<br>    [_inputStream open];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>openConnection 方法先是调用 updateSecureStreamOptions 给输入输出流配置 SSL 和选取网络服务类型，接着给输入输出流绑定一个全局 runloop，最后打开输入输出流，与服务端建立 TCP 连接。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_updateSecureStreamOptions;<br>&#123;<br>  <span class="hljs-comment">// 如果 scheme 是 wss:// 需要给输出流配置 kCFStreamPropertySSLSettings</span><br>    <span class="hljs-keyword">if</span> (_secure) &#123;<br>        <span class="hljs-built_in">NSMutableDictionary</span> *SSLOptions = [[<span class="hljs-built_in">NSMutableDictionary</span> alloc] init];<br>        <br>      <span class="hljs-comment">// 设置 ssl 安全级别</span><br>     <span class="hljs-comment">//  Indicates to use TLS or SSL with fallback to lower versions. This is what HTTPS does, for instance. </span><br>        [_outputStream setProperty:(__bridge <span class="hljs-type">id</span>)kCFStreamSocketSecurityLevelNegotiatedSSL forKey:(__bridge <span class="hljs-type">id</span>)kCFStreamPropertySocketSecurityLevel];<br>        <br>      <span class="hljs-comment">// 如果是自签证书 不验证证书链</span><br>        <span class="hljs-comment">// If we&#x27;re using pinned certs, don&#x27;t validate the certificate chain</span><br>        <span class="hljs-keyword">if</span> ([_urlRequest SR_SSLPinnedCertificates].count) &#123;<br>            [SSLOptions setValue:@NO forKey:(__bridge <span class="hljs-type">id</span>)kCFStreamSSLValidatesCertificateChain];<br>        &#125;<br>        <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>        <span class="hljs-keyword">self</span>.allowsUntrustedSSLCertificates = <span class="hljs-literal">YES</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>      <span class="hljs-comment">// 如果设置允许使用未授信的证书 不验证证书链</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.allowsUntrustedSSLCertificates) &#123;<br>            [SSLOptions setValue:@NO forKey:(__bridge <span class="hljs-type">id</span>)kCFStreamSSLValidatesCertificateChain];<br>            SRFastLog(<span class="hljs-string">@&quot;Allowing connection to any root cert&quot;</span>);<br>        &#125;<br>        <br>        [_outputStream setProperty:SSLOptions<br>                            forKey:(__bridge <span class="hljs-type">id</span>)kCFStreamPropertySSLSettings];<br>    &#125;<br>    <br>    _inputStream.delegate = <span class="hljs-keyword">self</span>;<br>    _outputStream.delegate = <span class="hljs-keyword">self</span>;<br>    <br>  <span class="hljs-comment">// 输入输出流设置网络服务类型</span><br>    [<span class="hljs-keyword">self</span> setupNetworkServiceType:_urlRequest.networkServiceType];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>updateSecureStreamOptions 主要是针对 SSL 的一些处理，如果 Url 的 scheme 是  <code>wss://</code> ，需要给输出流做 SSL 的相关配置，如果在初始化时传了自签证书或者设置了允许未授信证书，将不验证证书链，方法最后调用 setupNetworkServiceType 设置输入输出流的网络类型。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)scheduleInRunLoop:(<span class="hljs-built_in">NSRunLoop</span> *)aRunLoop forMode:(<span class="hljs-built_in">NSString</span> *)mode;<br>&#123;<br>    [_outputStream scheduleInRunLoop:aRunLoop forMode:mode];<br>    [_inputStream scheduleInRunLoop:aRunLoop forMode:mode];<br>    <br>    [_scheduledRunloops addobjc:@[aRunLoop, mode]];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>scheduleInRunLoop 方法给输入输出流设置了 runloop 和 runloop mode，最后将 runloop 和 runloop mode 加入到缓存队列，我们看下这个 runloop 是哪里来的：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> _SRRunLoopThread *networkThread = <span class="hljs-literal">nil</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSRunLoop</span> *networkRunLoop = <span class="hljs-literal">nil</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSRunLoop</span> (<span class="hljs-title">SRWebSocket</span>)</span><br><br>+ (<span class="hljs-built_in">NSRunLoop</span> *)SR_networkRunLoop &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        networkThread = [[_SRRunLoopThread alloc] init];<br>        networkThread.name = <span class="hljs-string">@&quot;com.squareup.SocketRocket.NetworkThread&quot;</span>;<br>        [networkThread start];<br>        networkRunLoop = networkThread.runLoop;<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> networkRunLoop;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个 NSRunLoop 的分类里定义了一个 networkThread 单例的初始化方法，单例携带一个 networkRunLoop，所以拿到的是一个常驻线程的 runloop，用于处理输入输出流的回调。</p><p>到此，SRWebSocket 源码使用的三个线程队列都已初始化完成，他们分别是：</p><ul><li><strong>networkThread</strong>：用于处理输入输出流并回调</li><li><strong>workQueue</strong>：SR 的主要工作队列，用于处理连接、输入输出流的读取等操作</li><li><strong>delegateOperationQueue</strong>：用于处理上层的回调</li></ul><p>输入输出流打开后，会与服务端尝试 TCP 连接并进行 SSL 握手，完成后会回调 handleEvent 方法：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)stream:(<span class="hljs-built_in">NSStream</span> *)aStream handleEvent:(<span class="hljs-built_in">NSStreamEvent</span>)eventCode;<br>&#123;<br>    __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br>    <br>  <span class="hljs-comment">// 这里处理自签证书的验证</span><br>    <span class="hljs-keyword">if</span> (_secure &amp;&amp; !_pinnedCertFound &amp;&amp; (eventCode == <span class="hljs-built_in">NSStreamEventHasBytesAvailable</span> || eventCode == <span class="hljs-built_in">NSStreamEventHasSpaceAvailable</span>)) &#123;<br>        <br>        <span class="hljs-built_in">NSArray</span> *sslCerts = [_urlRequest SR_SSLPinnedCertificates];<br>        <span class="hljs-keyword">if</span> (sslCerts) &#123;<br>            SecTrustRef secTrust = (__bridge SecTrustRef)[aStream propertyForKey:(__bridge <span class="hljs-type">id</span>)kCFStreamPropertySSLPeerTrust];<br>            <span class="hljs-keyword">if</span> (secTrust) &#123;<br>                <span class="hljs-built_in">NSInteger</span> numCerts = SecTrustGetCertificateCount(secTrust);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; numCerts &amp;&amp; !_pinnedCertFound; i++) &#123;<br>                    SecCertificateRef cert = SecTrustGetCertificateAtIndex(secTrust, i);<br>                    <span class="hljs-built_in">NSData</span> *certData = <span class="hljs-built_in">CFBridgingRelease</span>(SecCertificateCopyData(cert));<br>                    <br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">id</span> ref <span class="hljs-keyword">in</span> sslCerts) &#123;<br>                        SecCertificateRef trustedCert = (__bridge SecCertificateRef)ref;<br>                        <span class="hljs-built_in">NSData</span> *trustedCertData = <span class="hljs-built_in">CFBridgingRelease</span>(SecCertificateCopyData(trustedCert));<br>                        <br>                        <span class="hljs-keyword">if</span> ([trustedCertData isEqualToData:certData]) &#123;<br>                          <span class="hljs-comment">// 如果服务端证书与本地自签证书匹配</span><br>                            _pinnedCertFound = <span class="hljs-literal">YES</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <br>          <span class="hljs-comment">// 如果没有发现匹配的证书，需要将错误回调上层</span><br>            <span class="hljs-keyword">if</span> (!_pinnedCertFound) &#123;<br>                <span class="hljs-built_in">dispatch_async</span>(_workQueue, ^&#123;<br>                    <span class="hljs-built_in">NSDictionary</span> *userInfo = @&#123; <span class="hljs-built_in">NSLocalizedDescriptionKey</span> : <span class="hljs-string">@&quot;Invalid server cert&quot;</span> &#125;;<br>                    [weakSelf _failWithError:[<span class="hljs-built_in">NSError</span> errorWithDomain:<span class="hljs-string">@&quot;org.lolrus.SocketRocket&quot;</span> code:<span class="hljs-number">23556</span> userInfo:userInfo]];<br>                &#125;);<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aStream == _outputStream) &#123;<br>                <span class="hljs-built_in">dispatch_async</span>(_workQueue, ^&#123;<br>                   <span class="hljs-comment">// 继续走握手流程</span><br>                    [<span class="hljs-keyword">self</span> didConnect];<br>                &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>  <span class="hljs-comment">// 处理 event</span><br>    <span class="hljs-built_in">dispatch_async</span>(_workQueue, ^&#123;<br>        [weakSelf safeHandleEvent:eventCode stream:aStream];<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)safeHandleEvent:(<span class="hljs-built_in">NSStreamEvent</span>)eventCode stream:(<span class="hljs-built_in">NSStream</span> *)aStream<br>&#123;<br>        <span class="hljs-keyword">switch</span> (eventCode) &#123;<br>            <span class="hljs-comment">// 连接成功</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-built_in">NSStreamEventOpenCompleted</span>: &#123;<br>                SRFastLog(<span class="hljs-string">@&quot;NSStreamEventOpenCompleted %@&quot;</span>, aStream);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.readyState &gt;= SR_CLOSING) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                assert(_readBuffer);<br>                <br>              <span class="hljs-comment">// 除自签证书外的其他情况  会走到这里的 didConnect 方法进行握手</span><br>                <span class="hljs-comment">// didConnect fires after certificate verification if we&#x27;re using pinned certificates.</span><br>                <span class="hljs-type">BOOL</span> usingPinnedCerts = [[_urlRequest SR_SSLPinnedCertificates] count] &gt; <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> ((!_secure || !usingPinnedCerts) &amp;&amp; <span class="hljs-keyword">self</span>.readyState == SR_CONNECTING &amp;&amp; aStream == _inputStream) &#123;<br>                    [<span class="hljs-keyword">self</span> didConnect];<br>                &#125;<br>...<br></code></pre></div></td></tr></table></figure><p>handleEvent 方法里的代码是对自签证书的验证，在两端 TCP 连接完成后，将服务端证书与传入的自签证书一一比对，如果发现匹配就继续下一步的握手操作，如果没有匹配，则验证失败回调上层。实际 event 事件的处理是在 safeHandleEvent 里，在监听到 NSStreamEventOpenCompleted 事件后，除自签证书这种情况外，都会走到这里的握手方法。</p><h2 id="webSocket握手">webSocket握手</h2><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)didConnect;<br>&#123;<br>    SRFastLog(<span class="hljs-string">@&quot;Connected&quot;</span>);<br>  <span class="hljs-comment">// 创建 HTTP 的 GET 请求，版本 HTTP 1.1</span><br>    <span class="hljs-built_in">CFHTTPMessageRef</span> request = <span class="hljs-built_in">CFHTTPMessageCreateRequest</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;GET&quot;</span>), (__bridge <span class="hljs-built_in">CFURLRef</span>)_url, kCFHTTPVersion1_1);<br>    <br>    <span class="hljs-comment">// Set host first so it defaults</span><br>    <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Host&quot;</span>), (__bridge <span class="hljs-built_in">CFStringRef</span>)(_url.port ? [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@:%@&quot;</span>, _url.host, _url.port] : _url.host));<br>        <br>  <span class="hljs-comment">// 初始化 16 位随机字符</span><br>    <span class="hljs-built_in">NSMutableData</span> *keyBytes = [[<span class="hljs-built_in">NSMutableData</span> alloc] initWithLength:<span class="hljs-number">16</span>];<br>    SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes);<br>    <br>  <span class="hljs-comment">// Base64 编码   生成的 _secKey 用于请求头中的 Sec-WebSocket-Key</span><br>    <span class="hljs-keyword">if</span> ([keyBytes respondsToSelector:<span class="hljs-keyword">@selector</span>(base64EncodedStringWithOptions:)]) &#123;<br>        _secKey = [keyBytes base64EncodedStringWithOptions:<span class="hljs-number">0</span>];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic push</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic ignored <span class="hljs-string">&quot;-Wdeprecated-declarations&quot;</span></span><br>        _secKey = [keyBytes base64Encoding];<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic pop</span><br>    &#125;<br>    <br>  <span class="hljs-comment">// 校验编码后是否为 24 位</span><br>    assert([_secKey length] == <span class="hljs-number">24</span>);<br><br>    <span class="hljs-comment">// Apply cookies if any have been provided</span><br>    <span class="hljs-built_in">NSDictionary</span> * cookies = [<span class="hljs-built_in">NSHTTPCookie</span> requestHeaderFieldsWithCookies:[<span class="hljs-keyword">self</span> requestCookies]];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSString</span> * cookieKey <span class="hljs-keyword">in</span> cookies) &#123;<br>        <span class="hljs-built_in">NSString</span> * cookieValue = [cookies objcForKey:cookieKey];<br>        <span class="hljs-keyword">if</span> ([cookieKey length] &amp;&amp; [cookieValue length]) &#123;<br>            <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, (__bridge <span class="hljs-built_in">CFStringRef</span>)cookieKey, (__bridge <span class="hljs-built_in">CFStringRef</span>)cookieValue);<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">// set header for http basic auth</span><br>    <span class="hljs-keyword">if</span> (_url.user.length &amp;&amp; _url.password.length) &#123;<br>        <span class="hljs-built_in">NSData</span> *userAndPassword = [[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@:%@&quot;</span>, _url.user, _url.password] dataUsingEncoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>        <span class="hljs-built_in">NSString</span> *userAndPasswordBase64Encoded;<br>        <span class="hljs-keyword">if</span> ([keyBytes respondsToSelector:<span class="hljs-keyword">@selector</span>(base64EncodedStringWithOptions:)]) &#123;<br>            userAndPasswordBase64Encoded = [userAndPassword base64EncodedStringWithOptions:<span class="hljs-number">0</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic push</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic ignored <span class="hljs-string">&quot;-Wdeprecated-declarations&quot;</span></span><br>            userAndPasswordBase64Encoded = [userAndPassword base64Encoding];<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic pop</span><br>        &#125;<br>        _basicAuthorizationString = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Basic %@&quot;</span>, userAndPasswordBase64Encoded];<br>        <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Authorization&quot;</span>), (__bridge <span class="hljs-built_in">CFStringRef</span>)_basicAuthorizationString);<br>    &#125;<br><br>  <span class="hljs-comment">// 这里设置的是 webSocket 握手请求的头部信息</span><br>    <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Upgrade&quot;</span>), <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;websocket&quot;</span>));<br>    <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Connection&quot;</span>), <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Upgrade&quot;</span>));<br>    <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Sec-WebSocket-Key&quot;</span>), (__bridge <span class="hljs-built_in">CFStringRef</span>)_secKey);<br>    <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Sec-WebSocket-Version&quot;</span>), (__bridge <span class="hljs-built_in">CFStringRef</span>)[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%ld&quot;</span>, (<span class="hljs-type">long</span>)_webSocketVersion]);<br>    <br>    <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Origin&quot;</span>), (__bridge <span class="hljs-built_in">CFStringRef</span>)_url.SR_origin);<br>    <br>    <span class="hljs-keyword">if</span> (_requestedProtocols) &#123;<br>        <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Sec-WebSocket-Protocol&quot;</span>), (__bridge <span class="hljs-built_in">CFStringRef</span>)[_requestedProtocols componentsJoinedByString:<span class="hljs-string">@&quot;, &quot;</span>]);<br>    &#125;<br><br>    [_urlRequest.allHTTPHeaderFields enumerateKeysAndobjcsUsingBlock:^(<span class="hljs-type">id</span> key, <span class="hljs-type">id</span> obj, <span class="hljs-type">BOOL</span> *stop) &#123;<br>        <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, (__bridge <span class="hljs-built_in">CFStringRef</span>)key, (__bridge <span class="hljs-built_in">CFStringRef</span>)obj);<br>    &#125;];<br>    <br>  <span class="hljs-comment">// 将 HTTP 请求报文转成 OC 的 NSData 对象</span><br>    <span class="hljs-built_in">NSData</span> *message = <span class="hljs-built_in">CFBridgingRelease</span>(<span class="hljs-built_in">CFHTTPMessageCopySerializedMessage</span>(request));<br>    <br>    <span class="hljs-built_in">CFRelease</span>(request);<br><br>  <span class="hljs-comment">// 将 HTTP 请求报文写入到输出缓存</span><br>    [<span class="hljs-keyword">self</span> _writeData:message];<br>  <br>  <span class="hljs-comment">// 读取 HTTP 返回头部信息</span><br>    [<span class="hljs-keyword">self</span> _readHTTPHeader];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>didConnect 方法创建一个 HTTP 请求的 MessageRef，按照之前介绍过的 webSocket 握手标准，设置请求的头部信息，Sec-WebSocket-Key 是先生成 16 位随机字符再 Base64 编码成 24 位字符，将外部传入的子协议写入 Sec-WebSocket-Protocol 字符。方法的最后获取到 HTTP 请求报文的 NSData 对象，调用 writeData 将数据写入到输出缓冲区，等待输出流有空间可写时，将数据发送给服务端。最后调用 readHTTPHeader 创建 HTTP header 的消费者尝试从输入缓冲区中读取返回头信息。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_readHTTPHeader;<br>&#123;<br>    <span class="hljs-keyword">if</span> (_receivedHTTPHeaders == <span class="hljs-literal">NULL</span>) &#123;<br>        _receivedHTTPHeaders = <span class="hljs-built_in">CFHTTPMessageCreateEmpty</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NO</span>);<br>    &#125;<br>                        <br>  <span class="hljs-comment">// 尝试读取 HTTP Response Header</span><br>    [<span class="hljs-keyword">self</span> _readUntilHeaderCompleteWithCallback:^(SRWebSocket *<span class="hljs-keyword">self</span>,  <span class="hljs-built_in">NSData</span> *data) &#123;<br>        <span class="hljs-built_in">CFHTTPMessageAppendBytes</span>(_receivedHTTPHeaders, (<span class="hljs-keyword">const</span> <span class="hljs-built_in">UInt8</span> *)data.bytes, data.length);<br>        <span class="hljs-comment">// 判断 Header 是否有效</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CFHTTPMessageIsHeaderComplete</span>(_receivedHTTPHeaders)) &#123;<br>            SRFastLog(<span class="hljs-string">@&quot;Finished reading headers %@&quot;</span>, <span class="hljs-built_in">CFBridgingRelease</span>(<span class="hljs-built_in">CFHTTPMessageCopyAllHeaderFields</span>(_receivedHTTPHeaders)));<br>          <span class="hljs-comment">// 继续 Header 校验</span><br>            [<span class="hljs-keyword">self</span> _HTTPHeadersDidFinish];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 重复读取</span><br>            [<span class="hljs-keyword">self</span> _readHTTPHeader];<br>        &#125;<br>    &#125;];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>readHTTPHeader 方法中调用 readUntilHeaderCompleteWithCallback ，其方法内部实际是创建一个消费者去缓存中读取匹配 Header 特征字符的数据段，读到数据后回调 Block。回调函数中对 Header 是否有效做了校验，如果无效，重复读取 Header，有效则继续后续的 Header 校验。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_HTTPHeadersDidFinish;<br>&#123;<br>  <span class="hljs-comment">// 获取 HTTP Code</span><br>    <span class="hljs-built_in">NSInteger</span> responseCode = <span class="hljs-built_in">CFHTTPMessageGetResponseStatusCode</span>(_receivedHTTPHeaders);<br>    <br>  <span class="hljs-comment">// 校验 Code</span><br>    <span class="hljs-keyword">if</span> (responseCode &gt;= <span class="hljs-number">400</span>) &#123;<br>        SRFastLog(<span class="hljs-string">@&quot;Request failed with response code %d&quot;</span>, responseCode);<br>        [<span class="hljs-keyword">self</span> _failWithError:[<span class="hljs-built_in">NSError</span> errorWithDomain:SRWebSocketErrorDomain code:<span class="hljs-number">2132</span> userInfo:@&#123;<span class="hljs-built_in">NSLocalizedDescriptionKey</span>:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;received bad response code from server %ld&quot;</span>, (<span class="hljs-type">long</span>)responseCode], SRHTTPResponseErrorKey:@(responseCode)&#125;]];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 校验 Sec-WebSocket-Accept</span><br>    <span class="hljs-keyword">if</span>(![<span class="hljs-keyword">self</span> _checkHandshake:_receivedHTTPHeaders]) &#123;<br>        [<span class="hljs-keyword">self</span> _failWithError:[<span class="hljs-built_in">NSError</span> errorWithDomain:SRWebSocketErrorDomain code:<span class="hljs-number">2133</span> userInfo:[<span class="hljs-built_in">NSDictionary</span> dictionaryWithobjc:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Invalid Sec-WebSocket-Accept response&quot;</span>] forKey:<span class="hljs-built_in">NSLocalizedDescriptionKey</span>]]];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 校验 Sec-WebSocket-Protocol</span><br>    <span class="hljs-built_in">NSString</span> *negotiatedProtocol = <span class="hljs-built_in">CFBridgingRelease</span>(<span class="hljs-built_in">CFHTTPMessageCopyHeaderFieldValue</span>(_receivedHTTPHeaders, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Sec-WebSocket-Protocol&quot;</span>)));<br>    <span class="hljs-keyword">if</span> (negotiatedProtocol) &#123;<br>        <span class="hljs-comment">// Make sure we requested the protocol</span><br>        <span class="hljs-keyword">if</span> ([_requestedProtocols indexOfobjc:negotiatedProtocol] == <span class="hljs-built_in">NSNotFound</span>) &#123;<br>            [<span class="hljs-keyword">self</span> _failWithError:[<span class="hljs-built_in">NSError</span> errorWithDomain:SRWebSocketErrorDomain code:<span class="hljs-number">2133</span> userInfo:[<span class="hljs-built_in">NSDictionary</span> dictionaryWithobjc:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Server specified Sec-WebSocket-Protocol that wasn&#x27;t requested&quot;</span>] forKey:<span class="hljs-built_in">NSLocalizedDescriptionKey</span>]]];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        _protocol = negotiatedProtocol;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 更新状态 - 已连接</span><br>    <span class="hljs-keyword">self</span>.readyState = SR_OPEN;<br>    <br>  <span class="hljs-comment">// 这个标志位没有用到，所以一定会走 readFrameNew，尝试读取 webSocket 数据帧</span><br>    <span class="hljs-keyword">if</span> (!_didFail) &#123;<br>        [<span class="hljs-keyword">self</span> _readFrameNew];<br>    &#125;<br><br>  <span class="hljs-comment">// 将已连接状态回调给上层</span><br>    [<span class="hljs-keyword">self</span> _performDelegateBlock:^&#123;<br>        <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(webSocketDidOpen:)]) &#123;<br>            [<span class="hljs-keyword">self</span>.delegate webSocketDidOpen:<span class="hljs-keyword">self</span>];<br>        &#125;;<br>    &#125;];<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">BOOL</span>)_checkHandshake:(<span class="hljs-built_in">CFHTTPMessageRef</span>)httpMessage;<br>&#123;<br>  <span class="hljs-comment">// 拿到服务端返回的 Sec-WebSocket-Accept</span><br>    <span class="hljs-built_in">NSString</span> *acceptHeader = <span class="hljs-built_in">CFBridgingRelease</span>(<span class="hljs-built_in">CFHTTPMessageCopyHeaderFieldValue</span>(httpMessage, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Sec-WebSocket-Accept&quot;</span>)));<br><br>    <span class="hljs-keyword">if</span> (acceptHeader == <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 将本地的 _secKey 拼接协议规定的字符串</span><br>    <span class="hljs-built_in">NSString</span> *concattedString = [_secKey stringByAppendingString:SRWebSocketAppendToSecKeyString];<br>  <span class="hljs-comment">// 先做 Sha-1 散列，后 Base64 编码</span><br>    <span class="hljs-built_in">NSString</span> *expectedAccept = [concattedString stringBySHA1ThenBase64Encoding];<br>    <br>  <span class="hljs-comment">// 将处理后的结果与 Sec-WebSocket-Accept 比对，返回比对结果</span><br>    <span class="hljs-keyword">return</span> [acceptHeader isEqualToString:expectedAccept];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到 SRWebSocket 在校验握手返回头部信息时分了三个步骤，一是校验 HTTP Response Code 是否大于 400，其实协议规定的是服务端要返回 101，SRWebSocket 这里处理的比较宽松。二是校验 Sec-WebSocket-Accept，方法是将 Sec-WebSocket-Key 按服务端的方式，拼接协议规定字符串，sha-1 散列后 Base64 编码，如果结果与 Sec-WebSocket-Accept 一致，校验通过。三是校验 Sec-WebSocket-Protocol，如果服务端返回的这个字段有值，说明客户端在请求时提供了子协议方案，所以需要比对客户端和服务端的子协议是否一致。这三项校验完成，说明握手已经成功，此时更新状态为已连接，并回调给上层。</p><h2 id="数据读取与写入">数据读取与写入</h2><p>首先看一下 SRWebSocket 读取和写入的流程：</p><p><img src="/resources/image/SRWebSockey%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="SRWebSocket 流程图"></p><p>黄色区域部分是 SRWebSocket 的处理流程，可以看到，在输入输出流和客户端之间有一个读写缓存区作为输入输出数据的缓冲，相比数据写入，数据读取会复杂一些。</p><h3 id="数据读取">数据读取</h3><p>NSInputStream 从服务端的 Output 通道接收数据后，回调 NSStreamEventHasBytesAvailable 事件给 SRWebSocket：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)safeHandleEvent:(<span class="hljs-built_in">NSStreamEvent</span>)eventCode stream:(<span class="hljs-built_in">NSStream</span> *)aStream<br>&#123;<br>        <span class="hljs-keyword">switch</span> (eventCode) &#123;<br>...<br>            <span class="hljs-keyword">case</span> <span class="hljs-built_in">NSStreamEventHasBytesAvailable</span>: &#123;<br>                <span class="hljs-comment">// 输入流中有数据可读</span><br>                SRFastLog(<span class="hljs-string">@&quot;NSStreamEventHasBytesAvailable %@&quot;</span>, aStream);<br>                <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> bufferSize = <span class="hljs-number">2048</span>;<br>                uint8_t buffer[bufferSize];<br>                <br>                <span class="hljs-comment">// 将输入流中的数据读到已读缓存区</span><br>                <span class="hljs-keyword">while</span> (_inputStream.hasBytesAvailable) &#123;<br>                    <span class="hljs-built_in">NSInteger</span> bytes_read = [_inputStream read:buffer maxLength:bufferSize];<br>                    <br>                    <span class="hljs-keyword">if</span> (bytes_read &gt; <span class="hljs-number">0</span>) &#123;<br>                        [_readBuffer appendBytes:buffer length:bytes_read];<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bytes_read &lt; <span class="hljs-number">0</span>) &#123;<br>                        [<span class="hljs-keyword">self</span> failWithError:_inputStream.streamError];<br>                    &#125;<br>                    <br>                    <span class="hljs-keyword">if</span> (bytes_read != bufferSize) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;;<br>                <br>                <span class="hljs-comment">// 尝试从已读缓冲区读取数据</span><br>                [<span class="hljs-keyword">self</span> _pumpScanner];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>...<br></code></pre></div></td></tr></table></figure><p>在收到 NSStreamEventHasBytesAvailable 事件后，SRWebSocket 将输入流中可读的数据读到已读缓存区 _readBuffer 中，接下来要做的是从 _readBuffer 解析出 webSocket 消息给到客户端，需要借助 SRWebSocket 设计的消费者。</p><p>输入输出流被成功打开后，我们能从输入流中读到的数据分为两种，一个是握手阶段的 HTTP Response Header，另一个是 webSocket 帧数据。如果要从一个二进制流中解析这两种数据需要如何做呢，对于 HTTP Response Header 可以在缓存区中查找 <code>\r\n\r\n</code> 将匹配的最后一个字符之前的数据取出来就是所有的 HTTP Header 数据（因为握手总是发生在 webSocket 帧发送之前）。至于为什么是 <code>\r\n\r\n</code> 可以看下服务端返回的 HTTP 报文：</p><figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> Ok\r\n<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>AAA\r\n<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache\r\n<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Nov 2014 23:20:27 GMT\r\n<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html\r\n<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close\r\n\r\n   &lt;--------------<br></code></pre></div></td></tr></table></figure><p>每个 HTTP Header 之后一般都会有 <code>\r\n</code> 用于换行，而 Header 和 Body 之间会空一行，所以 Header 的末尾会是 <code>\r\n\r\n</code> 。解析出握手的返回头信息后，就是解析 webSocket 帧数据了，通过观察帧的结构发现每一帧所占字节数是不固定的，而且没有类似 HTTP Header 的分隔符作为标志，所以只能分批次解析 webSocket 帧。首先读取 2 个字节的数据，解析 Payload Length 和 Mask，通过这两个值判断是否有 Extension Payload Length 和 Masking Key，如果有，再把这部分数据读出来，此时已经拿到 Payload 数据长度，再往后就是 Payload 数据了，按 Payload Length 去读就可以。</p><p>SRWebSocket 消费者就是按这种模式去设计的，分为 HTTP consumer 和 webSocket consumer，每当有数据需要从已读缓存区读取时，就会创建对应的 consumer 加入到消费者工作队列 consumers 中，同时读取事件循环会从 consumers 中取出 consumer 去缓存区匹配数据。为了防止 consumer 创建过多，SRWebSocket 维护了一个消费者缓存池 consumerPool，需要时从缓存池获取，使用完成后归还缓存池，缓存池的大小默认是 8。</p><p>首先来看一下 HTTP consumer 的初始化代码：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_readHTTPHeader;<br>&#123;<br>...       <br>    [<span class="hljs-keyword">self</span> _readUntilHeaderCompleteWithCallback:^(SRWebSocket *<span class="hljs-keyword">self</span>,  <span class="hljs-built_in">NSData</span> *data) &#123;<br>        ...<br>    &#125;];<br>&#125;<br><br><span class="hljs-comment">// HTTP Header 匹配字符</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> CRLFCRLFBytes[] = &#123;<span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>&#125;;<br><br>- (<span class="hljs-type">void</span>)_readUntilHeaderCompleteWithCallback:(data_callback)dataHandler;<br>&#123;<br>    [<span class="hljs-keyword">self</span> _readUntilBytes:CRLFCRLFBytes length:<span class="hljs-keyword">sizeof</span>(CRLFCRLFBytes) callback:dataHandler];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)_readUntilBytes:(<span class="hljs-keyword">const</span> <span class="hljs-type">void</span> *)bytes length:(size_t)length callback:(data_callback)dataHandler;<br>&#123;<br>    <span class="hljs-comment">// TODO optimize so this can continue from where we last searched</span><br>  <span class="hljs-comment">// 定义了一个匿名函数，在 data 中查找匹配字符，并返回最后一个匹配字符前的字节数量</span><br>    stream_scanner consumer = ^size_t(<span class="hljs-built_in">NSData</span> *data) &#123;<br>        __block size_t found_size = <span class="hljs-number">0</span>;<br>        __block size_t match_count = <span class="hljs-number">0</span>;<br>        <br>        size_t size = data.length;<br>        <span class="hljs-keyword">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buffer = data.bytes;<br>        <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; size; i++ ) &#123;<br>            <span class="hljs-keyword">if</span> (((<span class="hljs-keyword">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)buffer)[i] == ((<span class="hljs-keyword">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)bytes)[match_count]) &#123;<br>                match_count += <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (match_count == length) &#123;<br>                  <span class="hljs-comment">// 所有字符匹配完成</span><br>                    found_size = i + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// 发现有不匹配，重置索引</span><br>                match_count = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> found_size;<br>    &#125;;<br>  <span class="hljs-comment">// 使用匹配规则的匿名函数 和匹配完成回调函数创建消费者</span><br>    [<span class="hljs-keyword">self</span> _addConsumerWithScanner:consumer callback:dataHandler];<br>&#125;<br><br><span class="hljs-comment">// 俄罗斯套娃...</span><br>- (<span class="hljs-type">void</span>)_addConsumerWithScanner:(stream_scanner)consumer callback:(data_callback)callback;<br>&#123;<br>    [<span class="hljs-keyword">self</span> assertOnWorkQueue];<br>    [<span class="hljs-keyword">self</span> _addConsumerWithScanner:consumer callback:callback dataLength:<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-comment">// 最后一层...</span><br>- (<span class="hljs-type">void</span>)_addConsumerWithScanner:(stream_scanner)consumer callback:(data_callback)callback dataLength:(size_t)dataLength;<br>&#123;    <br>    [<span class="hljs-keyword">self</span> assertOnWorkQueue];<br>  <span class="hljs-comment">// 从消费者缓存池中取出消费者，加入到工作队列</span><br>    [_consumers addobjc:[_consumerPool consumerWithScanner:consumer handler:callback bytesNeeded:dataLength readToCurrentFrame:<span class="hljs-literal">NO</span> unmaskBytes:<span class="hljs-literal">NO</span>]];<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到 SRWebSocket 把 HTTP Header 的匹配设计成消费者的一个匿名函数，这个匿名函数将对缓存区里的数据进行匹配拿到 Data 和 Size，之后将数据回调给 Callback 函数做 Header 的校验。</p><p>接着来看一下 webSocket consumer 的初始化代码：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_addConsumerWithDataLength:(size_t)dataLength callback:(data_callback)callback readToCurrentFrame:(<span class="hljs-type">BOOL</span>)readToCurrentFrame unmaskBytes:(<span class="hljs-type">BOOL</span>)unmaskBytes;<br>&#123;   <br>    [<span class="hljs-keyword">self</span> assertOnWorkQueue];<br>    assert(dataLength);<br>    <br>  <span class="hljs-comment">// 从消费者缓存池中取出消费者，加入到工作队列</span><br>    [_consumers addobjc:[_consumerPool consumerWithScanner:<span class="hljs-literal">nil</span> handler:callback bytesNeeded:dataLength readToCurrentFrame:readToCurrentFrame unmaskBytes:unmaskBytes]];<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>代码看起来跟创建 HTTP consumer 最后一步差不多，只是初始化 consumer 时传参不同。HTTP consumer 只需要一个匹配规则和处理回调，其他参数不关心。而 webSocket consumer 不需要匹配规则，需要的是按字节数读取数据，所以需要传入 dataLength。readToCurrentFrame 用于标识这个 consumer 是否处理的是数据类型消息的数据帧，unmaskBytes 用于标识 Payload 是否需要解掩码，这两个字段只有在 consumer 解析 Payload 数据时有用，其他情况传 NO。</p><p>初始化方法介绍完了，接下来分析下 webSocket consumer 的使用：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_readFrameNew;<br>&#123;<br>    <span class="hljs-built_in">dispatch_async</span>(_workQueue, ^&#123;<br>      <span class="hljs-comment">// 清空当前消息数据缓存区</span><br>        [_currentFrameData setLength:<span class="hljs-number">0</span>];<br>        <br>      <span class="hljs-comment">// 当前消息的类型</span><br>        _currentFrameOpcode = <span class="hljs-number">0</span>;<br>      <br>      <span class="hljs-comment">// 当前消息包含的帧数</span><br>        _currentFrameCount = <span class="hljs-number">0</span>;<br>      <br>      <span class="hljs-comment">// 参数未用到</span><br>        _readOpCount = <span class="hljs-number">0</span>;<br>      <br>      <span class="hljs-comment">// 用来记录 _currentFrameData 中已校验 UTF-8 编码的字符串位置偏移</span><br>        _currentStringScanPosition = <span class="hljs-number">0</span>;<br>        <br>      <span class="hljs-comment">// 继续</span><br>        [<span class="hljs-keyword">self</span> _readFrameContinue];<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>readFrameNew 是创建 webSocket 消费者的入口，方法中将几个比较重要的参数清空，currentFrameData、currentFrameOpcode、currentFrameCount 和 currentStringScanPosition 都只是给数据类型消息使用的，控制类型消息没有使用。currentFrameOpcode 这里可能有个疑问，为什么初始化为 0，0 在 opcode 中不是代表延续帧吗。其实 SRWebSocket 在读取前两个字节解析 opcode 时，如果 opcode 是 0，在构造 frame_header 结构体时依旧会沿用这个消息起始帧的 opcode 值，所以这里设置为 0 不会有冲突。</p><p>接着是 readFrameContinue 方法：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_readFrameContinue;<br>&#123;<br>  <span class="hljs-comment">// 猜测这里的控制主要是校验代码逻辑</span><br>    assert((_currentFrameCount == <span class="hljs-number">0</span> &amp;&amp; _currentFrameOpcode == <span class="hljs-number">0</span>) || (_currentFrameCount &gt; <span class="hljs-number">0</span> &amp;&amp; _currentFrameOpcode &gt; <span class="hljs-number">0</span>));<br><br>  <span class="hljs-comment">// 创建一个读取 2 个字节数据的 webSocket 消费者到工作队列</span><br>    [<span class="hljs-keyword">self</span> _addConsumerWithDataLength:<span class="hljs-number">2</span> callback:^(SRWebSocket *<span class="hljs-keyword">self</span>, <span class="hljs-built_in">NSData</span> *data) &#123;<br>      <span class="hljs-comment">// 构造一个 webSocket 头信息的结构体</span><br>      __block frame_header header = &#123;<span class="hljs-number">0</span>&#125;;<br>        <br>        <span class="hljs-keyword">const</span> uint8_t *headerBuffer = data.bytes;<br>        assert(data.length &gt;= <span class="hljs-number">2</span>);<br>        <br>      <span class="hljs-comment">// 拿到 RSV1、RSV2、RSV3，根据协议规定这三位必须是 0</span><br>        <span class="hljs-keyword">if</span> (headerBuffer[<span class="hljs-number">0</span>] &amp; SRRsvMask) &#123;<br>            [<span class="hljs-keyword">self</span> _closeWithProtocolError:<span class="hljs-string">@&quot;Server used RSV bits&quot;</span>];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>      <span class="hljs-comment">// 拿到 opcode</span><br>        uint8_t receivedOpcode = (SROpCodeMask &amp; headerBuffer[<span class="hljs-number">0</span>]);<br>        <br>      <span class="hljs-comment">// 控制帧 = ping 或 pong 或 close  数据帧 = !控制帧</span><br>        <span class="hljs-type">BOOL</span> isControlFrame = (receivedOpcode == SROpCodePing || receivedOpcode == SROpCodePong || receivedOpcode == SROpCodeConnectionClose);<br>        <br>      <span class="hljs-comment">// currentFrameCount &gt; 0 说明在等待 opcode 为 0 的延续帧</span><br>        <span class="hljs-keyword">if</span> (!isControlFrame &amp;&amp; receivedOpcode != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">self</span>-&gt;_currentFrameCount &gt; <span class="hljs-number">0</span>) &#123;<br>            [<span class="hljs-keyword">self</span> _closeWithProtocolError:<span class="hljs-string">@&quot;all data frames after the initial data frame must have opcode 0&quot;</span>];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>      <span class="hljs-comment">// currentFrameCount = 0 说明一定不要是延续帧</span><br>        <span class="hljs-keyword">if</span> (receivedOpcode == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">self</span>-&gt;_currentFrameCount == <span class="hljs-number">0</span>) &#123;<br>            [<span class="hljs-keyword">self</span> _closeWithProtocolError:<span class="hljs-string">@&quot;cannot continue a message&quot;</span>];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>      <span class="hljs-comment">// 这里就是前文提到的 如果当前帧 opcode 是 0，在构造 frame_header 时将 opcode 设置成当前消息首帧的 opcode 值</span><br>        header.opcode = receivedOpcode == <span class="hljs-number">0</span> ? <span class="hljs-keyword">self</span>-&gt;_currentFrameOpcode : receivedOpcode;<br>        <br>      <span class="hljs-comment">// 获取 FIN</span><br>        header.fin = !!(SRFinMask &amp; headerBuffer[<span class="hljs-number">0</span>]);<br>        <br>        <span class="hljs-comment">// 获取 Mask</span><br>        header.masked = !!(SRMaskMask &amp; headerBuffer[<span class="hljs-number">1</span>]);<br>      <br>      <span class="hljs-comment">// 获取 Payload Length</span><br>        header.payload_length = SRPayloadLenMask &amp; headerBuffer[<span class="hljs-number">1</span>];<br>        <br>        headerBuffer = <span class="hljs-literal">NULL</span>;<br>      <br>      <span class="hljs-comment">// 如果当前帧 Mask 位的值为 1，SRWebSocket 直接将连接关闭了，但实际协议只是规定客户端发送消息需要使用掩码，并没有对服务端行为做约束，这里是有些差异的</span><br>        <span class="hljs-keyword">if</span> (header.masked) &#123;<br>            [<span class="hljs-keyword">self</span> _closeWithProtocolError:<span class="hljs-string">@&quot;Client must receive unmasked data&quot;</span>];<br>        &#125;<br>        <br>      <span class="hljs-comment">// extra_bytes_needed 是用来统计 Extension Payload Length 和 Masking Key 的长度，用于下一轮 consumer 的消费</span><br>      <span class="hljs-comment">// 如果 Mask 位为 1，要加上 4 位的 Masking Key 长度。</span><br>        size_t extra_bytes_needed = header.masked ? <span class="hljs-keyword">sizeof</span>(_currentReadMaskKey) : <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">if</span> (header.payload_length == <span class="hljs-number">126</span>) &#123;<br>          <span class="hljs-comment">// 如果 Payload Length 是 126，要加上 16 位的 Extension Payload Length</span><br>            extra_bytes_needed += <span class="hljs-keyword">sizeof</span>(uint16_t);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (header.payload_length == <span class="hljs-number">127</span>) &#123;<br>          <span class="hljs-comment">// 如果 Payload Length 是 127，要加上 64 位的 Extension Payload Length</span><br>            extra_bytes_needed += <span class="hljs-keyword">sizeof</span>(uint64_t);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (extra_bytes_needed == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">// 如果 extra_bytes_needed 为 0，说明没有 Extension Payload Length 和 Masking Key 要处理，所以直接处理 Payload</span><br>            [<span class="hljs-keyword">self</span> _handleFrameHeader:header curData:<span class="hljs-keyword">self</span>-&gt;_currentFrameData];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果 extra_bytes_needed 不为 0，创建所需数据长度为 extra_bytes_needed 的 webSocket 消费者到工作队列</span><br>            [<span class="hljs-keyword">self</span> _addConsumerWithDataLength:extra_bytes_needed callback:^(SRWebSocket *<span class="hljs-keyword">self</span>, <span class="hljs-built_in">NSData</span> *data) &#123;<br>                size_t mapped_size = data.length;<br>                <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unused (mapped_size)</span><br>                <span class="hljs-keyword">const</span> <span class="hljs-type">void</span> *mapped_buffer = data.bytes;<br>              <br>              <span class="hljs-comment">// offset 用来标记 Masking Key 的位置</span><br>                size_t offset = <span class="hljs-number">0</span>;<br>                <br>                <span class="hljs-keyword">if</span> (header.payload_length == <span class="hljs-number">126</span>) &#123;<br>                  <span class="hljs-comment">// 如果 Payload Length 是 126，真实负载数据长度是 Payload Length 之后的 16 位来标识</span><br>                    assert(mapped_size &gt;= <span class="hljs-keyword">sizeof</span>(uint16_t));<br>                    uint16_t newLen = EndianU16_BtoN(*(uint16_t *)(mapped_buffer));<br>                    header.payload_length = newLen;<br>                    offset += <span class="hljs-keyword">sizeof</span>(uint16_t);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (header.payload_length == <span class="hljs-number">127</span>) &#123;<br>                  <span class="hljs-comment">// 如果 Payload Length 是 127，真实负载数据长度是 Payload Length 之后的 64 位来标识</span><br>                    assert(mapped_size &gt;= <span class="hljs-keyword">sizeof</span>(uint64_t));<br>                    header.payload_length = EndianU64_BtoN(*(uint64_t *)(mapped_buffer));<br>                    offset += <span class="hljs-keyword">sizeof</span>(uint64_t);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-comment">// 能走到这里，说明没有 Extension Payload Length</span><br>                    assert(header.payload_length &lt; <span class="hljs-number">126</span> &amp;&amp; header.payload_length &gt;= <span class="hljs-number">0</span>);<br>                &#125;<br>                <br>              <span class="hljs-comment">// 如果 Mask 位为 1，需要将 Masking Key 读取到缓存区，用于之后 Payload 解掩码</span><br>                <span class="hljs-keyword">if</span> (header.masked) &#123;<br>                    assert(mapped_size &gt;= <span class="hljs-keyword">sizeof</span>(_currentReadMaskOffset) + offset);<br>                    memcpy(<span class="hljs-keyword">self</span>-&gt;_currentReadMaskKey, ((uint8_t *)mapped_buffer) + offset, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">self</span>-&gt;_currentReadMaskKey));<br>                &#125;<br>                <br>              <span class="hljs-comment">// 处理 Payload</span><br>                [<span class="hljs-keyword">self</span> _handleFrameHeader:header curData:<span class="hljs-keyword">self</span>-&gt;_currentFrameData];<br>            &#125; readToCurrentFrame:<span class="hljs-literal">NO</span> unmaskBytes:<span class="hljs-literal">NO</span>];<br>        &#125;<br>    &#125; readToCurrentFrame:<span class="hljs-literal">NO</span> unmaskBytes:<span class="hljs-literal">NO</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>readFrameContinue 方法先是创建了一个读取 2 个字节数据的 consumer，读取到数据后构建一个 frame_header 结构体，通过对 Mask 位和 Payload Length 的解析，判断是否有 Extension Payload Length 和 Masking Key 存在，如果存在，就创建一个读取这部分数据的 consumer，获取到真实负载长度和掩码后，创建读取 Payload 数据的 consumer，如果不存在则直接创建一个读取 Payload 数据的 consumer。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_handleFrameHeader:(frame_header)frame_header curData:(<span class="hljs-built_in">NSData</span> *)curData;<br>&#123;<br>  <span class="hljs-comment">// 前面介绍过，构造的 frame_header 的 opcode 不应该为 0</span><br>    assert(frame_header.opcode != <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.readyState == SR_CLOSED) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 控制帧 = ping 或 pong 或 close  数据帧 = !控制帧</span><br>    <span class="hljs-type">BOOL</span> isControlFrame = (frame_header.opcode == SROpCodePing || frame_header.opcode == SROpCodePong || frame_header.opcode == SROpCodeConnectionClose);<br>    <br>  <span class="hljs-comment">// 控制帧不能分片</span><br>    <span class="hljs-keyword">if</span> (isControlFrame &amp;&amp; !frame_header.fin) &#123;<br>        [<span class="hljs-keyword">self</span> _closeWithProtocolError:<span class="hljs-string">@&quot;Fragmented control frames not allowed&quot;</span>];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 控制帧 Payload Length 不能是 126、127</span><br>    <span class="hljs-keyword">if</span> (isControlFrame &amp;&amp; frame_header.payload_length &gt;= <span class="hljs-number">126</span>) &#123;<br>        [<span class="hljs-keyword">self</span> _closeWithProtocolError:<span class="hljs-string">@&quot;Control frames cannot have payloads larger than 126 bytes&quot;</span>];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 数据帧类型才会更新这两个变量的值</span><br>    <span class="hljs-keyword">if</span> (!isControlFrame) &#123;<br>        _currentFrameOpcode = frame_header.opcode;<br>        _currentFrameCount += <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (frame_header.payload_length == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Payload Length 是 0</span><br>        <span class="hljs-keyword">if</span> (isControlFrame) &#123;<br>          <span class="hljs-comment">// 如果是控制帧，感觉这里可以将 curData 替换成 nil</span><br>            [<span class="hljs-keyword">self</span> _handleFrameWithData:curData opCode:frame_header.opcode];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果是数据帧</span><br>            <span class="hljs-keyword">if</span> (frame_header.fin) &#123;<br>              <span class="hljs-comment">// FIN 位为 1，是当前消息的最后一帧，因此需要将 currentFrameData 缓存的当前消息的所有帧数据回调给上层</span><br>                [<span class="hljs-keyword">self</span> _handleFrameWithData:_currentFrameData opCode:frame_header.opcode];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// TODO add assert that opcode is not a control;</span><br>              <span class="hljs-comment">// 如果是延续帧，Payload Length 为 0，直接读取下一帧</span><br>                [<span class="hljs-keyword">self</span> _readFrameContinue];<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Payload Length 不是 0</span><br>        assert(frame_header.payload_length &lt;= SIZE_T_MAX);<br>      <span class="hljs-comment">// 创建读取 Payload 的 webSocket 消费者加入到工作队列</span><br>        [<span class="hljs-keyword">self</span> _addConsumerWithDataLength:(size_t)frame_header.payload_length callback:^(SRWebSocket *<span class="hljs-keyword">self</span>, <span class="hljs-built_in">NSData</span> *newData) &#123;<br>            <span class="hljs-keyword">if</span> (isControlFrame) &#123;<br>              <span class="hljs-comment">// 如果是控制帧，将这部分读到的 Payload 数据回调给上层</span><br>                [<span class="hljs-keyword">self</span> _handleFrameWithData:newData opCode:frame_header.opcode];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// 如果是数据帧</span><br>                <span class="hljs-keyword">if</span> (frame_header.fin) &#123;<br>                  <span class="hljs-comment">// FIN 位为 1，是当前消息的最后一帧，因此需要将 currentFrameData 缓存的当前消息的所有帧数据回调给上层</span><br>                    [<span class="hljs-keyword">self</span> _handleFrameWithData:<span class="hljs-keyword">self</span>-&gt;_currentFrameData opCode:frame_header.opcode];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// TODO add assert that opcode is not a control;</span><br>                  <span class="hljs-comment">// 如果是延续帧，直接读取下一帧</span><br>                  <span class="hljs-comment">// 这里无需关心延续帧的 Payload 没有被 append 到 currentFrameData，在循环消费者队列匹配数据时已经处理过了</span><br>                    [<span class="hljs-keyword">self</span> _readFrameContinue];<br>                &#125;<br>                <br>            &#125;<br>        &#125; readToCurrentFrame:!isControlFrame unmaskBytes:frame_header.masked];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>handleFrameHeader 方法对 Payload Length 是否为 0，当前帧是控制帧还是数据帧做了逻辑区分。区别于之前创建的 webSocket 消费者，用于读取 Payload 数据的消费者 readToCurrentFrame 和 unmaskBytes 都传了值，这两个值在循环消费者队列读取数据时会用到。接下来就是处理完整的 webSocket 消息数据了：</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_handleFrameWithData:(<span class="hljs-built_in">NSData</span> *)frameData opCode:(<span class="hljs-built_in">NSInteger</span>)opcode;<br>&#123;                <br>    <span class="hljs-comment">// Check that the current data is valid UTF8</span><br>    <span class="hljs-comment">// 控制帧 = ping 或 pong 或 close  数据帧 = !控制帧</span><br>    <span class="hljs-type">BOOL</span> isControlFrame = (opcode == SROpCodePing || opcode == SROpCodePong || opcode == SROpCodeConnectionClose);<br>  <span class="hljs-comment">// 到目前为止，当前消息的所有数据已经拿到了，就可以创建下一轮消费者了</span><br>    <span class="hljs-keyword">if</span> (!isControlFrame) &#123;<br>      <span class="hljs-comment">// 如果当前是数据帧，需要先清空数据帧相关的变量和缓存</span><br>        [<span class="hljs-keyword">self</span> _readFrameNew];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果是控制帧，直接创建下一轮消费者</span><br>        <span class="hljs-built_in">dispatch_async</span>(_workQueue, ^&#123;<br>            [<span class="hljs-keyword">self</span> _readFrameContinue];<br>        &#125;);<br>    &#125;<br>    <br>    <span class="hljs-comment">//frameData will be copied before passing to handlers</span><br>    <span class="hljs-comment">//otherwise there can be misbehaviours when value at the pointer is changed</span><br>    <span class="hljs-keyword">switch</span> (opcode) &#123;<br>        <span class="hljs-keyword">case</span> SROpCodeTextFrame: &#123;<br>          <span class="hljs-comment">// 处理字符数据类型消息</span><br>            <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(webSocketShouldConvertTextFrameToString:)] &amp;&amp; ![<span class="hljs-keyword">self</span>.delegate webSocketShouldConvertTextFrameToString:<span class="hljs-keyword">self</span>]) &#123;<br>              <span class="hljs-comment">// 如果上层指定字符数据使用二进制方式返回</span><br>                [<span class="hljs-keyword">self</span> _handleMessage:[frameData <span class="hljs-keyword">copy</span>]];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// 默认字符数据使用字符串方式返回</span><br>                <span class="hljs-built_in">NSString</span> *str = [[<span class="hljs-built_in">NSString</span> alloc] initWithData:frameData encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>                <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">nil</span> &amp;&amp; frameData) &#123;<br>                    [<span class="hljs-keyword">self</span> closeWithCode:SRStatusCodeInvalidUTF8 reason:<span class="hljs-string">@&quot;Text frames must be valid UTF-8&quot;</span>];<br>                    <span class="hljs-built_in">dispatch_async</span>(_workQueue, ^&#123;<br>                        [<span class="hljs-keyword">self</span> closeConnection];<br>                    &#125;);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                [<span class="hljs-keyword">self</span> _handleMessage:str];<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> SROpCodeBinaryFrame:<br>        <span class="hljs-comment">// 处理二进制数据类型消息</span><br>            [<span class="hljs-keyword">self</span> _handleMessage:[frameData <span class="hljs-keyword">copy</span>]];<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SROpCodeConnectionClose:<br>        <span class="hljs-comment">// 处理关闭控制类型消息</span><br>            [<span class="hljs-keyword">self</span> handleCloseWithData:[frameData <span class="hljs-keyword">copy</span>]];<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SROpCodePing:<br>        <span class="hljs-comment">// 处理 ping 控制类型消息</span><br>            [<span class="hljs-keyword">self</span> handlePing:[frameData <span class="hljs-keyword">copy</span>]];<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SROpCodePong:<br>        <span class="hljs-comment">// 处理 pong 控制类型消息</span><br>            [<span class="hljs-keyword">self</span> handlePong:[frameData <span class="hljs-keyword">copy</span>]];<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// 其他 opcode 无效</span><br>            [<span class="hljs-keyword">self</span> _closeWithProtocolError:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Unknown opcode %ld&quot;</span>, (<span class="hljs-type">long</span>)opcode]];<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Handle invalid opcode</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>handleFrameWithData 方法根据 opcode 的不同，对数据有不同的处理方式，并在处理前先创建了下一轮的消费者。以上这些代码只是 webSocket 消费者的创建和回调处理，我们还需要一个事件去驱动数据流转，这个事件就是 pumpScanner。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">-(<span class="hljs-type">void</span>)_pumpScanner;<br>&#123;<br>    [<span class="hljs-keyword">self</span> assertOnWorkQueue];<br>    <br>  <span class="hljs-comment">// 如果正在 pumping 直接返回</span><br>    <span class="hljs-keyword">if</span> (!_isPumping) &#123;<br>        _isPumping = <span class="hljs-literal">YES</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> ([<span class="hljs-keyword">self</span> _innerPumpScanner]) &#123;<br>        <br>    &#125;<br>    <br>    _isPumping = <span class="hljs-literal">NO</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>pumpScanner 方法里循环调用了 innerPumpScanner，我们先记住这个 while 循环。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">// Returns true if did work</span><br>- (<span class="hljs-type">BOOL</span>)_innerPumpScanner &#123;<br>    <br>  <span class="hljs-comment">// 这是个标志位  决定 pumpScanner 的循环是否持续</span><br>    <span class="hljs-type">BOOL</span> didWork = <span class="hljs-literal">NO</span>;<br>    <br>  <span class="hljs-comment">// 状态不对  返回 NO</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.readyState &gt;= SR_CLOSED) &#123;<br>        <span class="hljs-keyword">return</span> didWork;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 消费者工作队列是空的   返回 NO</span><br>    <span class="hljs-keyword">if</span> (!_consumers.count) &#123;<br>        <span class="hljs-keyword">return</span> didWork;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 已读缓冲区没有新增可读数据  返回 NO</span><br>    size_t curSize = _readBuffer.length - _readBufferOffset;<br>    <span class="hljs-keyword">if</span> (!curSize) &#123;<br>        <span class="hljs-keyword">return</span> didWork;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 从消费者工作队列里取出第一个消费者</span><br>    SRIOConsumer *consumer = [_consumers objcAtIndex:<span class="hljs-number">0</span>];<br>    <br>    size_t bytesNeeded = consumer.bytesNeeded;<br>    <br>    size_t foundSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (consumer.consumer) &#123;<br>      <span class="hljs-comment">// 如果消费者携带匹配规则的匿名函数，说明是 HTTP Header consumer，</span><br>        <span class="hljs-built_in">NSData</span> *tempView = [<span class="hljs-built_in">NSData</span> dataWithBytesNoCopy:(<span class="hljs-type">char</span> *)_readBuffer.bytes + _readBufferOffset length:_readBuffer.length - _readBufferOffset freeWhenDone:<span class="hljs-literal">NO</span>];  <br>      <span class="hljs-comment">// 计算可读缓存中匹配 HTTP Header 的数据长度</span><br>        foundSize = consumer.consumer(tempView);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// webSocket consumer</span><br>        assert(consumer.bytesNeeded);<br>        <span class="hljs-keyword">if</span> (curSize &gt;= bytesNeeded) &#123;<br>          <span class="hljs-comment">// 可读的数据比需要的大，那么只读消费者需要的长度</span><br>            foundSize = bytesNeeded;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (consumer.readToCurrentFrame) &#123;<br>          <span class="hljs-comment">// 可读的数据比需要的小，但这个消费者是读取数据类型的 Payload，那么能读多少读多少</span><br>            foundSize = curSize;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">NSData</span> *slice = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> (consumer.readToCurrentFrame || foundSize) &#123;<br>      <span class="hljs-comment">// 将消费者需要的数据取出来</span><br>        <span class="hljs-built_in">NSRange</span> sliceRange = <span class="hljs-built_in">NSMakeRange</span>(_readBufferOffset, foundSize);<br>        slice = [_readBuffer subdataWithRange:sliceRange];<br>        <br>      <span class="hljs-comment">// 更新偏移量</span><br>        _readBufferOffset += foundSize;<br>        <br>      <span class="hljs-comment">// 这里是优化缓存使用大小</span><br>        <span class="hljs-keyword">if</span> (_readBufferOffset &gt; <span class="hljs-number">4096</span> &amp;&amp; _readBufferOffset &gt; (_readBuffer.length &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>            _readBuffer = [[<span class="hljs-built_in">NSMutableData</span> alloc] initWithBytes:(<span class="hljs-type">char</span> *)_readBuffer.bytes + _readBufferOffset length:_readBuffer.length - _readBufferOffset];            _readBufferOffset = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>      <span class="hljs-comment">// 消费者的 unmaskBytes 属性，如果是 1，需要将 Payload 数据解掩码，而解掩码所需的 Masking Key，之前已经保存到 currentReadMaskKey 里了</span><br>        <span class="hljs-keyword">if</span> (consumer.unmaskBytes) &#123;<br>            <span class="hljs-built_in">NSMutableData</span> *mutableSlice = [slice mutableCopy];<br>            <br>            <span class="hljs-built_in">NSUInteger</span> len = mutableSlice.length;<br>            uint8_t *bytes = mutableSlice.mutableBytes;<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSUInteger</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>                bytes[i] = bytes[i] ^ _currentReadMaskKey[_currentReadMaskOffset % <span class="hljs-keyword">sizeof</span>(_currentReadMaskKey)];<br>                _currentReadMaskOffset += <span class="hljs-number">1</span>;<br>            &#125;<br>            <br>            slice = mutableSlice;<br>        &#125;<br>        <br>      <span class="hljs-comment">// 消费者的 readToCurrentFrame 属性，如果是 1，说明是在读取数据帧的 Payload</span><br>        <span class="hljs-keyword">if</span> (consumer.readToCurrentFrame) &#123;<br>          <span class="hljs-comment">// 将当前帧的 Payload 数据拼接到当前消息数据的缓存上</span><br>            [_currentFrameData appendData:slice];<br>            <br>          <span class="hljs-comment">// 参数没用上</span><br>            _readOpCount += <span class="hljs-number">1</span>;<br>            <br>          <span class="hljs-comment">// 如果当前帧类型是文本帧，需要对 Payload 数据做 UTF8 编码校验</span><br>            <span class="hljs-keyword">if</span> (_currentFrameOpcode == SROpCodeTextFrame) &#123;<br>                <span class="hljs-comment">// Validate UTF8 stuff.</span><br>                size_t currentDataSize = _currentFrameData.length;<br>                <span class="hljs-keyword">if</span> (_currentFrameOpcode == SROpCodeTextFrame &amp;&amp; currentDataSize &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Optimize the crap out of this.  Don&#x27;t really have to copy all the data each time</span><br>                    <br>                    size_t scanSize = currentDataSize - _currentStringScanPosition;<br>                    <br>                    <span class="hljs-built_in">NSData</span> *scan_data = [_currentFrameData subdataWithRange:<span class="hljs-built_in">NSMakeRange</span>(_currentStringScanPosition, scanSize)];<br>                    int32_t valid_utf8_size = validate_dispatch_data_partial_string(scan_data);<br>                    <br>                    <span class="hljs-keyword">if</span> (valid_utf8_size == <span class="hljs-number">-1</span>) &#123;<br>                        [<span class="hljs-keyword">self</span> closeWithCode:SRStatusCodeInvalidUTF8 reason:<span class="hljs-string">@&quot;Text frames must be valid UTF-8&quot;</span>];<br>                        <span class="hljs-built_in">dispatch_async</span>(_workQueue, ^&#123;<br>                            [<span class="hljs-keyword">self</span> closeConnection];<br>                        &#125;);<br>                        <span class="hljs-keyword">return</span> didWork;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                      <span class="hljs-comment">// 更新已校验字符偏移</span><br>                        _currentStringScanPosition += valid_utf8_size;<br>                    &#125;<br>                &#125; <br>                <br>            &#125;<br>            <br>          <span class="hljs-comment">// 更新消费者的 bytesNeeded</span><br>            consumer.bytesNeeded -= foundSize;<br>            <br>          <span class="hljs-comment">// 如果 bytesNeeded 是 0，说明当前消费者杀青了，调用消费者的完成回调，把它还给缓存池</span><br>            <span class="hljs-keyword">if</span> (consumer.bytesNeeded == <span class="hljs-number">0</span>) &#123;<br>                [_consumers removeobjcAtIndex:<span class="hljs-number">0</span>];<br>                consumer.handler(<span class="hljs-keyword">self</span>, <span class="hljs-literal">nil</span>);<br>                [_consumerPool returnConsumer:consumer];<br>                didWork = <span class="hljs-literal">YES</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (foundSize) &#123;<br>          <span class="hljs-comment">// 如果不是消费者不是读取数据帧 Payload 类型的 webSocket consumer</span><br>          <span class="hljs-comment">// 并且已经拿到了想要的数据，调用消费者的完成回调，把它还给缓存池</span><br>            [_consumers removeobjcAtIndex:<span class="hljs-number">0</span>];<br>            consumer.handler(<span class="hljs-keyword">self</span>, slice);<br>            [_consumerPool returnConsumer:consumer];<br>            didWork = <span class="hljs-literal">YES</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> didWork;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个方法里的 didWork 标志位需要跟上一个方法的 while 循环结合起来看，只有在消费者拿到了自己想要的数据完成使命后，才会将这个标志位设为 YES，进入下一次循环，因为此时可能可读缓存区还有一部分数据是可以读的。当前状态问题、工作队列没有消费者、可读缓存区没有数据可读 和消费者没有完整拿到数据，这些情况即使再跑一次 innerPumpScanner 也未必解决，不如停止循环，等待下一次 pumpScanner 的触发。</p><h3 id="数据写入">数据写入</h3><p>与读取相比，写入是一个反向组装的过程，代码相对比较简单。写入的驱动源于客户端调用 send()、sendPing()，之后会走到 sendFrameWithOpcode 方法。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_sendFrameWithOpcode:(SROpCode)opcode data:(<span class="hljs-type">id</span>)data;<br>&#123;<br>    [<span class="hljs-keyword">self</span> assertOnWorkQueue];<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> == data) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 只支持字符和二进制类型</span><br>    <span class="hljs-built_in">NSAssert</span>([data isKindOfClass:[<span class="hljs-built_in">NSData</span> <span class="hljs-keyword">class</span>]] || [data isKindOfClass:[<span class="hljs-built_in">NSString</span> <span class="hljs-keyword">class</span>]], <span class="hljs-string">@&quot;NSString or NSData&quot;</span>);<br>    <br>  <span class="hljs-comment">// 计算 Payload Length</span><br>    size_t payloadLength = [data isKindOfClass:[<span class="hljs-built_in">NSString</span> <span class="hljs-keyword">class</span>]] ? [(<span class="hljs-built_in">NSString</span> *)data lengthOfBytesUsingEncoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>] : [data length];<br>        <br>    <span class="hljs-built_in">NSMutableData</span> *frame = [[<span class="hljs-built_in">NSMutableData</span> alloc] initWithLength:payloadLength + SRFrameHeaderOverhead];<br>  <span class="hljs-comment">// 这里是先粗略计算下是否还有能容下这个 webSocket 帧的内存大小</span><br>    <span class="hljs-keyword">if</span> (!frame) &#123;<br>        [<span class="hljs-keyword">self</span> closeWithCode:SRStatusCodeMessageTooBig reason:<span class="hljs-string">@&quot;Message too big&quot;</span>];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    uint8_t *frame_buffer = (uint8_t *)[frame mutableBytes];<br>    <br>    <span class="hljs-comment">// 写 FIN、RSV、Opcode 位</span><br>    frame_buffer[<span class="hljs-number">0</span>] = SRFinMask | opcode;<br>    <br>  <span class="hljs-comment">// 协议规定  客户端发送的帧 Mask 需设置为 1</span><br>    <span class="hljs-type">BOOL</span> useMask = <span class="hljs-literal">YES</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> NOMASK</span><br>    useMask = <span class="hljs-literal">NO</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>  <span class="hljs-comment">// 写 Mask 位</span><br>    <span class="hljs-keyword">if</span> (useMask) &#123;<br>    <span class="hljs-comment">// set the mask and header</span><br>        frame_buffer[<span class="hljs-number">1</span>] |= SRMaskMask;<br>    &#125;<br>    <br>    size_t frame_buffer_size = <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-keyword">const</span> uint8_t *unmasked_payload = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> ([data isKindOfClass:[<span class="hljs-built_in">NSData</span> <span class="hljs-keyword">class</span>]]) &#123;<br>        unmasked_payload = (uint8_t *)[data bytes];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([data isKindOfClass:[<span class="hljs-built_in">NSString</span> <span class="hljs-keyword">class</span>]]) &#123;<br>        unmasked_payload =  (<span class="hljs-keyword">const</span> uint8_t *)[data UTF8String];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 写 Payload Length / Extension Payload Length</span><br>    <span class="hljs-keyword">if</span> (payloadLength &lt; <span class="hljs-number">126</span>) &#123;<br>      <span class="hljs-comment">// Payload Length 7位可以表示</span><br>        frame_buffer[<span class="hljs-number">1</span>] |= payloadLength;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (payloadLength &lt;= <span class="hljs-built_in">UINT16_MAX</span>) &#123;<br>      <span class="hljs-comment">// Payload Length 需用16位表示</span><br>        frame_buffer[<span class="hljs-number">1</span>] |= <span class="hljs-number">126</span>;<br>        *((uint16_t *)(frame_buffer + frame_buffer_size)) = EndianU16_BtoN((uint16_t)payloadLength);<br>        frame_buffer_size += <span class="hljs-keyword">sizeof</span>(uint16_t);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Payload Length 需用64位表示</span><br>        frame_buffer[<span class="hljs-number">1</span>] |= <span class="hljs-number">127</span>;<br>        *((uint64_t *)(frame_buffer + frame_buffer_size)) = EndianU64_BtoN((uint64_t)payloadLength);<br>        frame_buffer_size += <span class="hljs-keyword">sizeof</span>(uint64_t);<br>    &#125;<br>        <br>    <span class="hljs-keyword">if</span> (!useMask) &#123;<br>      <span class="hljs-comment">// 不使用掩码  直接写 Payload</span><br>        <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; payloadLength; i++) &#123;<br>            frame_buffer[frame_buffer_size] = unmasked_payload[i];<br>            frame_buffer_size += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 使用掩码  先写 Masking Key</span><br>        uint8_t *mask_key = frame_buffer + frame_buffer_size;<br>        SecRandomCopyBytes(kSecRandomDefault, <span class="hljs-keyword">sizeof</span>(uint32_t), (uint8_t *)mask_key);<br>        frame_buffer_size += <span class="hljs-keyword">sizeof</span>(uint32_t);<br>        <br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> could probably optimize this with SIMD</span><br>      <span class="hljs-comment">// 写掩码后的 Payload</span><br>        <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; payloadLength; i++) &#123;<br>            frame_buffer[frame_buffer_size] = unmasked_payload[i] ^ mask_key[i % <span class="hljs-keyword">sizeof</span>(uint32_t)];<br>            frame_buffer_size += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    assert(frame_buffer_size &lt;= [frame length]);<br>  <br>  <span class="hljs-comment">// 这里校正实际的帧大小</span><br>    frame.length = frame_buffer_size;<br>    <br>    [<span class="hljs-keyword">self</span> _writeData:frame];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>sendFrameWithOpcode 方法的作用是把 Payload 数据根据 Opcode 包装成 webSocket 帧，最后调用 writeData 将数据写到缓存区。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_writeData:(<span class="hljs-built_in">NSData</span> *)data;<br>&#123;    <br>    [<span class="hljs-keyword">self</span> assertOnWorkQueue];<br><br>  <span class="hljs-comment">// 用来表示是否是在完成写入后关闭连接</span><br>    <span class="hljs-keyword">if</span> (_closeWhenFinishedWriting) &#123;<br>            <span class="hljs-keyword">return</span>;<br>    &#125;<br>  <br>  <span class="hljs-comment">// 将 webSocket 帧数据拼接到输出缓存区</span><br>    [_outputBuffer appendData:data];<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>到这里，我们已经将 webSocket 帧打包好拼接到了输出缓存区，下一步是需要将输出缓存区可输出的数据写入到输出流中，就是 pumpWriting。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_pumpWriting;<br>&#123;<br>    [<span class="hljs-keyword">self</span> assertOnWorkQueue];<br>    <br>    <span class="hljs-built_in">NSUInteger</span> dataLength = _outputBuffer.length;<br>  <span class="hljs-comment">// 输出缓存区有新的数据内容输出，并且输出流有空间可以写</span><br>    <span class="hljs-keyword">if</span> (dataLength - _outputBufferOffset &gt; <span class="hljs-number">0</span> &amp;&amp; _outputStream.hasSpaceAvailable) &#123;<br>      <span class="hljs-comment">// 写入到输出流中</span><br>        <span class="hljs-built_in">NSInteger</span> bytesWritten = [_outputStream write:_outputBuffer.bytes + _outputBufferOffset maxLength:dataLength - _outputBufferOffset];<br>        <span class="hljs-keyword">if</span> (bytesWritten == <span class="hljs-number">-1</span>) &#123;<br>            [<span class="hljs-keyword">self</span> _failWithError:[<span class="hljs-built_in">NSError</span> errorWithDomain:SRWebSocketErrorDomain code:<span class="hljs-number">2145</span> userInfo:[<span class="hljs-built_in">NSDictionary</span> dictionaryWithobjc:<span class="hljs-string">@&quot;Error writing to stream&quot;</span> forKey:<span class="hljs-built_in">NSLocalizedDescriptionKey</span>]]];<br>             <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>      <span class="hljs-comment">// 更新已写偏移量</span><br>        _outputBufferOffset += bytesWritten;<br>        <br>      <span class="hljs-comment">// 优化内存使用</span><br>        <span class="hljs-keyword">if</span> (_outputBufferOffset &gt; <span class="hljs-number">4096</span> &amp;&amp; _outputBufferOffset &gt; (_outputBuffer.length &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>            _outputBuffer = [[<span class="hljs-built_in">NSMutableData</span> alloc] initWithBytes:(<span class="hljs-type">char</span> *)_outputBuffer.bytes + _outputBufferOffset length:_outputBuffer.length - _outputBufferOffset];<br>            _outputBufferOffset = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 这里如果 closeWhenFinishedWriting 被设置为 YES，并且所有数据都已完成写入，会主动关闭连接</span><br>    <span class="hljs-keyword">if</span> (_closeWhenFinishedWriting &amp;&amp; <br>        _outputBuffer.length - _outputBufferOffset == <span class="hljs-number">0</span> &amp;&amp; <br>        (_inputStream.streamStatus != <span class="hljs-built_in">NSStreamStatusNotOpen</span> &amp;&amp;<br>         _inputStream.streamStatus != <span class="hljs-built_in">NSStreamStatusClosed</span>) &amp;&amp;<br>        !_sentClose) &#123;<br>        _sentClose = <span class="hljs-literal">YES</span>;<br>        <br>        <span class="hljs-keyword">@synchronized</span>(<span class="hljs-keyword">self</span>) &#123;<br>          <span class="hljs-comment">// 关闭输入输出流</span><br>            [_outputStream close];<br>            [_inputStream close];<br>            <br>            <span class="hljs-comment">// 移除 runloop</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSArray</span> *runLoop <span class="hljs-keyword">in</span> [_scheduledRunloops <span class="hljs-keyword">copy</span>]) &#123;<br>                [<span class="hljs-keyword">self</span> unscheduleFromRunLoop:[runLoop objcAtIndex:<span class="hljs-number">0</span>] forMode:[runLoop objcAtIndex:<span class="hljs-number">1</span>]];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (!_failed) &#123;<br>          <span class="hljs-comment">// 回调上层</span><br>            [<span class="hljs-keyword">self</span> _performDelegateBlock:^&#123;<br>                <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(webSocket:didCloseWithCode:reason:wasClean:)]) &#123;<br>                    [<span class="hljs-keyword">self</span>.delegate webSocket:<span class="hljs-keyword">self</span> didCloseWithCode:_closeCode reason:_closeReason wasClean:<span class="hljs-literal">YES</span>];<br>                &#125;<br>            &#125;];<br>        &#125;<br>        <br>        [<span class="hljs-keyword">self</span> _scheduleCleanup];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>pumpWriting 完成了从输出缓存区到输出流的数据写入，剩下的就是输出流将数据发送到服务端的 Input，底层已经帮我们处理了。</p><h2 id="关闭连接-v2">关闭连接</h2><p>查看 SRWebSocket 的头文件会发现，监听 webSocket 异常关闭的方法有两个。</p><figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)webSocket:(SRWebSocket *)webSocket didFailWithError:(<span class="hljs-built_in">NSError</span> *)error;<br>- (<span class="hljs-type">void</span>)webSocket:(SRWebSocket *)webSocket didCloseWithCode:(<span class="hljs-built_in">NSInteger</span>)code reason:(<span class="hljs-built_in">NSString</span> *)reason wasClean:(<span class="hljs-type">BOOL</span>)wasClean;<br></code></pre></div></td></tr></table></figure><p>查看源码会发现 didCloseWithCode 一般处理的是部分协议规定的 webSocket 状态码，而 didFailWithError 一般处理 webSocket 在建连阶段的异常，比如 Header 解析异常、超时异常，以及一些输入输出流的异常报错。可以理解为常见的 webSocket 协议的状态异常由 didCloseWithCode 回调，其他情况则由 didFailWithError 覆盖。正如前面提到的，两端关闭 webSocket 连接不能只是单纯的断开 TCP，需两端在 webSocket 层面协商后再执行。SRWebSocket 在处理客户端主动断开时，只是向服务端发送 Close 帧，然后等待服务端返回 Close 后再清理资源断开连接。</p><h1>封装 SRWebSocket</h1><p>之前公司使用 SRWebSocket 有几个需求，一是需要在 TCP 连接前先做 DNS 预解析，二是需要给 webSocket 各阶段做行为打点统计耗时，三是添加重连功能。实现思路是在 SRWebSocket 层加入 DNS 预解析，调整建连顺序，添加几个 SR_ReadyState，虽然这不是按协议标准。重连和打点则单独封装一层来做，尽量少去修改 SRWebSocket 源码。最终的 Repo 地址：<a href="https://github.com/XiaopingSun/XPWebSocket">XPWebSocket</a></p><h1>后记</h1><p>SRWebSocket 这篇博客算是一个心结吧，从我牛离职后，总感觉有什么事情没有做完，现在心结已了，很开心！之后要继续学习自己喜欢的音视频开发了，也会把学到的东西第一时间在这里更新，加油吧骚年！</p>]]></content>
    
    
    <categories>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webSocket</tag>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac环境编译rtmpdump</title>
    <link href="/2021/09/16/Mac%E7%8E%AF%E5%A2%83%E7%BC%96%E8%AF%91rtmpdump/"/>
    <url>/2021/09/16/Mac%E7%8E%AF%E5%A2%83%E7%BC%96%E8%AF%91rtmpdump/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>最近一直在学习流媒体的 rtmp 协议，想结合 librtmp 的源码看下协议具体实现，但下载后 make 发现各种问题，而且项目里没有 configure 和 cmake，只有一个 Makefile，所以又补习了 Makefile 的常用写法，这个<a href="https://blog.csdn.net/weixin_38391755/article/details/80380786">Makefile教程</a>相当不错，可以当做小手册来查。</p><h1>踩坑开始</h1><p>首先准备 github 环境，将 rtmpdump 工程 clone 到本地 <a href="https://github.com/mstorsjo/rtmpdump">https://github.com/mstorsjo/rtmpdump</a></p><p><code>git clone git@github.com:mstorsjo/rtmpdump.git</code></p><p>工程目录很简单，源代码文件很少，文件夹层级只有两层，librtmp 文件夹是 librtmp.a 库的源码文件，rtmpdump 根目录下是 rtmp 命令行工具的源码文件。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">.<br>├── COPYING<br>├── ChangeLog<br>├── Makefile<br>├── README<br>├── librtmp<br>│   ├── COPYING<br>│   ├── Makefile<br>│   ├── amf.c<br>│   ├── amf.h<br>│   ├── bytes.h<br>│   ├── dh.h<br>│   ├── dhgroups.h<br>│   ├── handshake.h<br>│   ├── hashswf.c<br>│   ├── http.h<br>│   ├── librtmp.3<br>│   ├── librtmp.3.html<br>│   ├── librtmp.pc.in<br>│   ├── log.c<br>│   ├── log.h<br>│   ├── parseurl.c<br>│   ├── rtmp.c<br>│   ├── rtmp.h<br>│   └── rtmp_sys.h<br>├── rtmpdump.1<br>├── rtmpdump.1.html<br>├── rtmpdump.c<br>├── rtmpgw.8<br>├── rtmpgw.8.html<br>├── rtmpgw.c<br>├── rtmpsrv.c<br>├── rtmpsuck.c<br>├── thread.c<br>└── thread.h<br></code></pre></div></td></tr></table></figure><p>文件夹首层和 librtmp 文件夹内都有一个 Makefile，这是个嵌套结构，一般只需要在根目录 make 即可，会先编译 librtmp.a 再编译命令行工具。</p><p>查看 github 的 <a href="http://readme.md">readme.md</a> 发现，mac 环境编译需要携带参数 SYS=darwin，然后我们开始编译：</p><p><code>make SYS=darwin</code></p><p>但运行后报错，无法找到openssl：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">gcc -Wall   -DRTMPDUMP_VERSION=\&quot;v2.4\&quot; -DUSE_OPENSSL  -O2 -fPIC   -c -o rtmp.o rtmp.c<br>rtmp.c:60:10: fatal error: <span class="hljs-string">&#x27;openssl/ssl.h&#x27;</span> file not found<br><span class="hljs-comment">#include &lt;openssl/ssl.h&gt;</span><br>         ^~~~~~~~~~~~~~~<br>1 error generated.<br>make[1]: *** [rtmp.o] Error 1<br>make: *** [librtmp/librtmp.a] Error 2<br></code></pre></div></td></tr></table></figure><p>查看 Makefile 发现是编译 librtmp 所需的 rtmp.c 中引用了 openssl，并且在编译时找不到链接库。openssl 是我用 brew install 安装的，并不在系统默认的目录下，而且 rtmpdump 是很久之前的代码，新版本的 openssl 会有兼容性问题，所以建议到官网下载 openssl 历史版本，这里用的是 <a href="https://www.openssl.org/source/old/0.9.x/openssl-0.9.8x.tar.gz">openssl 0.9.8x</a>。</p><p>下载好 openssl 之后进入到根目录，之后配置 configure 并 make:</p><p><code>./configure darwin64-x86_64-cc no-shared</code></p><p><code>make</code></p><p>查看 librtmp 文件夹内的 Makefile 文件发现有两个变量可以在调用 make 时将 openssl 的头文件和库文件的路径索引传进来，因此 cd 回 rtmpdump 根目录重新 make，将刚刚编译好的 openssl 的路径传递进来:</p><p><code>make SYS=darwin XCFLAGS='-I/Users/workspace_sun/Downloads/openssl-0.9.8x/include' XLDFLAGS='-L/Users/workspace_sun/Downloads/openssl-0.9.8x'</code></p><p>这次没有再报错了，有几个 warning 不知道是否会影响使用，但 librtmp.a 已经编译出来了，rtmpdump 根目录也多了4个可执行文件：rtmpdump、rtmpgw、rtmpsrv、rtmpsuck</p><h1>结语</h1><p>至此 Mac 平台的 rtmpdump 就编译好了，虽然很过程不太顺利，但也学到了 Makefile 的一些常用语法，不过手写起来确实不是很方便，如果是我我应该会选cmake。。。</p>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rtmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Markdown常用语法总结</title>
    <link href="/2021/09/15/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/09/15/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1>基础语法</h1><h2 id="字体">字体</h2><h3 id="标题">标题</h3><ul><li>使用底线的语法</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">我是一级标题</span><br><span class="hljs-section">=========</span><br></code></pre></div></td></tr></table></figure><p>或</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">我是二级标题</span><br><span class="hljs-section">---------</span><br></code></pre></div></td></tr></table></figure><blockquote><p>注：这种语法只支持两级标题</p></blockquote><ul><li>使用#的语法（推荐）</li></ul><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean"># 我是一级标题<br>## 我是二级标题<br>### 我是三级标题<br>#### 我是四级标题  <br>##### 我是五级标题<br>###### 我是六级标题<br></code></pre></div></td></tr></table></figure><blockquote><p>注：这种语法只支持六级标题</p></blockquote><h3 id="粗体和斜体">粗体和斜体</h3><ul><li>粗体格式的语法如下</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-strong">**加粗内容**</span>（推荐）<br></code></pre></div></td></tr></table></figure><p>或</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima"><span class="hljs-symbol">__</span>加粗内容<span class="hljs-symbol">__</span><br></code></pre></div></td></tr></table></figure><ul><li>斜体格式的语法如下</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体内容*</span>（推荐）<br></code></pre></div></td></tr></table></figure><p>或</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-literal">_</span>斜体内容<span class="hljs-literal">_</span><br></code></pre></div></td></tr></table></figure><h2 id="段落与换行">段落与换行</h2><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">片段<span class="hljs-number">1</span><span class="hljs-selector-attr">[空格]</span><span class="hljs-selector-attr">[空格]</span><span class="hljs-selector-attr">[回车]</span><br>片段<span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>片段1<br>片段2</p><h2 id="分割线">分割线</h2><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">星号</span><br><span class="hljs-string">***</span><br><span class="hljs-string">*</span> <span class="hljs-string">*</span> <span class="hljs-string">*</span><br><span class="hljs-string">*********</span><br><span class="hljs-string">减号</span><br><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-bullet">-</span> <span class="hljs-bullet">-</span><br><span class="hljs-string">---------</span><br><span class="hljs-string">下划线</span><br><span class="hljs-string">___</span><br><span class="hljs-string">_</span> <span class="hljs-string">_</span> <span class="hljs-string">_</span><br><span class="hljs-string">_________</span><br></code></pre></div></td></tr></table></figure><p>星号</p><hr><hr><hr><p>横杠</p><hr><hr><hr><p>下划线</p><hr><hr><hr><h2 id="删除线">删除线</h2><figure class="highlight haml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haml">~~被删除的文字~~<br></code></pre></div></td></tr></table></figure><p><s>被删除的文字</s></p><h2 id="下划线">下划线</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>下划线文字<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><u>下划线文字</u></p><h2 id="转义">转义</h2><ul><li>语法如下</li></ul><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript"><span class="hljs-string">\特殊符号</span><br></code></pre></div></td></tr></table></figure><ul><li>特殊符号如下</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">\   反斜线<br>`   反引号<br><span class="hljs-bullet">*   </span>星号<br>_   下划线<br>&#123;&#125;  花括号<br>[]  方括号<br>()  小括号<br>#   井字号<br>+   加号<br><span class="hljs-bullet">-   </span>减号<br><span class="hljs-bullet">.   </span>英文句点<br>!   感叹号<br></code></pre></div></td></tr></table></figure><ul><li>Example:</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">\*\* 正常显示星号 \*\* <br></code></pre></div></td></tr></table></figure><p>** 正常显示星号 **</p><h2 id="表情符号">表情符号</h2><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-meta">:smile:</span><br><span class="hljs-meta">:laughing:</span><br><span class="hljs-meta">:clap:</span><br></code></pre></div></td></tr></table></figure><p>😄<br>😆<br>👏</p><p>其他表情符号参考<a href="https://sunhwee.com/posts/a927e90e.html">Markdown Emoji表情语法速查表</a></p><h2 id="列表">列表</h2><h3 id="无序列表">无序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 第一项<br><span class="hljs-bullet">*</span> 第二项<br><span class="hljs-bullet">*</span> 第三项<br><br><span class="hljs-bullet">+</span> 第一项<br><span class="hljs-bullet">+</span> 第二项<br><span class="hljs-bullet">+</span> 第三项<br><br><span class="hljs-bullet">-</span> 第一项<br><span class="hljs-bullet">-</span> 第二项<br><span class="hljs-bullet">-</span> 第三项<br></code></pre></div></td></tr></table></figure><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h3 id="有序列表">有序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项<br><span class="hljs-bullet">2.</span> 第二项<br><span class="hljs-bullet">3.</span> 第三项<br></code></pre></div></td></tr></table></figure><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="嵌套列表">嵌套列表</h3><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 第一项<br><span class="hljs-bullet">    1.</span> 第一子项<br><span class="hljs-bullet">    2.</span> 第二子项<br><span class="hljs-bullet">    3.</span> 第三子项<br><span class="hljs-bullet">-</span> 第二项<br><span class="hljs-bullet">-</span> 第三项<br></code></pre></div></td></tr></table></figure><ul><li>第一项<ol><li>第一子项</li><li>第二子项</li><li>第三子项</li></ol></li><li>第二项</li><li>第三项</li></ul><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项<br><span class="hljs-bullet">    -</span> 第一子项<br><span class="hljs-bullet">    -</span> 第二子项<br><span class="hljs-bullet">    -</span> 第三子项<br><span class="hljs-bullet">2.</span> 第二项<br><span class="hljs-bullet">3.</span> 第三项<br></code></pre></div></td></tr></table></figure><ol><li>第一项<ul><li>第一子项</li><li>第二子项</li><li>第三子项</li></ul></li><li>第二项</li><li>第三项</li></ol><h2 id="链接">链接</h2><h3 id="文字链接">文字链接</h3><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">在日常工作中我们经常使用的网址有[Google](<span class="hljs-link">https://www.google.com/)、</span>[<span class="hljs-string">Github</span>](<span class="hljs-link">https://github.com/)和</span>[<span class="hljs-string">Stack Overflow</span>]（https://stackoverflow.com/）<br></code></pre></div></td></tr></table></figure><p>在日常工作中我们经常使用的网址有<a href="https://www.google.com/">Google</a>、<a href="https://github.com/">Github</a>和<a href="https://stackoverflow.com/">Stack Overflow</a></p><h3 id="网址链接">网址链接</h3><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">博客地址&lt;https:<span class="hljs-regexp">//</span>blog.pursue.top/&gt;<br></code></pre></div></td></tr></table></figure><p>博客地址<a href="https://blog.pursue.top/">https://blog.pursue.top/</a></p><blockquote><p>注: 扩展语法GFM中&lt;&gt;可省略</p></blockquote><h2 id="图片">图片</h2><h3 id="图片链接">图片链接</h3><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade">![个人头像](<span class="hljs-regexp">/resources/im</span>age/portrait.png)  <br></code></pre></div></td></tr></table></figure><p><img src="/resources/image/portrait.png" alt="个人头像"></p><h3 id="图片标签">图片标签</h3><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;/resources/image/portrait.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;50%&quot;</span>&gt;  <br></code></pre></div></td></tr></table></figure><img src="/resources/image/portrait.png" width="50%">  <h2 id="支持的HTML元素">支持的HTML元素</h2><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">使用 &lt;<span class="hljs-selector-tag">kbd</span>&gt;Ctrl&lt;/<span class="hljs-selector-tag">kbd</span>&gt;+&lt;<span class="hljs-selector-tag">kbd</span>&gt;Alt&lt;/<span class="hljs-selector-tag">kbd</span>&gt;+&lt;<span class="hljs-selector-tag">kbd</span>&gt;<span class="hljs-selector-tag">Del</span>&lt;/<span class="hljs-selector-tag">kbd</span>&gt; 重启电脑 <br></code></pre></div></td></tr></table></figure><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h2 id="引用与区块">引用与区块</h2><h3 id="引用">引用</h3><figure class="highlight node-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">这是一个引用</span><br></code></pre></div></td></tr></table></figure><blockquote><p>这是一个引用</p></blockquote><h3 id="区块">区块</h3><ul><li>区块嵌套</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">第一层</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt; 第二层</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; 第三层</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt; 第四层</span><br></code></pre></div></td></tr></table></figure><blockquote><p>第一层</p><blockquote><p>第二层</p><blockquote><p>第三层</p><blockquote><p>第四层</p></blockquote></blockquote></blockquote></blockquote><ul><li>区块中使用列表</li></ul><figure class="highlight node-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1.</span> 第一项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2.</span> 第二项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">- 第一项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">- 第二项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">- 第三项</span><br></code></pre></div></td></tr></table></figure><blockquote><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><ul><li>列表中使用区块</li></ul><figure class="highlight nestedtext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nestedtext">1. 第一项<br>    <span class="hljs-punctuation">&gt;</span> <span class="hljs-string">菜鸟教程</span><br>    <span class="hljs-punctuation">&gt;</span> <span class="hljs-string">&gt; 学的不仅是技术</span><br>    <span class="hljs-punctuation">&gt;</span> <span class="hljs-string">&gt;</span><br>    <span class="hljs-punctuation">&gt;</span> <span class="hljs-string">&gt; &gt; 更是梦想</span><br>2. 第二项<br></code></pre></div></td></tr></table></figure><ol><li>第一项<blockquote><p>菜鸟教程</p><blockquote><p>学的不仅是技术</p><blockquote><p>更是梦想</p></blockquote></blockquote></blockquote></li><li>第二项</li></ol><h2 id="fluid-主题便签">fluid 主题便签</h2><p>在 markdown 中加入如下的代码来使用便签：</p><figure class="highlight django"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">note</span> success %&#125;</span><span class="language-xml"></span><br><span class="language-xml">文字 或者 &#x27;markdown&#x27; 均可</span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">endnote</span> %&#125;</span><br></code></pre></div></td></tr></table></figure><p>或者使用 HTML 形式：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>&gt;</span>标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>可选便签：</p><div class="note note-primary">            <p>primary</p>          </div><div class="note note-secondary">            <p>secondary</p>          </div><div class="note note-success">            <p>success</p>          </div><div class="note note-danger">            <p>danger</p>          </div><div class="note note-warning">            <p>warning</p>          </div><div class="note note-info">            <p>info</p>          </div><div class="note note-light">            <p>light</p>          </div><h2 id="表格">表格</h2><h3 id="表格格式">表格格式</h3><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">|<span class="hljs-string"> 序号 </span>|<span class="hljs-string"> 标题 </span>|<span class="hljs-string"> 网址 </span>|<br>|<span class="hljs-string"> ------ </span>|<span class="hljs-string"> ------ </span>|<span class="hljs-string"> ------ </span>|<br>|<span class="hljs-string"> 01 </span>|<span class="hljs-string"> 博客 </span>|<span class="hljs-string"> https://blog.pursue.top/ </span>|<br>|<span class="hljs-string"> 02 </span>|<span class="hljs-string"> 微博 </span>|<span class="hljs-string"> https://weibo.com/u/2270909331 </span>|<br></code></pre></div></td></tr></table></figure><table><thead><tr><th>序号</th><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>01</td><td>博客</td><td><a href="https://blog.pursue.top/">https://blog.pursue.top/</a></td></tr><tr><td>02</td><td>微博</td><td><a href="https://weibo.com/u/2270909331">https://weibo.com/u/2270909331</a></td></tr></tbody></table><h3 id="表格内使用其他标记">表格内使用其他标记</h3><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">|<span class="hljs-string"> 序号 </span>|<span class="hljs-string"> 标题 </span>|<span class="hljs-string"> 网址 </span>|<br>|<span class="hljs-string"> ------ </span>|<span class="hljs-string"> ------ </span>|<span class="hljs-string"> ------ </span>|<br>|<span class="hljs-string"> *01* </span>|<span class="hljs-string"> [博客](https://blog.pursue.top/) </span>|<span class="hljs-string"> https://blog.pursue.top/ </span>|<br>|<span class="hljs-string"> **02** </span>|<span class="hljs-string"> [微博](https://weibo.com/u/2270909331) </span>|<span class="hljs-string"> https://weibo.com/u/2270909331 </span>|<br></code></pre></div></td></tr></table></figure><table><thead><tr><th>序号</th><th>标题</th><th>网址</th></tr></thead><tbody><tr><td><em>01</em></td><td><a href="https://blog.pursue.top/">博客</a></td><td><a href="https://blog.pursue.top/">https://blog.pursue.top/</a></td></tr><tr><td><strong>02</strong></td><td><a href="https://weibo.com/u/2270909331">微博</a></td><td><a href="https://weibo.com/u/2270909331">https://weibo.com/u/2270909331</a></td></tr></tbody></table><h2 id="代码">代码</h2><h3 id="行内代码">行内代码</h3><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade"><span class="hljs-string">`Hello, world!`</span><br></code></pre></div></td></tr></table></figure><p><code>Hello, world!</code></p><h3 id="代码块">代码块</h3><ul><li>Tab或4个空格开头的代码块</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">[Tab]<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>符号包裹的代码块（推荐）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">```<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br>```<br></code></pre></div></td></tr></table></figure><p>或</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">~~~<br>int main(int argc, char * argv[]) &#123;<br><span class="hljs-code">printf(&quot;Hello, World!&quot;);</span><br><span class="hljs-code">return 0;</span><br><span class="hljs-section">&#125;;</span><br><span class="hljs-section">~~~</span><br></code></pre></div></td></tr></table></figure><ul><li>语法高亮（C语言为例）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">``` <span class="hljs-function">c</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br>```<br></code></pre></div></td></tr></table></figure><ul><li>实际效果</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1>数学公式</h1><p>To Do</p><h1>流程图表</h1><p>To Do</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
