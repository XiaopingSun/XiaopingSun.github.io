

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://hexo.qiniu.pursue.top/%E9%9F%B3%E4%B9%90.png">
  <link rel="icon" href="https://hexo.qiniu.pursue.top/%E9%9F%B3%E4%B9%90.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="XpSun">
  <meta name="keywords" content="IT技术博客 电吉他 生活">
  
    <meta name="description" content="前言 今天是 2022 年 4 月 3 日，博客搭建完成后已经大半年没有记录过了，上次是去年 9 月份，接着 10 月初转岗到 SDK 部门，到今年 3 月底离职，刚好半年时间。这半年好像忙的也没有什么时间静下来写写博客，借着疫情居家这段时间，重新搭了下博客页面，打算好好记录一下，学到的技术和日常生活。说到 webSocket，其实背景是七牛的实时音视频 SDK 使用了 SRWebSocket 与">
<meta property="og:type" content="article">
<meta property="og:title" content="SRWebSocket源码分析记录">
<meta property="og:url" content="https://blog.pursue.top/2022/04/03/SRWebSocket%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="XpSun&#39;s Blog">
<meta property="og:description" content="前言 今天是 2022 年 4 月 3 日，博客搭建完成后已经大半年没有记录过了，上次是去年 9 月份，接着 10 月初转岗到 SDK 部门，到今年 3 月底离职，刚好半年时间。这半年好像忙的也没有什么时间静下来写写博客，借着疫情居家这段时间，重新搭了下博客页面，打算好好记录一下，学到的技术和日常生活。说到 webSocket，其实背景是七牛的实时音视频 SDK 使用了 SRWebSocket 与">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hexo.qiniu.pursue.top/websocket.png">
<meta property="article:published_time" content="2022-04-03T03:21:07.000Z">
<meta property="article:modified_time" content="2025-04-09T05:08:37.320Z">
<meta property="article:author" content="XpSun">
<meta property="article:tag" content="webSocket">
<meta property="article:tag" content="网络协议">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://hexo.qiniu.pursue.top/websocket.png">
  
  
  <title>SRWebSocket源码分析记录 - XpSun&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-dark-dimmed.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"blog.pursue.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":80,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"https://hexo.qiniu.pursue.top/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>XpSun&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://hexo.qiniu.pursue.top/SC01C11.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="SRWebSocket源码分析记录">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-03 11:21" pubdate>
        2022年4月3日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      46k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      384 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">SRWebSocket源码分析记录</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2025年4月9日 下午
                
              </p>
            
            <div class="markdown-body">
              <h1>前言</h1>
<p>今天是 2022 年 4 月 3 日，博客搭建完成后已经大半年没有记录过了，上次是去年 9 月份，接着 10 月初转岗到 SDK 部门，到今年 3 月底离职，刚好半年时间。这半年好像忙的也没有什么时间静下来写写博客，借着疫情居家这段时间，重新搭了下博客页面，打算好好记录一下，学到的技术和日常生活。说到 webSocket，其实背景是七牛的实时音视频 SDK 使用了 SRWebSocket 与服务端交互信令，由于业务需求需要给 SRWebSocket 添加一些功能，比如 DNS 预解析、重连策略、webSocket 各阶段打点，所以就详细读了 SRWebSocket 源码，了解了 webSocket 协议。</p>
<h1>webSocket 协议简介</h1>
<p>webSocket 诞生前，如果要在客户端和服务端之间实现双向通信，通常的做法是客户端 HTTP 轮询服务端接口，这样不仅效率低，会消耗大量流量，而且也不能保证服务端消息第一时间传递给客户端，算不上是真正意义的双向通信，而这也是 webSocket 出现的原因。webSocket 协议被设计来取代现有 HTTP 轮询方式实现双向通信，它和 HTTP 的区别在于，webSocket 不再遵循客户端主动发起请求，服务端回复响应的 Request-Response 机制，而是可以在客户端没有发送请求的情况下，服务端也可以主动发送数据给客户端，仅使用一个 TCP 连接就实现真正意义的双向通讯。同时，webSocket 将消息打包成一个个帧序列，与冗长的 HTTP 请求体相比消耗更少的流量。</p>
<p><img src="https://hexo.qiniu.pursue.top/websocket-http.webp" srcset="https://hexo.qiniu.pursue.top/loading.gif" lazyload alt="http 轮询和 websocket 对比"></p>
<p>webSocket 和 HTTP 一样属于应用层协议，协议 scheme 是  <code>ws://</code> 和 <code>wss://</code> ，默认端口是 80 和 443，其交互过程包含以下阶段：</p>
<p>建立 TCP 连接、SSL 握手（如果有）、webSocket 握手、发送数据帧和关闭连接。</p>
<h2 id="建立-TCP-连接">建立 TCP 连接</h2>
<p>上面提到 webSocket 只使用了一个 TCP 连接，那首先是要与服务端建立这个 TCP 连接。</p>
<p><img src="https://hexo.qiniu.pursue.top/tcp-connect.png" srcset="https://hexo.qiniu.pursue.top/loading.gif" lazyload alt="TCP 连接"></p>
<h2 id="SSL-握手（如果有）">SSL 握手（如果有）</h2>
<p>如果协议头是 <code>wss://</code>，默认会在建立 TCP 连接后，webSocket 握手前，获取服务端证书并校验，SSL 握手完成后后续请求会使用协商后的加密算法。SRWebSocket 源码支持未授信证书和自签证书的导入验证。</p>
<p><img src="https://hexo.qiniu.pursue.top/ssl-handshake" srcset="https://hexo.qiniu.pursue.top/loading.gif" lazyload alt="SSL 握手"></p>
<h2 id="webSocket-握手">webSocket 握手</h2>
<p>webSocket 握手实际是一个 HTTP Upgrade 请求，使用 HTTP 的原因与 webSocket 默认端口设置为 80 或 443 是一样的，为了确保兼容性，80 和 443 是 HTTP 和 HTTPS 使用的端口，服务器一般都会开放，不至于被防火墙挡掉，而使用 HTTP 也好理解，就是使用一个大家通用的协议去协商一个不太通用的协议，方便协商过程中字段属性的传递，也便于解析协商结果。</p>
<h3 id="来自客户端的握手请求">来自客户端的握手请求</h3>
<figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/chat</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>server.example.com<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Sec-WebSocket-Key</span><span class="hljs-punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://example.com<br><span class="hljs-attribute">Sec-WebSocket-Protocol</span><span class="hljs-punctuation">: </span>chat, superchat<br><span class="hljs-attribute">Sec-WebSocket-Version</span><span class="hljs-punctuation">: </span>13<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>GET /chat HTTP/1.1</strong></li>
</ul>
<p>握手使用的 HTTP 版本至少是 1.1，请求方式是 GET，这里的 Path 可能需要解释下，一般客户端传入的 webSocket 地址可能会是 <code>ws://aaa.bbb.ccc/path</code>，实际用来建立 TCP 连接只需要 host 解析出的 IP 和根据协议名选取的默认端口号，<code>/path</code> 一般表示握手服务所在路径。</p>
<ul>
<li><strong>Host: <a target="_blank" rel="noopener" href="http://server.example.com">server.example.com</a></strong></li>
</ul>
<p>握手服务域名。</p>
<ul>
<li><strong>Upgrade: websocket</strong></li>
</ul>
<p>Upgrade 是 HTTP 协议中用于定义转换协议的 Header 域，它表示如果服务器支持的话，客户端希望从已建立好的连接协议，切换到另外一个应用层协议，这里是希望将协议切换成 webSocket。</p>
<ul>
<li><strong>Connection: Upgrade</strong></li>
</ul>
<p>需要将 Connection 设置为 Upgrade，指示该请求用于协议升级。</p>
<ul>
<li><strong>Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</strong></li>
</ul>
<p>Sec-WebSocket-Key 是客户端在请求前生成 16 位随机字符经过 Base64 编码后生成的24位字符，服务端收到后会对该字符串做处理后，通过头部字段 Sec-WebSocket-Accept 返回给客户端。</p>
<ul>
<li><strong>Origin: <a target="_blank" rel="noopener" href="http://example.com">http://example.com</a></strong></li>
</ul>
<p>用于标识原始域名，防止跨域攻击。</p>
<ul>
<li><strong>Sec-WebSocket-Protocol: chat, superchat</strong></li>
</ul>
<p>客户端支持的子协议列表，服务端需从数组中选择支持的协议并返回，如果都不支持，会导致握手失败。客户端也可不发送子协议，但一旦发送，需两端一致才能成功握手。</p>
<ul>
<li><strong>Sec-WebSocket-Version</strong></li>
</ul>
<p>客户端支持的协议版本，如果该版本没有匹配服务端理解的任何一个版本，需要握手失败。</p>
<p><img src="https://hexo.qiniu.pursue.top/handshake-req.png" srcset="https://hexo.qiniu.pursue.top/loading.gif" lazyload alt="handshake 请求"></p>
<h3 id="来自服务端的握手返回">来自服务端的握手返回</h3>
<figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Sec-WebSocket-Accept</span><span class="hljs-punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>HTTP/1.1 101 Switching Protocols</strong></li>
</ul>
<p>服务端返回 101 表示收到并同意将协议切换到 webSocket。</p>
<ul>
<li><strong>Upgrade: websocket</strong></li>
</ul>
<p>与客户端请求头一致。</p>
<ul>
<li><strong>Connection: Upgrade</strong></li>
</ul>
<p>与客户端请求头一致。</p>
<ul>
<li><strong>Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</strong></li>
</ul>
<p>服务端在收到客户端的 Sec-WebSocket-Key 之后，将 Sec-WebSocket-Key 拼接协议规定的字符串 <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code> 后，做一次 Sha-1 散列，接着 Base64 编码，得到的字符串作为 Sec-WebSocket-Accept 返回给客户端，而客户端要做的是将之前请求使用的 Sec-WebSocket-Key 按照服务端的流程做字符串处理后，与 Sec-WebSocket-Accept 比对，如果不匹配，需要握手失败。</p>
<p><img src="https://hexo.qiniu.pursue.top/handshake-resp.png" srcset="https://hexo.qiniu.pursue.top/loading.gif" lazyload alt="handshake 返回"></p>
<h2 id="数据帧">数据帧</h2>
<p>协议规定的 webSocket 帧组成部分：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin"> 0                   1                   2                   3<br> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br>+-+-+-+-+-------+-+-------------+-------------------------------+<br>|<span class="hljs-string">F</span>|<span class="hljs-string">R</span>|<span class="hljs-string">R</span>|<span class="hljs-string">R</span>|<span class="hljs-string"> opcode</span>|<span class="hljs-string">M</span>|<span class="hljs-string"> Payload len </span>|<span class="hljs-string">    Extended payload length    </span>|<br>|<span class="hljs-string">I</span>|<span class="hljs-string">S</span>|<span class="hljs-string">S</span>|<span class="hljs-string">S</span>|<span class="hljs-string">  (4)  </span>|<span class="hljs-string">A</span>|<span class="hljs-string">     (7)     </span>|<span class="hljs-string">             (16/64)           </span>|<br>|<span class="hljs-string">N</span>|<span class="hljs-string">V</span>|<span class="hljs-string">V</span>|<span class="hljs-string">V</span>|<span class="hljs-string">       </span>|<span class="hljs-string">S</span>|<span class="hljs-string">             </span>|<span class="hljs-string">   (if payload len==126/127)   </span>|<br>|<span class="hljs-string"> </span>|<span class="hljs-string">1</span>|<span class="hljs-string">2</span>|<span class="hljs-string">3</span>|<span class="hljs-string">       </span>|<span class="hljs-string">K</span>|<span class="hljs-string">             </span>|<span class="hljs-string">                               </span>|<br>+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +<br>|<span class="hljs-string">     Extended payload length continued, if payload len == 127  </span>|<br>+ - - - - - - - - - - - - - - - +-------------------------------+<br>|<span class="hljs-string">                               </span>|<span class="hljs-string">Masking-key, if MASK set to 1  </span>|<br>+-------------------------------+-------------------------------+<br>|<span class="hljs-string"> Masking-key (continued)       </span>|<span class="hljs-string">          Payload Data         </span>|<br>+-------------------------------- - - - - - - - - - - - - - - - +<br>:                     Payload Data continued ...                :<br>+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +<br>|<span class="hljs-string">                     Payload Data continued ...                </span>|<br>+---------------------------------------------------------------+<br></code></pre></div></td></tr></table></figure>
<p>webSocket 的消息类型大致分为两种：数据类型和控制类型，数据类型的消息由于长度取决于消息内容本身，所以较长的数据消息会采取分帧策略，将一个数据消息拆分成若干个上述格式的数据帧，而控制类型的消息一般内容比较少，单帧就可以负载所有内容，不需要分帧。有些文档上解释成帧和片，为了避免混淆，本篇将指令单元用“消息”表示，发送单元用“帧”表示。下面看下帧内容：</p>
<ul>
<li>FIN</li>
</ul>
<p>1 bit，用于指使此帧是否是消息的最后片段，如果消息没有分帧，FIN 一定是 1。SRWebSocket 在解析消息的时候会使用 FIN 判断消息的结束。</p>
<ul>
<li>RSV1、RSV2、RSV3</li>
</ul>
<p>每个 1 bit，必须是 0，除非一个扩展协议将非0值定义含义。如果收到一个非 0 值且没有协商的扩展协议定义这个非 0 值的含义，接收端必须将 webSocket 连接视为失败。</p>
<ul>
<li>opcode</li>
</ul>
<p>4 bit，定义了该帧负载数据的类型，字段值和消息类型的对应关系如下：</p>
<figure class="highlight haml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">x0</span></span> 代表一个继续帧<br><span class="hljs-tag">%<span class="hljs-selector-tag">x1</span></span> 代表一个文本帧<br><span class="hljs-tag">%<span class="hljs-selector-tag">x2</span></span> 代表一个二进制帧<br><span class="hljs-tag">%<span class="hljs-selector-tag">x3</span></span>-7 保留用于未来的非控制帧<br><span class="hljs-tag">%<span class="hljs-selector-tag">x8</span></span> 代表连接关闭<br><span class="hljs-tag">%<span class="hljs-selector-tag">x9</span></span> 代表ping<br><span class="hljs-tag">%<span class="hljs-selector-tag">xA</span></span> 代表pong<br><span class="hljs-tag">%<span class="hljs-selector-tag">xB</span></span>-F 保留用于未来的控制帧	<br></code></pre></div></td></tr></table></figure>
<ul>
<li>MASK</li>
</ul>
<p>1 bit，定义了此帧负载数据是否是经过掩码的。如果设置为 1，会有 4 字节的 Masking-key 出现在 Payload 数据前面，如上图。客户端收到 MASK 为 1 的帧，需要解析 Masking-key 并按位对 Payload 做异或运算拿到掩码前的真实数据。另外协议规定从客户端发送到服务器的所有帧需要将 MASK 设置为 1，使用掩码。</p>
<ul>
<li>Payload len</li>
</ul>
<p>7 bit，定义了负载数据的长度，如果是 0 - 125，表示是真实的负载数据长度。如果是 126，之后的2字节（Extended payload length）是用来表示负载长度的 16 位无符号整数。如果是 127，之后的 8 字节（Extended payload length）是用来表示负载长度的 64 位无符号整数。这里遵循用最小字节数表示负载长度的原则。</p>
<ul>
<li>Extended payload length</li>
</ul>
<p>16 bit / 64 bit，如上所述，该字段是用在 Payload len 的 7 bit 不足以表示负载长度时，所占字节数依赖 Payload len 的值。</p>
<ul>
<li>Masking-key</li>
</ul>
<p>32 bit，当 MASK 为 1 时，该字段存在，MASK 为 0 时，该字段缺失。</p>
<ul>
<li>Payload Data</li>
</ul>
<p>负载数据。</p>
<h3 id="看个例子">看个例子</h3>
<p><img src="https://hexo.qiniu.pursue.top/websocket-wire.png" srcset="https://hexo.qiniu.pursue.top/loading.gif" lazyload alt="websocket 抓包"></p>
<p>这是一条服务端给客户端发送的 webSocket 消息，首先看它的 Opcode 是 1 并且 Fin 是 1，说明这条数据消息没有使用分帧策略。Mask 为 0 说明没有使用掩码，字段里也就没有 Masking key。Payload length 是 126，说明在 Payload length 之后有 2 字节的 Extended Payload Length 用来标识负载的真实长度。Extended Payload Length 标识负载长度是 277，我们用这个长度去解析 Payload。由于这条数据消息只有一个数据帧，因此我们解析完成后可以将消息直接回调给上层。</p>
<h2 id="关闭连接">关闭连接</h2>
<p>webSocket 的关闭并不只是简单的一端主动断开 TCP 连接，需要考虑本端和对端缓存里是否有未及时处理的数据，需要区分具体的情况，详细的可以参考官方文档：<a target="_blank" rel="noopener" href="https://chenjianlong.gitbooks.io/rfc-6455-websocket-protocol-in-chinese/content/section7/section7.html">关于如何关闭连接</a></p>
<h1>SRWebSocket 源码分析记录</h1>
<div class="note note-info">
            <p><a target="_blank" rel="noopener" href="https://github.com/facebookincubator/SocketRocket">SRWebSocket</a> 是 Facebook 提供的根据 webSocket 协议标准实现的 iOS 平台库，之前七牛 RTC 项目使用的是 0.5.1 版本，比较稳定，本篇也针对这一版本的代码做下基础分析。</p>
          </div>
<h2 id="外层调用">外层调用</h2>
<p>源码只有一个类 SRWebSocket，头文件里定义了一系列属性、初始化方法和回调，可以按需配置，我们引入这个头文件，使用姿势也很简单：</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-comment">// Do any additional setup after loading the view.</span><br>        <br>    <span class="hljs-built_in">NSURLRequest</span> *request = [<span class="hljs-built_in">NSURLRequest</span> requestWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;ws://%@:%@&quot;</span>, server, port]]];<br>    _webSocket = [[SRWebSocket alloc] initWithURLRequest:request];<br>    _webSocket.delegate = <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">IBAction</span>)open:(<span class="hljs-built_in">UIButton</span> *)sender &#123;<br>    [_webSocket open];<br>&#125;<br><br>- (<span class="hljs-keyword">IBAction</span>)close:(<span class="hljs-built_in">UIButton</span> *)sender &#123;<br>    [_webSocket close];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - SRWebSocketDelegate</span><br>- (<span class="hljs-type">void</span>)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(<span class="hljs-type">id</span>)message &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;SRWebSocket didReceiveMessage: %@&quot;</span>, message);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)webSocketDidOpen:(SRWebSocket *)webSocket&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;SRWebSocket webSocketDidOpen&quot;</span>);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)webSocket:(SRWebSocket *)webSocket didFailWithError:(<span class="hljs-built_in">NSError</span> *)error &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;SRWebSocket didFailWithError: %@&quot;</span>, error);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)webSocket:(SRWebSocket *)webSocket didCloseWithCode:(<span class="hljs-built_in">NSInteger</span>)code reason:(<span class="hljs-built_in">NSString</span> *)reason wasClean:(<span class="hljs-type">BOOL</span>)wasClean &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;SRWebSocket didCloseWithCode: %ld  reason: %@&quot;</span>, code, reason);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>接下来我们看下源码内部。</p>
<h2 id="初始化">初始化</h2>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">id</span>)initWithURLRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request protocols:(<span class="hljs-built_in">NSArray</span> *)protocols allowsUntrustedSSLCertificates:(<span class="hljs-type">BOOL</span>)allowsUntrustedSSLCertificates;<br>&#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        assert(request.URL);<br>        _url = request.URL;<br>        _urlRequest = request;<br>        _allowsUntrustedSSLCertificates = allowsUntrustedSSLCertificates;<br>        <br>        _requestedProtocols = [protocols <span class="hljs-keyword">copy</span>];<br>        <br>        [<span class="hljs-keyword">self</span> _SR_commonInit];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>Init 方法初始化一些属性变量，url 保存 webSocket 地址，requestedProtocols 保存客户端定义的子协议，allowsUntrustedSSLCertificates 标识是否允许未授信的证书，如果设置为 YES，会在连接中忽略证书链的校验。接下来调用了 SR_commonInit 方法做进一步初始化。</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_SR_commonInit;<br>&#123;<br>  	<span class="hljs-comment">// 如果协议不是 ws、http、wss、https，assert</span><br>    <span class="hljs-built_in">NSString</span> *scheme = _url.scheme.lowercaseString;<br>    assert([scheme isEqualToString:<span class="hljs-string">@&quot;ws&quot;</span>] || [scheme isEqualToString:<span class="hljs-string">@&quot;http&quot;</span>] || [scheme isEqualToString:<span class="hljs-string">@&quot;wss&quot;</span>] || [scheme isEqualToString:<span class="hljs-string">@&quot;https&quot;</span>]);<br>    <br>  	<span class="hljs-comment">// 判断是否是安全连接</span><br>    <span class="hljs-keyword">if</span> ([scheme isEqualToString:<span class="hljs-string">@&quot;wss&quot;</span>] || [scheme isEqualToString:<span class="hljs-string">@&quot;https&quot;</span>]) &#123;<br>        _secure = <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <br>  	<span class="hljs-comment">// 更新状态 - 连接中</span><br>    _readyState = SR_CONNECTING;<br>  <br>  	<span class="hljs-comment">// 消费者是否都已停止   该字段未使用</span><br>    _consumerStopped = <span class="hljs-literal">YES</span>;<br>  <br>  	<span class="hljs-comment">// 标识客户端使用的 webSocket 版本</span><br>    _webSocketVersion = <span class="hljs-number">13</span>;<br>    <br>  	<span class="hljs-comment">// 初始化读写控制队列  串行</span><br>    _workQueue = dispatch_queue_create(<span class="hljs-literal">NULL</span>, DISPATCH_QUEUE_SERIAL);<br>    <br>    <span class="hljs-comment">// Going to set a specific on the queue so we can validate we&#x27;re on the work queue</span><br>    dispatch_queue_set_specific(_workQueue, (__bridge <span class="hljs-type">void</span> *)<span class="hljs-keyword">self</span>, maybe_bridge(_workQueue), <span class="hljs-literal">NULL</span>);<br>    <br>  	<span class="hljs-comment">// 获取回调队列  主线程</span><br>    _delegateDispatchQueue = dispatch_get_main_queue();<br>    sr_dispatch_retain(_delegateDispatchQueue);<br>    <br>  	<span class="hljs-comment">// 初始化读写缓存</span><br>    _readBuffer = [[<span class="hljs-built_in">NSMutableData</span> alloc] init];<br>    _outputBuffer = [[<span class="hljs-built_in">NSMutableData</span> alloc] init];<br>    <br>  	<span class="hljs-comment">// 初始化当前 opcode 下的 payload 缓存  一般只存放文本帧和二进制帧的 payload  拼接成完整消息后回调出去</span><br>    _currentFrameData = [[<span class="hljs-built_in">NSMutableData</span> alloc] init];<br><br>  	<span class="hljs-comment">// 初始化消费者工作队列</span><br>    _consumers = [[<span class="hljs-built_in">NSMutableArray</span> alloc] init];<br>    <br>  	<span class="hljs-comment">// 初始化消费者缓存池</span><br>    _consumerPool = [[SRIOConsumerPool alloc] init];<br>    <br>  	<span class="hljs-comment">// 初始化 runloop 缓存池</span><br>    _scheduledRunloops = [[<span class="hljs-built_in">NSMutableSet</span> alloc] init];<br>    <br>    [<span class="hljs-keyword">self</span> _initializeStreams];<br>    <br>    <span class="hljs-comment">// default handlers</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>SR_commonInit 方法里首先是校验了 Url 的协议是否是预期，判断是否是安全连接，初始化一些队列和线程，接着调用 initializeStreams 初始化输入输出的 stream。</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_initializeStreams;<br>&#123;<br>  	<span class="hljs-comment">// 判断端口号是否超过 32 位 unsigned int 大小</span><br>    assert(_url.port.unsignedIntValue &lt;= <span class="hljs-built_in">UINT32_MAX</span>);<br>    uint32_t port = _url.port.unsignedIntValue;<br>  <br>  	<span class="hljs-comment">// 如果端口没传，通过之前判断的 _secure 字段设置端口 80 或 443</span><br>    <span class="hljs-keyword">if</span> (port == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!_secure) &#123;<br>            port = <span class="hljs-number">80</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            port = <span class="hljs-number">443</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">NSString</span> *host = _url.host;<br>    <br>    <span class="hljs-built_in">CFReadStreamRef</span> readStream = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">CFWriteStreamRef</span> writeStream = <span class="hljs-literal">NULL</span>;<br>    <br>  	<span class="hljs-comment">// 通过 host 和 port 创建输入输出流</span><br>    <span class="hljs-built_in">CFStreamCreatePairWithSocketToHost</span>(<span class="hljs-literal">NULL</span>, (__bridge <span class="hljs-built_in">CFStringRef</span>)host, port, &amp;readStream, &amp;writeStream);<br>    <br>  	<span class="hljs-comment">// 将 CFReadStreamRef、CFWriteStreamRef 转成 oc 的 NSInputStream 和 NSOutputStream，释放所有权</span><br>    _outputStream = <span class="hljs-built_in">CFBridgingRelease</span>(writeStream);<br>    _inputStream = <span class="hljs-built_in">CFBridgingRelease</span>(readStream);<br>    <br>  	<span class="hljs-comment">// 设置输入输出流的代理</span><br>    _inputStream.delegate = <span class="hljs-keyword">self</span>;<br>    _outputStream.delegate = <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>initializeStreams 方法先是做了端口号校验，如果 Url 没传端口号，那么默认使用 80 或 443 端口，接着通过域名和端口号创建输入输出流，将 CoreFoundation 指针转成 OC 的对象，设置代理，输入输出流的事件会回调 handleEvent 方法。</p>
<h2 id="建立-TCP-连接、SSL-握手（如果有）">建立 TCP 连接、SSL 握手（如果有）</h2>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)open;<br>&#123;<br>    assert(_url);<br>  <br>  	<span class="hljs-comment">// 防止在 connecting 状态下多次 open</span><br>    <span class="hljs-built_in">NSAssert</span>(_readyState == SR_CONNECTING, <span class="hljs-string">@&quot;Cannot call -(void)open on SRWebSocket more than once&quot;</span>);<br><br>  	<span class="hljs-comment">// retain self 防止被释放造成野指针异常</span><br>    _selfRetain = <span class="hljs-keyword">self</span>;<br><br>  	<span class="hljs-comment">// 如果 _urlRequest 设置了超时时间，sr 内部是用 GCD 的 after 去计算超时时间，如果超过了 _urlRequest.timeoutInterval 之后 self.readyState 依然是 未连接成功 就会主动断开</span><br>    <span class="hljs-keyword">if</span> (_urlRequest.timeoutInterval &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, _urlRequest.timeoutInterval * <span class="hljs-built_in">NSEC_PER_SEC</span>);<br>        dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="hljs-type">void</span>)&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.readyState == SR_CONNECTING)<br>                [<span class="hljs-keyword">self</span> _failWithError:[<span class="hljs-built_in">NSError</span> errorWithDomain:<span class="hljs-string">@&quot;com.squareup.SocketRocket&quot;</span> code:<span class="hljs-number">504</span> userInfo:@&#123;<span class="hljs-built_in">NSLocalizedDescriptionKey</span>: <span class="hljs-string">@&quot;Timeout Connecting to Server&quot;</span>&#125;]];<br>        &#125;);<br>    &#125;<br><br>    [<span class="hljs-keyword">self</span> openConnection];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面的初始化方法完成后，外层就可以主动调用 open 打开连接了。可以看到 open 方法里使用 GCD 对超时时间做控制，如果需要定义超时时间，需要在初始化时的 NSURLRequest 对象里设置 timeoutInterval。open 方法最后调用 openConnection 去打开连接。</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)openConnection;<br>&#123;<br>  	<span class="hljs-comment">// 给输入输出流配置安全设置和网络类型</span><br>    [<span class="hljs-keyword">self</span> _updateSecureStreamOptions];<br>    <br>  	<span class="hljs-comment">// 给输入输出流绑定 runloop</span><br>    <span class="hljs-keyword">if</span> (!_scheduledRunloops.count) &#123;<br>        [<span class="hljs-keyword">self</span> scheduleInRunLoop:[<span class="hljs-built_in">NSRunLoop</span> SR_networkRunLoop] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 打开输入输出流   这里会与服务端做 tcp 连接  完成会回调 handleEvent 方法 NSStreamEventOpenCompleted 事件</span><br>    [_outputStream open];<br>    [_inputStream open];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>openConnection 方法先是调用 updateSecureStreamOptions 给输入输出流配置 SSL 和选取网络服务类型，接着给输入输出流绑定一个全局 runloop，最后打开输入输出流，与服务端建立 TCP 连接。</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_updateSecureStreamOptions;<br>&#123;<br>  	<span class="hljs-comment">// 如果 scheme 是 wss:// 需要给输出流配置 kCFStreamPropertySSLSettings</span><br>    <span class="hljs-keyword">if</span> (_secure) &#123;<br>        <span class="hljs-built_in">NSMutableDictionary</span> *SSLOptions = [[<span class="hljs-built_in">NSMutableDictionary</span> alloc] init];<br>        <br>      	<span class="hljs-comment">// 设置 ssl 安全级别</span><br>     		<span class="hljs-comment">//  Indicates to use TLS or SSL with fallback to lower versions. This is what HTTPS does, for instance. </span><br>        [_outputStream setProperty:(__bridge <span class="hljs-type">id</span>)kCFStreamSocketSecurityLevelNegotiatedSSL forKey:(__bridge <span class="hljs-type">id</span>)kCFStreamPropertySocketSecurityLevel];<br>        <br>      	<span class="hljs-comment">// 如果是自签证书 不验证证书链</span><br>        <span class="hljs-comment">// If we&#x27;re using pinned certs, don&#x27;t validate the certificate chain</span><br>        <span class="hljs-keyword">if</span> ([_urlRequest SR_SSLPinnedCertificates].count) &#123;<br>            [SSLOptions setValue:@NO forKey:(__bridge <span class="hljs-type">id</span>)kCFStreamSSLValidatesCertificateChain];<br>        &#125;<br>        <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>        <span class="hljs-keyword">self</span>.allowsUntrustedSSLCertificates = <span class="hljs-literal">YES</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>      	<span class="hljs-comment">// 如果设置允许使用未授信的证书 不验证证书链</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.allowsUntrustedSSLCertificates) &#123;<br>            [SSLOptions setValue:@NO forKey:(__bridge <span class="hljs-type">id</span>)kCFStreamSSLValidatesCertificateChain];<br>            SRFastLog(<span class="hljs-string">@&quot;Allowing connection to any root cert&quot;</span>);<br>        &#125;<br>        <br>        [_outputStream setProperty:SSLOptions<br>                            forKey:(__bridge <span class="hljs-type">id</span>)kCFStreamPropertySSLSettings];<br>    &#125;<br>    <br>    _inputStream.delegate = <span class="hljs-keyword">self</span>;<br>    _outputStream.delegate = <span class="hljs-keyword">self</span>;<br>    <br>  	<span class="hljs-comment">// 输入输出流设置网络服务类型</span><br>    [<span class="hljs-keyword">self</span> setupNetworkServiceType:_urlRequest.networkServiceType];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>updateSecureStreamOptions 主要是针对 SSL 的一些处理，如果 Url 的 scheme 是  <code>wss://</code> ，需要给输出流做 SSL 的相关配置，如果在初始化时传了自签证书或者设置了允许未授信证书，将不验证证书链，方法最后调用 setupNetworkServiceType 设置输入输出流的网络类型。</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)scheduleInRunLoop:(<span class="hljs-built_in">NSRunLoop</span> *)aRunLoop forMode:(<span class="hljs-built_in">NSString</span> *)mode;<br>&#123;<br>    [_outputStream scheduleInRunLoop:aRunLoop forMode:mode];<br>    [_inputStream scheduleInRunLoop:aRunLoop forMode:mode];<br>    <br>    [_scheduledRunloops addobjc:@[aRunLoop, mode]];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>scheduleInRunLoop 方法给输入输出流设置了 runloop 和 runloop mode，最后将 runloop 和 runloop mode 加入到缓存队列，我们看下这个 runloop 是哪里来的：</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">static</span> _SRRunLoopThread *networkThread = <span class="hljs-literal">nil</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSRunLoop</span> *networkRunLoop = <span class="hljs-literal">nil</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSRunLoop</span> (<span class="hljs-title">SRWebSocket</span>)</span><br><br>+ (<span class="hljs-built_in">NSRunLoop</span> *)SR_networkRunLoop &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        networkThread = [[_SRRunLoopThread alloc] init];<br>        networkThread.name = <span class="hljs-string">@&quot;com.squareup.SocketRocket.NetworkThread&quot;</span>;<br>        [networkThread start];<br>        networkRunLoop = networkThread.runLoop;<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> networkRunLoop;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在这个 NSRunLoop 的分类里定义了一个 networkThread 单例的初始化方法，单例携带一个 networkRunLoop，所以拿到的是一个常驻线程的 runloop，用于处理输入输出流的回调。</p>
<p>到此，SRWebSocket 源码使用的三个线程队列都已初始化完成，他们分别是：</p>
<ul>
<li><strong>networkThread</strong>：用于处理输入输出流并回调</li>
<li><strong>workQueue</strong>：SR 的主要工作队列，用于处理连接、输入输出流的读取等操作</li>
<li><strong>delegateOperationQueue</strong>：用于处理上层的回调</li>
</ul>
<p>输入输出流打开后，会与服务端尝试 TCP 连接并进行 SSL 握手，完成后会回调 handleEvent 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)stream:(<span class="hljs-built_in">NSStream</span> *)aStream handleEvent:(<span class="hljs-built_in">NSStreamEvent</span>)eventCode;<br>&#123;<br>    __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br>    <br>  	<span class="hljs-comment">// 这里处理自签证书的验证</span><br>    <span class="hljs-keyword">if</span> (_secure &amp;&amp; !_pinnedCertFound &amp;&amp; (eventCode == <span class="hljs-built_in">NSStreamEventHasBytesAvailable</span> || eventCode == <span class="hljs-built_in">NSStreamEventHasSpaceAvailable</span>)) &#123;<br>        <br>        <span class="hljs-built_in">NSArray</span> *sslCerts = [_urlRequest SR_SSLPinnedCertificates];<br>        <span class="hljs-keyword">if</span> (sslCerts) &#123;<br>            SecTrustRef secTrust = (__bridge SecTrustRef)[aStream propertyForKey:(__bridge <span class="hljs-type">id</span>)kCFStreamPropertySSLPeerTrust];<br>            <span class="hljs-keyword">if</span> (secTrust) &#123;<br>                <span class="hljs-built_in">NSInteger</span> numCerts = SecTrustGetCertificateCount(secTrust);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; numCerts &amp;&amp; !_pinnedCertFound; i++) &#123;<br>                    SecCertificateRef cert = SecTrustGetCertificateAtIndex(secTrust, i);<br>                    <span class="hljs-built_in">NSData</span> *certData = <span class="hljs-built_in">CFBridgingRelease</span>(SecCertificateCopyData(cert));<br>                    <br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">id</span> ref <span class="hljs-keyword">in</span> sslCerts) &#123;<br>                        SecCertificateRef trustedCert = (__bridge SecCertificateRef)ref;<br>                        <span class="hljs-built_in">NSData</span> *trustedCertData = <span class="hljs-built_in">CFBridgingRelease</span>(SecCertificateCopyData(trustedCert));<br>                        <br>                        <span class="hljs-keyword">if</span> ([trustedCertData isEqualToData:certData]) &#123;<br>                          	<span class="hljs-comment">// 如果服务端证书与本地自签证书匹配</span><br>                            _pinnedCertFound = <span class="hljs-literal">YES</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <br>          	<span class="hljs-comment">// 如果没有发现匹配的证书，需要将错误回调上层</span><br>            <span class="hljs-keyword">if</span> (!_pinnedCertFound) &#123;<br>                <span class="hljs-built_in">dispatch_async</span>(_workQueue, ^&#123;<br>                    <span class="hljs-built_in">NSDictionary</span> *userInfo = @&#123; <span class="hljs-built_in">NSLocalizedDescriptionKey</span> : <span class="hljs-string">@&quot;Invalid server cert&quot;</span> &#125;;<br>                    [weakSelf _failWithError:[<span class="hljs-built_in">NSError</span> errorWithDomain:<span class="hljs-string">@&quot;org.lolrus.SocketRocket&quot;</span> code:<span class="hljs-number">23556</span> userInfo:userInfo]];<br>                &#125;);<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aStream == _outputStream) &#123;<br>                <span class="hljs-built_in">dispatch_async</span>(_workQueue, ^&#123;<br>                   	<span class="hljs-comment">// 继续走握手流程</span><br>                    [<span class="hljs-keyword">self</span> didConnect];<br>                &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>  	<span class="hljs-comment">// 处理 event</span><br>    <span class="hljs-built_in">dispatch_async</span>(_workQueue, ^&#123;<br>        [weakSelf safeHandleEvent:eventCode stream:aStream];<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)safeHandleEvent:(<span class="hljs-built_in">NSStreamEvent</span>)eventCode stream:(<span class="hljs-built_in">NSStream</span> *)aStream<br>&#123;<br>        <span class="hljs-keyword">switch</span> (eventCode) &#123;<br>            <span class="hljs-comment">// 连接成功</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-built_in">NSStreamEventOpenCompleted</span>: &#123;<br>                SRFastLog(<span class="hljs-string">@&quot;NSStreamEventOpenCompleted %@&quot;</span>, aStream);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.readyState &gt;= SR_CLOSING) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                assert(_readBuffer);<br>                <br>              	<span class="hljs-comment">// 除自签证书外的其他情况  会走到这里的 didConnect 方法进行握手</span><br>                <span class="hljs-comment">// didConnect fires after certificate verification if we&#x27;re using pinned certificates.</span><br>                <span class="hljs-type">BOOL</span> usingPinnedCerts = [[_urlRequest SR_SSLPinnedCertificates] count] &gt; <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> ((!_secure || !usingPinnedCerts) &amp;&amp; <span class="hljs-keyword">self</span>.readyState == SR_CONNECTING &amp;&amp; aStream == _inputStream) &#123;<br>                    [<span class="hljs-keyword">self</span> didConnect];<br>                &#125;<br>...<br></code></pre></div></td></tr></table></figure>
<p>handleEvent 方法里的代码是对自签证书的验证，在两端 TCP 连接完成后，将服务端证书与传入的自签证书一一比对，如果发现匹配就继续下一步的握手操作，如果没有匹配，则验证失败回调上层。实际 event 事件的处理是在 safeHandleEvent 里，在监听到 NSStreamEventOpenCompleted 事件后，除自签证书这种情况外，都会走到这里的握手方法。</p>
<h2 id="webSocket握手">webSocket握手</h2>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)didConnect;<br>&#123;<br>    SRFastLog(<span class="hljs-string">@&quot;Connected&quot;</span>);<br>  	<span class="hljs-comment">// 创建 HTTP 的 GET 请求，版本 HTTP 1.1</span><br>    <span class="hljs-built_in">CFHTTPMessageRef</span> request = <span class="hljs-built_in">CFHTTPMessageCreateRequest</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;GET&quot;</span>), (__bridge <span class="hljs-built_in">CFURLRef</span>)_url, kCFHTTPVersion1_1);<br>    <br>    <span class="hljs-comment">// Set host first so it defaults</span><br>    <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Host&quot;</span>), (__bridge <span class="hljs-built_in">CFStringRef</span>)(_url.port ? [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@:%@&quot;</span>, _url.host, _url.port] : _url.host));<br>        <br>  	<span class="hljs-comment">// 初始化 16 位随机字符</span><br>    <span class="hljs-built_in">NSMutableData</span> *keyBytes = [[<span class="hljs-built_in">NSMutableData</span> alloc] initWithLength:<span class="hljs-number">16</span>];<br>    SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes);<br>    <br>  	<span class="hljs-comment">// Base64 编码   生成的 _secKey 用于请求头中的 Sec-WebSocket-Key</span><br>    <span class="hljs-keyword">if</span> ([keyBytes respondsToSelector:<span class="hljs-keyword">@selector</span>(base64EncodedStringWithOptions:)]) &#123;<br>        _secKey = [keyBytes base64EncodedStringWithOptions:<span class="hljs-number">0</span>];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic push</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic ignored <span class="hljs-string">&quot;-Wdeprecated-declarations&quot;</span></span><br>        _secKey = [keyBytes base64Encoding];<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic pop</span><br>    &#125;<br>    <br>  	<span class="hljs-comment">// 校验编码后是否为 24 位</span><br>    assert([_secKey length] == <span class="hljs-number">24</span>);<br><br>    <span class="hljs-comment">// Apply cookies if any have been provided</span><br>    <span class="hljs-built_in">NSDictionary</span> * cookies = [<span class="hljs-built_in">NSHTTPCookie</span> requestHeaderFieldsWithCookies:[<span class="hljs-keyword">self</span> requestCookies]];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSString</span> * cookieKey <span class="hljs-keyword">in</span> cookies) &#123;<br>        <span class="hljs-built_in">NSString</span> * cookieValue = [cookies objcForKey:cookieKey];<br>        <span class="hljs-keyword">if</span> ([cookieKey length] &amp;&amp; [cookieValue length]) &#123;<br>            <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, (__bridge <span class="hljs-built_in">CFStringRef</span>)cookieKey, (__bridge <span class="hljs-built_in">CFStringRef</span>)cookieValue);<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">// set header for http basic auth</span><br>    <span class="hljs-keyword">if</span> (_url.user.length &amp;&amp; _url.password.length) &#123;<br>        <span class="hljs-built_in">NSData</span> *userAndPassword = [[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@:%@&quot;</span>, _url.user, _url.password] dataUsingEncoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>        <span class="hljs-built_in">NSString</span> *userAndPasswordBase64Encoded;<br>        <span class="hljs-keyword">if</span> ([keyBytes respondsToSelector:<span class="hljs-keyword">@selector</span>(base64EncodedStringWithOptions:)]) &#123;<br>            userAndPasswordBase64Encoded = [userAndPassword base64EncodedStringWithOptions:<span class="hljs-number">0</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic push</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic ignored <span class="hljs-string">&quot;-Wdeprecated-declarations&quot;</span></span><br>            userAndPasswordBase64Encoded = [userAndPassword base64Encoding];<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic pop</span><br>        &#125;<br>        _basicAuthorizationString = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Basic %@&quot;</span>, userAndPasswordBase64Encoded];<br>        <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Authorization&quot;</span>), (__bridge <span class="hljs-built_in">CFStringRef</span>)_basicAuthorizationString);<br>    &#125;<br>	<br>  	<span class="hljs-comment">// 这里设置的是 webSocket 握手请求的头部信息</span><br>    <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Upgrade&quot;</span>), <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;websocket&quot;</span>));<br>    <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Connection&quot;</span>), <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Upgrade&quot;</span>));<br>    <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Sec-WebSocket-Key&quot;</span>), (__bridge <span class="hljs-built_in">CFStringRef</span>)_secKey);<br>    <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Sec-WebSocket-Version&quot;</span>), (__bridge <span class="hljs-built_in">CFStringRef</span>)[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%ld&quot;</span>, (<span class="hljs-type">long</span>)_webSocketVersion]);<br>    <br>    <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Origin&quot;</span>), (__bridge <span class="hljs-built_in">CFStringRef</span>)_url.SR_origin);<br>    <br>    <span class="hljs-keyword">if</span> (_requestedProtocols) &#123;<br>        <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Sec-WebSocket-Protocol&quot;</span>), (__bridge <span class="hljs-built_in">CFStringRef</span>)[_requestedProtocols componentsJoinedByString:<span class="hljs-string">@&quot;, &quot;</span>]);<br>    &#125;<br><br>    [_urlRequest.allHTTPHeaderFields enumerateKeysAndobjcsUsingBlock:^(<span class="hljs-type">id</span> key, <span class="hljs-type">id</span> obj, <span class="hljs-type">BOOL</span> *stop) &#123;<br>        <span class="hljs-built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, (__bridge <span class="hljs-built_in">CFStringRef</span>)key, (__bridge <span class="hljs-built_in">CFStringRef</span>)obj);<br>    &#125;];<br>    <br>  	<span class="hljs-comment">// 将 HTTP 请求报文转成 OC 的 NSData 对象</span><br>    <span class="hljs-built_in">NSData</span> *message = <span class="hljs-built_in">CFBridgingRelease</span>(<span class="hljs-built_in">CFHTTPMessageCopySerializedMessage</span>(request));<br>    <br>    <span class="hljs-built_in">CFRelease</span>(request);<br><br>  	<span class="hljs-comment">// 将 HTTP 请求报文写入到输出缓存</span><br>    [<span class="hljs-keyword">self</span> _writeData:message];<br>  <br>  	<span class="hljs-comment">// 读取 HTTP 返回头部信息</span><br>    [<span class="hljs-keyword">self</span> _readHTTPHeader];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>didConnect 方法创建一个 HTTP 请求的 MessageRef，按照之前介绍过的 webSocket 握手标准，设置请求的头部信息，Sec-WebSocket-Key 是先生成 16 位随机字符再 Base64 编码成 24 位字符，将外部传入的子协议写入 Sec-WebSocket-Protocol 字符。方法的最后获取到 HTTP 请求报文的 NSData 对象，调用 writeData 将数据写入到输出缓冲区，等待输出流有空间可写时，将数据发送给服务端。最后调用 readHTTPHeader 创建 HTTP header 的消费者尝试从输入缓冲区中读取返回头信息。</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_readHTTPHeader;<br>&#123;<br>    <span class="hljs-keyword">if</span> (_receivedHTTPHeaders == <span class="hljs-literal">NULL</span>) &#123;<br>        _receivedHTTPHeaders = <span class="hljs-built_in">CFHTTPMessageCreateEmpty</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NO</span>);<br>    &#125;<br>                        <br>  	<span class="hljs-comment">// 尝试读取 HTTP Response Header</span><br>    [<span class="hljs-keyword">self</span> _readUntilHeaderCompleteWithCallback:^(SRWebSocket *<span class="hljs-keyword">self</span>,  <span class="hljs-built_in">NSData</span> *data) &#123;<br>        <span class="hljs-built_in">CFHTTPMessageAppendBytes</span>(_receivedHTTPHeaders, (<span class="hljs-keyword">const</span> <span class="hljs-built_in">UInt8</span> *)data.bytes, data.length);<br>        <span class="hljs-comment">// 判断 Header 是否有效</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CFHTTPMessageIsHeaderComplete</span>(_receivedHTTPHeaders)) &#123;<br>            SRFastLog(<span class="hljs-string">@&quot;Finished reading headers %@&quot;</span>, <span class="hljs-built_in">CFBridgingRelease</span>(<span class="hljs-built_in">CFHTTPMessageCopyAllHeaderFields</span>(_receivedHTTPHeaders)));<br>          	<span class="hljs-comment">// 继续 Header 校验</span><br>            [<span class="hljs-keyword">self</span> _HTTPHeadersDidFinish];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          	<span class="hljs-comment">// 重复读取</span><br>            [<span class="hljs-keyword">self</span> _readHTTPHeader];<br>        &#125;<br>    &#125;];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>readHTTPHeader 方法中调用 readUntilHeaderCompleteWithCallback ，其方法内部实际是创建一个消费者去缓存中读取匹配 Header 特征字符的数据段，读到数据后回调 Block。回调函数中对 Header 是否有效做了校验，如果无效，重复读取 Header，有效则继续后续的 Header 校验。</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_HTTPHeadersDidFinish;<br>&#123;<br>  	<span class="hljs-comment">// 获取 HTTP Code</span><br>    <span class="hljs-built_in">NSInteger</span> responseCode = <span class="hljs-built_in">CFHTTPMessageGetResponseStatusCode</span>(_receivedHTTPHeaders);<br>    <br>  	<span class="hljs-comment">// 校验 Code</span><br>    <span class="hljs-keyword">if</span> (responseCode &gt;= <span class="hljs-number">400</span>) &#123;<br>        SRFastLog(<span class="hljs-string">@&quot;Request failed with response code %d&quot;</span>, responseCode);<br>        [<span class="hljs-keyword">self</span> _failWithError:[<span class="hljs-built_in">NSError</span> errorWithDomain:SRWebSocketErrorDomain code:<span class="hljs-number">2132</span> userInfo:@&#123;<span class="hljs-built_in">NSLocalizedDescriptionKey</span>:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;received bad response code from server %ld&quot;</span>, (<span class="hljs-type">long</span>)responseCode], SRHTTPResponseErrorKey:@(responseCode)&#125;]];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 校验 Sec-WebSocket-Accept</span><br>    <span class="hljs-keyword">if</span>(![<span class="hljs-keyword">self</span> _checkHandshake:_receivedHTTPHeaders]) &#123;<br>        [<span class="hljs-keyword">self</span> _failWithError:[<span class="hljs-built_in">NSError</span> errorWithDomain:SRWebSocketErrorDomain code:<span class="hljs-number">2133</span> userInfo:[<span class="hljs-built_in">NSDictionary</span> dictionaryWithobjc:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Invalid Sec-WebSocket-Accept response&quot;</span>] forKey:<span class="hljs-built_in">NSLocalizedDescriptionKey</span>]]];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  	<span class="hljs-comment">// 校验 Sec-WebSocket-Protocol</span><br>    <span class="hljs-built_in">NSString</span> *negotiatedProtocol = <span class="hljs-built_in">CFBridgingRelease</span>(<span class="hljs-built_in">CFHTTPMessageCopyHeaderFieldValue</span>(_receivedHTTPHeaders, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Sec-WebSocket-Protocol&quot;</span>)));<br>    <span class="hljs-keyword">if</span> (negotiatedProtocol) &#123;<br>        <span class="hljs-comment">// Make sure we requested the protocol</span><br>        <span class="hljs-keyword">if</span> ([_requestedProtocols indexOfobjc:negotiatedProtocol] == <span class="hljs-built_in">NSNotFound</span>) &#123;<br>            [<span class="hljs-keyword">self</span> _failWithError:[<span class="hljs-built_in">NSError</span> errorWithDomain:SRWebSocketErrorDomain code:<span class="hljs-number">2133</span> userInfo:[<span class="hljs-built_in">NSDictionary</span> dictionaryWithobjc:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Server specified Sec-WebSocket-Protocol that wasn&#x27;t requested&quot;</span>] forKey:<span class="hljs-built_in">NSLocalizedDescriptionKey</span>]]];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        _protocol = negotiatedProtocol;<br>    &#125;<br>    <br>  	<span class="hljs-comment">// 更新状态 - 已连接</span><br>    <span class="hljs-keyword">self</span>.readyState = SR_OPEN;<br>    <br>  	<span class="hljs-comment">// 这个标志位没有用到，所以一定会走 readFrameNew，尝试读取 webSocket 数据帧</span><br>    <span class="hljs-keyword">if</span> (!_didFail) &#123;<br>        [<span class="hljs-keyword">self</span> _readFrameNew];<br>    &#125;<br><br>  	<span class="hljs-comment">// 将已连接状态回调给上层</span><br>    [<span class="hljs-keyword">self</span> _performDelegateBlock:^&#123;<br>        <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(webSocketDidOpen:)]) &#123;<br>            [<span class="hljs-keyword">self</span>.delegate webSocketDidOpen:<span class="hljs-keyword">self</span>];<br>        &#125;;<br>    &#125;];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">BOOL</span>)_checkHandshake:(<span class="hljs-built_in">CFHTTPMessageRef</span>)httpMessage;<br>&#123;<br>  	<span class="hljs-comment">// 拿到服务端返回的 Sec-WebSocket-Accept</span><br>    <span class="hljs-built_in">NSString</span> *acceptHeader = <span class="hljs-built_in">CFBridgingRelease</span>(<span class="hljs-built_in">CFHTTPMessageCopyHeaderFieldValue</span>(httpMessage, <span class="hljs-built_in">CFSTR</span>(<span class="hljs-string">&quot;Sec-WebSocket-Accept&quot;</span>)));<br><br>    <span class="hljs-keyword">if</span> (acceptHeader == <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>  	<span class="hljs-comment">// 将本地的 _secKey 拼接协议规定的字符串</span><br>    <span class="hljs-built_in">NSString</span> *concattedString = [_secKey stringByAppendingString:SRWebSocketAppendToSecKeyString];<br>  	<span class="hljs-comment">// 先做 Sha-1 散列，后 Base64 编码</span><br>    <span class="hljs-built_in">NSString</span> *expectedAccept = [concattedString stringBySHA1ThenBase64Encoding];<br>    <br>  	<span class="hljs-comment">// 将处理后的结果与 Sec-WebSocket-Accept 比对，返回比对结果</span><br>    <span class="hljs-keyword">return</span> [acceptHeader isEqualToString:expectedAccept];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>可以看到 SRWebSocket 在校验握手返回头部信息时分了三个步骤，一是校验 HTTP Response Code 是否大于 400，其实协议规定的是服务端要返回 101，SRWebSocket 这里处理的比较宽松。二是校验 Sec-WebSocket-Accept，方法是将 Sec-WebSocket-Key 按服务端的方式，拼接协议规定字符串，sha-1 散列后 Base64 编码，如果结果与 Sec-WebSocket-Accept 一致，校验通过。三是校验 Sec-WebSocket-Protocol，如果服务端返回的这个字段有值，说明客户端在请求时提供了子协议方案，所以需要比对客户端和服务端的子协议是否一致。这三项校验完成，说明握手已经成功，此时更新状态为已连接，并回调给上层。</p>
<h2 id="数据读取与写入">数据读取与写入</h2>
<p>首先看一下 SRWebSocket 读取和写入的流程：</p>
<p><img src="https://hexo.qiniu.pursue.top/SRWebSockey%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="https://hexo.qiniu.pursue.top/loading.gif" lazyload alt="SRWebSocket 流程图"></p>
<p>黄色区域部分是 SRWebSocket 的处理流程，可以看到，在输入输出流和客户端之间有一个读写缓存区作为输入输出数据的缓冲，相比数据写入，数据读取会复杂一些。</p>
<h3 id="数据读取">数据读取</h3>
<p>NSInputStream 从服务端的 Output 通道接收数据后，回调 NSStreamEventHasBytesAvailable 事件给 SRWebSocket：</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)safeHandleEvent:(<span class="hljs-built_in">NSStreamEvent</span>)eventCode stream:(<span class="hljs-built_in">NSStream</span> *)aStream<br>&#123;<br>        <span class="hljs-keyword">switch</span> (eventCode) &#123;<br>...<br>            <span class="hljs-keyword">case</span> <span class="hljs-built_in">NSStreamEventHasBytesAvailable</span>: &#123;<br>                <span class="hljs-comment">// 输入流中有数据可读</span><br>                SRFastLog(<span class="hljs-string">@&quot;NSStreamEventHasBytesAvailable %@&quot;</span>, aStream);<br>                <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> bufferSize = <span class="hljs-number">2048</span>;<br>                uint8_t buffer[bufferSize];<br>                <br>                <span class="hljs-comment">// 将输入流中的数据读到已读缓存区</span><br>                <span class="hljs-keyword">while</span> (_inputStream.hasBytesAvailable) &#123;<br>                    <span class="hljs-built_in">NSInteger</span> bytes_read = [_inputStream read:buffer maxLength:bufferSize];<br>                    <br>                    <span class="hljs-keyword">if</span> (bytes_read &gt; <span class="hljs-number">0</span>) &#123;<br>                        [_readBuffer appendBytes:buffer length:bytes_read];<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bytes_read &lt; <span class="hljs-number">0</span>) &#123;<br>                        [<span class="hljs-keyword">self</span> failWithError:_inputStream.streamError];<br>                    &#125;<br>                    <br>                    <span class="hljs-keyword">if</span> (bytes_read != bufferSize) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;;<br>                <br>                <span class="hljs-comment">// 尝试从已读缓冲区读取数据</span><br>                [<span class="hljs-keyword">self</span> _pumpScanner];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>...<br></code></pre></div></td></tr></table></figure>
<p>在收到 NSStreamEventHasBytesAvailable 事件后，SRWebSocket 将输入流中可读的数据读到已读缓存区 _readBuffer 中，接下来要做的是从 _readBuffer 解析出 webSocket 消息给到客户端，需要借助 SRWebSocket 设计的消费者。</p>
<p>输入输出流被成功打开后，我们能从输入流中读到的数据分为两种，一个是握手阶段的 HTTP Response Header，另一个是 webSocket 帧数据。如果要从一个二进制流中解析这两种数据需要如何做呢，对于 HTTP Response Header 可以在缓存区中查找 <code>\r\n\r\n</code> 将匹配的最后一个字符之前的数据取出来就是所有的 HTTP Header 数据（因为握手总是发生在 webSocket 帧发送之前）。至于为什么是 <code>\r\n\r\n</code> 可以看下服务端返回的 HTTP 报文：</p>
<figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> Ok\r\n<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>AAA\r\n<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache\r\n<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 07 Nov 2014 23:20:27 GMT\r\n<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html\r\n<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close\r\n\r\n   &lt;--------------<br></code></pre></div></td></tr></table></figure>
<p>每个 HTTP Header 之后一般都会有 <code>\r\n</code> 用于换行，而 Header 和 Body 之间会空一行，所以 Header 的末尾会是 <code>\r\n\r\n</code> 。解析出握手的返回头信息后，就是解析 webSocket 帧数据了，通过观察帧的结构发现每一帧所占字节数是不固定的，而且没有类似 HTTP Header 的分隔符作为标志，所以只能分批次解析 webSocket 帧。首先读取 2 个字节的数据，解析 Payload Length 和 Mask，通过这两个值判断是否有 Extension Payload Length 和 Masking Key，如果有，再把这部分数据读出来，此时已经拿到 Payload 数据长度，再往后就是 Payload 数据了，按 Payload Length 去读就可以。</p>
<p>SRWebSocket 消费者就是按这种模式去设计的，分为 HTTP consumer 和 webSocket consumer，每当有数据需要从已读缓存区读取时，就会创建对应的 consumer 加入到消费者工作队列 consumers 中，同时读取事件循环会从 consumers 中取出 consumer 去缓存区匹配数据。为了防止 consumer 创建过多，SRWebSocket 维护了一个消费者缓存池 consumerPool，需要时从缓存池获取，使用完成后归还缓存池，缓存池的大小默认是 8。</p>
<p>首先来看一下 HTTP consumer 的初始化代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_readHTTPHeader;<br>&#123;<br>...       <br>    [<span class="hljs-keyword">self</span> _readUntilHeaderCompleteWithCallback:^(SRWebSocket *<span class="hljs-keyword">self</span>,  <span class="hljs-built_in">NSData</span> *data) &#123;<br>        ...<br>    &#125;];<br>&#125;<br><br><span class="hljs-comment">// HTTP Header 匹配字符</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> CRLFCRLFBytes[] = &#123;<span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>&#125;;<br><br>- (<span class="hljs-type">void</span>)_readUntilHeaderCompleteWithCallback:(data_callback)dataHandler;<br>&#123;<br>    [<span class="hljs-keyword">self</span> _readUntilBytes:CRLFCRLFBytes length:<span class="hljs-keyword">sizeof</span>(CRLFCRLFBytes) callback:dataHandler];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)_readUntilBytes:(<span class="hljs-keyword">const</span> <span class="hljs-type">void</span> *)bytes length:(size_t)length callback:(data_callback)dataHandler;<br>&#123;<br>    <span class="hljs-comment">// TODO optimize so this can continue from where we last searched</span><br>  	<span class="hljs-comment">// 定义了一个匿名函数，在 data 中查找匹配字符，并返回最后一个匹配字符前的字节数量</span><br>    stream_scanner consumer = ^size_t(<span class="hljs-built_in">NSData</span> *data) &#123;<br>        __block size_t found_size = <span class="hljs-number">0</span>;<br>        __block size_t match_count = <span class="hljs-number">0</span>;<br>        <br>        size_t size = data.length;<br>        <span class="hljs-keyword">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buffer = data.bytes;<br>        <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; size; i++ ) &#123;<br>            <span class="hljs-keyword">if</span> (((<span class="hljs-keyword">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)buffer)[i] == ((<span class="hljs-keyword">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)bytes)[match_count]) &#123;<br>                match_count += <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (match_count == length) &#123;<br>                  	<span class="hljs-comment">// 所有字符匹配完成</span><br>                    found_size = i + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              	<span class="hljs-comment">// 发现有不匹配，重置索引</span><br>                match_count = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> found_size;<br>    &#125;;<br>  	<span class="hljs-comment">// 使用匹配规则的匿名函数 和匹配完成回调函数创建消费者</span><br>    [<span class="hljs-keyword">self</span> _addConsumerWithScanner:consumer callback:dataHandler];<br>&#125;<br><br><span class="hljs-comment">// 俄罗斯套娃...</span><br>- (<span class="hljs-type">void</span>)_addConsumerWithScanner:(stream_scanner)consumer callback:(data_callback)callback;<br>&#123;<br>    [<span class="hljs-keyword">self</span> assertOnWorkQueue];<br>    [<span class="hljs-keyword">self</span> _addConsumerWithScanner:consumer callback:callback dataLength:<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-comment">// 最后一层...</span><br>- (<span class="hljs-type">void</span>)_addConsumerWithScanner:(stream_scanner)consumer callback:(data_callback)callback dataLength:(size_t)dataLength;<br>&#123;    <br>    [<span class="hljs-keyword">self</span> assertOnWorkQueue];<br>  	<span class="hljs-comment">// 从消费者缓存池中取出消费者，加入到工作队列</span><br>    [_consumers addobjc:[_consumerPool consumerWithScanner:consumer handler:callback bytesNeeded:dataLength readToCurrentFrame:<span class="hljs-literal">NO</span> unmaskBytes:<span class="hljs-literal">NO</span>]];<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>可以看到 SRWebSocket 把 HTTP Header 的匹配设计成消费者的一个匿名函数，这个匿名函数将对缓存区里的数据进行匹配拿到 Data 和 Size，之后将数据回调给 Callback 函数做 Header 的校验。</p>
<p>接着来看一下 webSocket consumer 的初始化代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_addConsumerWithDataLength:(size_t)dataLength callback:(data_callback)callback readToCurrentFrame:(<span class="hljs-type">BOOL</span>)readToCurrentFrame unmaskBytes:(<span class="hljs-type">BOOL</span>)unmaskBytes;<br>&#123;   <br>    [<span class="hljs-keyword">self</span> assertOnWorkQueue];<br>    assert(dataLength);<br>    <br>  	<span class="hljs-comment">// 从消费者缓存池中取出消费者，加入到工作队列</span><br>    [_consumers addobjc:[_consumerPool consumerWithScanner:<span class="hljs-literal">nil</span> handler:callback bytesNeeded:dataLength readToCurrentFrame:readToCurrentFrame unmaskBytes:unmaskBytes]];<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>代码看起来跟创建 HTTP consumer 最后一步差不多，只是初始化 consumer 时传参不同。HTTP consumer 只需要一个匹配规则和处理回调，其他参数不关心。而 webSocket consumer 不需要匹配规则，需要的是按字节数读取数据，所以需要传入 dataLength。readToCurrentFrame 用于标识这个 consumer 是否处理的是数据类型消息的数据帧，unmaskBytes 用于标识 Payload 是否需要解掩码，这两个字段只有在 consumer 解析 Payload 数据时有用，其他情况传 NO。</p>
<p>初始化方法介绍完了，接下来分析下 webSocket consumer 的使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_readFrameNew;<br>&#123;<br>    <span class="hljs-built_in">dispatch_async</span>(_workQueue, ^&#123;<br>      	<span class="hljs-comment">// 清空当前消息数据缓存区</span><br>        [_currentFrameData setLength:<span class="hljs-number">0</span>];<br>        <br>      	<span class="hljs-comment">// 当前消息的类型</span><br>        _currentFrameOpcode = <span class="hljs-number">0</span>;<br>      <br>      	<span class="hljs-comment">// 当前消息包含的帧数</span><br>        _currentFrameCount = <span class="hljs-number">0</span>;<br>      <br>      	<span class="hljs-comment">// 参数未用到</span><br>        _readOpCount = <span class="hljs-number">0</span>;<br>      <br>      	<span class="hljs-comment">// 用来记录 _currentFrameData 中已校验 UTF-8 编码的字符串位置偏移</span><br>        _currentStringScanPosition = <span class="hljs-number">0</span>;<br>        <br>      	<span class="hljs-comment">// 继续</span><br>        [<span class="hljs-keyword">self</span> _readFrameContinue];<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>readFrameNew 是创建 webSocket 消费者的入口，方法中将几个比较重要的参数清空，currentFrameData、currentFrameOpcode、currentFrameCount 和 currentStringScanPosition 都只是给数据类型消息使用的，控制类型消息没有使用。currentFrameOpcode 这里可能有个疑问，为什么初始化为 0，0 在 opcode 中不是代表延续帧吗。其实 SRWebSocket 在读取前两个字节解析 opcode 时，如果 opcode 是 0，在构造 frame_header 结构体时依旧会沿用这个消息起始帧的 opcode 值，所以这里设置为 0 不会有冲突。</p>
<p>接着是 readFrameContinue 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_readFrameContinue;<br>&#123;<br>  	<span class="hljs-comment">// 猜测这里的控制主要是校验代码逻辑</span><br>    assert((_currentFrameCount == <span class="hljs-number">0</span> &amp;&amp; _currentFrameOpcode == <span class="hljs-number">0</span>) || (_currentFrameCount &gt; <span class="hljs-number">0</span> &amp;&amp; _currentFrameOpcode &gt; <span class="hljs-number">0</span>));<br><br>  	<span class="hljs-comment">// 创建一个读取 2 个字节数据的 webSocket 消费者到工作队列</span><br>    [<span class="hljs-keyword">self</span> _addConsumerWithDataLength:<span class="hljs-number">2</span> callback:^(SRWebSocket *<span class="hljs-keyword">self</span>, <span class="hljs-built_in">NSData</span> *data) &#123;<br>      <span class="hljs-comment">// 构造一个 webSocket 头信息的结构体</span><br>      __block frame_header header = &#123;<span class="hljs-number">0</span>&#125;;<br>        <br>        <span class="hljs-keyword">const</span> uint8_t *headerBuffer = data.bytes;<br>        assert(data.length &gt;= <span class="hljs-number">2</span>);<br>        <br>      	<span class="hljs-comment">// 拿到 RSV1、RSV2、RSV3，根据协议规定这三位必须是 0</span><br>        <span class="hljs-keyword">if</span> (headerBuffer[<span class="hljs-number">0</span>] &amp; SRRsvMask) &#123;<br>            [<span class="hljs-keyword">self</span> _closeWithProtocolError:<span class="hljs-string">@&quot;Server used RSV bits&quot;</span>];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>      	<span class="hljs-comment">// 拿到 opcode</span><br>        uint8_t receivedOpcode = (SROpCodeMask &amp; headerBuffer[<span class="hljs-number">0</span>]);<br>        <br>      	<span class="hljs-comment">// 控制帧 = ping 或 pong 或 close  数据帧 = !控制帧</span><br>        <span class="hljs-type">BOOL</span> isControlFrame = (receivedOpcode == SROpCodePing || receivedOpcode == SROpCodePong || receivedOpcode == SROpCodeConnectionClose);<br>        <br>      	<span class="hljs-comment">// currentFrameCount &gt; 0 说明在等待 opcode 为 0 的延续帧</span><br>        <span class="hljs-keyword">if</span> (!isControlFrame &amp;&amp; receivedOpcode != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">self</span>-&gt;_currentFrameCount &gt; <span class="hljs-number">0</span>) &#123;<br>            [<span class="hljs-keyword">self</span> _closeWithProtocolError:<span class="hljs-string">@&quot;all data frames after the initial data frame must have opcode 0&quot;</span>];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>      	<span class="hljs-comment">// currentFrameCount = 0 说明一定不要是延续帧</span><br>        <span class="hljs-keyword">if</span> (receivedOpcode == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">self</span>-&gt;_currentFrameCount == <span class="hljs-number">0</span>) &#123;<br>            [<span class="hljs-keyword">self</span> _closeWithProtocolError:<span class="hljs-string">@&quot;cannot continue a message&quot;</span>];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>      	<span class="hljs-comment">// 这里就是前文提到的 如果当前帧 opcode 是 0，在构造 frame_header 时将 opcode 设置成当前消息首帧的 opcode 值</span><br>        header.opcode = receivedOpcode == <span class="hljs-number">0</span> ? <span class="hljs-keyword">self</span>-&gt;_currentFrameOpcode : receivedOpcode;<br>        <br>      	<span class="hljs-comment">// 获取 FIN</span><br>        header.fin = !!(SRFinMask &amp; headerBuffer[<span class="hljs-number">0</span>]);<br>        <br>        <span class="hljs-comment">// 获取 Mask</span><br>        header.masked = !!(SRMaskMask &amp; headerBuffer[<span class="hljs-number">1</span>]);<br>      <br>      	<span class="hljs-comment">// 获取 Payload Length</span><br>        header.payload_length = SRPayloadLenMask &amp; headerBuffer[<span class="hljs-number">1</span>];<br>        <br>        headerBuffer = <span class="hljs-literal">NULL</span>;<br>      <br>      	<span class="hljs-comment">// 如果当前帧 Mask 位的值为 1，SRWebSocket 直接将连接关闭了，但实际协议只是规定客户端发送消息需要使用掩码，并没有对服务端行为做约束，这里是有些差异的</span><br>        <span class="hljs-keyword">if</span> (header.masked) &#123;<br>            [<span class="hljs-keyword">self</span> _closeWithProtocolError:<span class="hljs-string">@&quot;Client must receive unmasked data&quot;</span>];<br>        &#125;<br>        <br>      	<span class="hljs-comment">// extra_bytes_needed 是用来统计 Extension Payload Length 和 Masking Key 的长度，用于下一轮 consumer 的消费</span><br>      	<span class="hljs-comment">// 如果 Mask 位为 1，要加上 4 位的 Masking Key 长度。</span><br>        size_t extra_bytes_needed = header.masked ? <span class="hljs-keyword">sizeof</span>(_currentReadMaskKey) : <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">if</span> (header.payload_length == <span class="hljs-number">126</span>) &#123;<br>          	<span class="hljs-comment">// 如果 Payload Length 是 126，要加上 16 位的 Extension Payload Length</span><br>            extra_bytes_needed += <span class="hljs-keyword">sizeof</span>(uint16_t);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (header.payload_length == <span class="hljs-number">127</span>) &#123;<br>          	<span class="hljs-comment">// 如果 Payload Length 是 127，要加上 64 位的 Extension Payload Length</span><br>            extra_bytes_needed += <span class="hljs-keyword">sizeof</span>(uint64_t);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (extra_bytes_needed == <span class="hljs-number">0</span>) &#123;<br>          	<span class="hljs-comment">// 如果 extra_bytes_needed 为 0，说明没有 Extension Payload Length 和 Masking Key 要处理，所以直接处理 Payload</span><br>            [<span class="hljs-keyword">self</span> _handleFrameHeader:header curData:<span class="hljs-keyword">self</span>-&gt;_currentFrameData];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          	<span class="hljs-comment">// 如果 extra_bytes_needed 不为 0，创建所需数据长度为 extra_bytes_needed 的 webSocket 消费者到工作队列</span><br>            [<span class="hljs-keyword">self</span> _addConsumerWithDataLength:extra_bytes_needed callback:^(SRWebSocket *<span class="hljs-keyword">self</span>, <span class="hljs-built_in">NSData</span> *data) &#123;<br>                size_t mapped_size = data.length;<br>                <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unused (mapped_size)</span><br>                <span class="hljs-keyword">const</span> <span class="hljs-type">void</span> *mapped_buffer = data.bytes;<br>              <br>              	<span class="hljs-comment">// offset 用来标记 Masking Key 的位置</span><br>                size_t offset = <span class="hljs-number">0</span>;<br>                <br>                <span class="hljs-keyword">if</span> (header.payload_length == <span class="hljs-number">126</span>) &#123;<br>                  	<span class="hljs-comment">// 如果 Payload Length 是 126，真实负载数据长度是 Payload Length 之后的 16 位来标识</span><br>                    assert(mapped_size &gt;= <span class="hljs-keyword">sizeof</span>(uint16_t));<br>                    uint16_t newLen = EndianU16_BtoN(*(uint16_t *)(mapped_buffer));<br>                    header.payload_length = newLen;<br>                    offset += <span class="hljs-keyword">sizeof</span>(uint16_t);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (header.payload_length == <span class="hljs-number">127</span>) &#123;<br>                  	<span class="hljs-comment">// 如果 Payload Length 是 127，真实负载数据长度是 Payload Length 之后的 64 位来标识</span><br>                    assert(mapped_size &gt;= <span class="hljs-keyword">sizeof</span>(uint64_t));<br>                    header.payload_length = EndianU64_BtoN(*(uint64_t *)(mapped_buffer));<br>                    offset += <span class="hljs-keyword">sizeof</span>(uint64_t);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                  	<span class="hljs-comment">// 能走到这里，说明没有 Extension Payload Length</span><br>                    assert(header.payload_length &lt; <span class="hljs-number">126</span> &amp;&amp; header.payload_length &gt;= <span class="hljs-number">0</span>);<br>                &#125;<br>                <br>              	<span class="hljs-comment">// 如果 Mask 位为 1，需要将 Masking Key 读取到缓存区，用于之后 Payload 解掩码</span><br>                <span class="hljs-keyword">if</span> (header.masked) &#123;<br>                    assert(mapped_size &gt;= <span class="hljs-keyword">sizeof</span>(_currentReadMaskOffset) + offset);<br>                    memcpy(<span class="hljs-keyword">self</span>-&gt;_currentReadMaskKey, ((uint8_t *)mapped_buffer) + offset, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">self</span>-&gt;_currentReadMaskKey));<br>                &#125;<br>                <br>              	<span class="hljs-comment">// 处理 Payload</span><br>                [<span class="hljs-keyword">self</span> _handleFrameHeader:header curData:<span class="hljs-keyword">self</span>-&gt;_currentFrameData];<br>            &#125; readToCurrentFrame:<span class="hljs-literal">NO</span> unmaskBytes:<span class="hljs-literal">NO</span>];<br>        &#125;<br>    &#125; readToCurrentFrame:<span class="hljs-literal">NO</span> unmaskBytes:<span class="hljs-literal">NO</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>readFrameContinue 方法先是创建了一个读取 2 个字节数据的 consumer，读取到数据后构建一个 frame_header 结构体，通过对 Mask 位和 Payload Length 的解析，判断是否有 Extension Payload Length 和 Masking Key 存在，如果存在，就创建一个读取这部分数据的 consumer，获取到真实负载长度和掩码后，创建读取 Payload 数据的 consumer，如果不存在则直接创建一个读取 Payload 数据的 consumer。</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_handleFrameHeader:(frame_header)frame_header curData:(<span class="hljs-built_in">NSData</span> *)curData;<br>&#123;<br>  	<span class="hljs-comment">// 前面介绍过，构造的 frame_header 的 opcode 不应该为 0</span><br>    assert(frame_header.opcode != <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.readyState == SR_CLOSED) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 控制帧 = ping 或 pong 或 close  数据帧 = !控制帧</span><br>    <span class="hljs-type">BOOL</span> isControlFrame = (frame_header.opcode == SROpCodePing || frame_header.opcode == SROpCodePong || frame_header.opcode == SROpCodeConnectionClose);<br>    <br>  	<span class="hljs-comment">// 控制帧不能分片</span><br>    <span class="hljs-keyword">if</span> (isControlFrame &amp;&amp; !frame_header.fin) &#123;<br>        [<span class="hljs-keyword">self</span> _closeWithProtocolError:<span class="hljs-string">@&quot;Fragmented control frames not allowed&quot;</span>];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  	<span class="hljs-comment">// 控制帧 Payload Length 不能是 126、127</span><br>    <span class="hljs-keyword">if</span> (isControlFrame &amp;&amp; frame_header.payload_length &gt;= <span class="hljs-number">126</span>) &#123;<br>        [<span class="hljs-keyword">self</span> _closeWithProtocolError:<span class="hljs-string">@&quot;Control frames cannot have payloads larger than 126 bytes&quot;</span>];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  	<span class="hljs-comment">// 数据帧类型才会更新这两个变量的值</span><br>    <span class="hljs-keyword">if</span> (!isControlFrame) &#123;<br>        _currentFrameOpcode = frame_header.opcode;<br>        _currentFrameCount += <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (frame_header.payload_length == <span class="hljs-number">0</span>) &#123;<br>      	<span class="hljs-comment">// Payload Length 是 0</span><br>        <span class="hljs-keyword">if</span> (isControlFrame) &#123;<br>          	<span class="hljs-comment">// 如果是控制帧，感觉这里可以将 curData 替换成 nil</span><br>            [<span class="hljs-keyword">self</span> _handleFrameWithData:curData opCode:frame_header.opcode];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          	<span class="hljs-comment">// 如果是数据帧</span><br>            <span class="hljs-keyword">if</span> (frame_header.fin) &#123;<br>              	<span class="hljs-comment">// FIN 位为 1，是当前消息的最后一帧，因此需要将 currentFrameData 缓存的当前消息的所有帧数据回调给上层</span><br>                [<span class="hljs-keyword">self</span> _handleFrameWithData:_currentFrameData opCode:frame_header.opcode];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// TODO add assert that opcode is not a control;</span><br>              	<span class="hljs-comment">// 如果是延续帧，Payload Length 为 0，直接读取下一帧</span><br>                [<span class="hljs-keyword">self</span> _readFrameContinue];<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      	<span class="hljs-comment">// Payload Length 不是 0</span><br>        assert(frame_header.payload_length &lt;= SIZE_T_MAX);<br>      	<span class="hljs-comment">// 创建读取 Payload 的 webSocket 消费者加入到工作队列</span><br>        [<span class="hljs-keyword">self</span> _addConsumerWithDataLength:(size_t)frame_header.payload_length callback:^(SRWebSocket *<span class="hljs-keyword">self</span>, <span class="hljs-built_in">NSData</span> *newData) &#123;<br>            <span class="hljs-keyword">if</span> (isControlFrame) &#123;<br>              	<span class="hljs-comment">// 如果是控制帧，将这部分读到的 Payload 数据回调给上层</span><br>                [<span class="hljs-keyword">self</span> _handleFrameWithData:newData opCode:frame_header.opcode];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              	<span class="hljs-comment">// 如果是数据帧</span><br>                <span class="hljs-keyword">if</span> (frame_header.fin) &#123;<br>                  	<span class="hljs-comment">// FIN 位为 1，是当前消息的最后一帧，因此需要将 currentFrameData 缓存的当前消息的所有帧数据回调给上层</span><br>                    [<span class="hljs-keyword">self</span> _handleFrameWithData:<span class="hljs-keyword">self</span>-&gt;_currentFrameData opCode:frame_header.opcode];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// TODO add assert that opcode is not a control;</span><br>                  	<span class="hljs-comment">// 如果是延续帧，直接读取下一帧</span><br>                  	<span class="hljs-comment">// 这里无需关心延续帧的 Payload 没有被 append 到 currentFrameData，在循环消费者队列匹配数据时已经处理过了</span><br>                    [<span class="hljs-keyword">self</span> _readFrameContinue];<br>                &#125;<br>                <br>            &#125;<br>        &#125; readToCurrentFrame:!isControlFrame unmaskBytes:frame_header.masked];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>handleFrameHeader 方法对 Payload Length 是否为 0，当前帧是控制帧还是数据帧做了逻辑区分。区别于之前创建的 webSocket 消费者，用于读取 Payload 数据的消费者 readToCurrentFrame 和 unmaskBytes 都传了值，这两个值在循环消费者队列读取数据时会用到。接下来就是处理完整的 webSocket 消息数据了：</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_handleFrameWithData:(<span class="hljs-built_in">NSData</span> *)frameData opCode:(<span class="hljs-built_in">NSInteger</span>)opcode;<br>&#123;                <br>    <span class="hljs-comment">// Check that the current data is valid UTF8</span><br>    <span class="hljs-comment">// 控制帧 = ping 或 pong 或 close  数据帧 = !控制帧</span><br>    <span class="hljs-type">BOOL</span> isControlFrame = (opcode == SROpCodePing || opcode == SROpCodePong || opcode == SROpCodeConnectionClose);<br>  	<span class="hljs-comment">// 到目前为止，当前消息的所有数据已经拿到了，就可以创建下一轮消费者了</span><br>    <span class="hljs-keyword">if</span> (!isControlFrame) &#123;<br>      	<span class="hljs-comment">// 如果当前是数据帧，需要先清空数据帧相关的变量和缓存</span><br>        [<span class="hljs-keyword">self</span> _readFrameNew];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      	<span class="hljs-comment">// 如果是控制帧，直接创建下一轮消费者</span><br>        <span class="hljs-built_in">dispatch_async</span>(_workQueue, ^&#123;<br>            [<span class="hljs-keyword">self</span> _readFrameContinue];<br>        &#125;);<br>    &#125;<br>    <br>    <span class="hljs-comment">//frameData will be copied before passing to handlers</span><br>    <span class="hljs-comment">//otherwise there can be misbehaviours when value at the pointer is changed</span><br>    <span class="hljs-keyword">switch</span> (opcode) &#123;<br>        <span class="hljs-keyword">case</span> SROpCodeTextFrame: &#123;<br>          	<span class="hljs-comment">// 处理字符数据类型消息</span><br>            <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(webSocketShouldConvertTextFrameToString:)] &amp;&amp; ![<span class="hljs-keyword">self</span>.delegate webSocketShouldConvertTextFrameToString:<span class="hljs-keyword">self</span>]) &#123;<br>              	<span class="hljs-comment">// 如果上层指定字符数据使用二进制方式返回</span><br>                [<span class="hljs-keyword">self</span> _handleMessage:[frameData <span class="hljs-keyword">copy</span>]];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              	<span class="hljs-comment">// 默认字符数据使用字符串方式返回</span><br>                <span class="hljs-built_in">NSString</span> *str = [[<span class="hljs-built_in">NSString</span> alloc] initWithData:frameData encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>                <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">nil</span> &amp;&amp; frameData) &#123;<br>                    [<span class="hljs-keyword">self</span> closeWithCode:SRStatusCodeInvalidUTF8 reason:<span class="hljs-string">@&quot;Text frames must be valid UTF-8&quot;</span>];<br>                    <span class="hljs-built_in">dispatch_async</span>(_workQueue, ^&#123;<br>                        [<span class="hljs-keyword">self</span> closeConnection];<br>                    &#125;);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                [<span class="hljs-keyword">self</span> _handleMessage:str];<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> SROpCodeBinaryFrame:<br>        		<span class="hljs-comment">// 处理二进制数据类型消息</span><br>            [<span class="hljs-keyword">self</span> _handleMessage:[frameData <span class="hljs-keyword">copy</span>]];<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SROpCodeConnectionClose:<br>        		<span class="hljs-comment">// 处理关闭控制类型消息</span><br>            [<span class="hljs-keyword">self</span> handleCloseWithData:[frameData <span class="hljs-keyword">copy</span>]];<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SROpCodePing:<br>        		<span class="hljs-comment">// 处理 ping 控制类型消息</span><br>            [<span class="hljs-keyword">self</span> handlePing:[frameData <span class="hljs-keyword">copy</span>]];<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SROpCodePong:<br>        		<span class="hljs-comment">// 处理 pong 控制类型消息</span><br>            [<span class="hljs-keyword">self</span> handlePong:[frameData <span class="hljs-keyword">copy</span>]];<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>        		<span class="hljs-comment">// 其他 opcode 无效</span><br>            [<span class="hljs-keyword">self</span> _closeWithProtocolError:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Unknown opcode %ld&quot;</span>, (<span class="hljs-type">long</span>)opcode]];<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Handle invalid opcode</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>handleFrameWithData 方法根据 opcode 的不同，对数据有不同的处理方式，并在处理前先创建了下一轮的消费者。以上这些代码只是 webSocket 消费者的创建和回调处理，我们还需要一个事件去驱动数据流转，这个事件就是 pumpScanner。</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">-(<span class="hljs-type">void</span>)_pumpScanner;<br>&#123;<br>    [<span class="hljs-keyword">self</span> assertOnWorkQueue];<br>    <br>  	<span class="hljs-comment">// 如果正在 pumping 直接返回</span><br>    <span class="hljs-keyword">if</span> (!_isPumping) &#123;<br>        _isPumping = <span class="hljs-literal">YES</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> ([<span class="hljs-keyword">self</span> _innerPumpScanner]) &#123;<br>        <br>    &#125;<br>    <br>    _isPumping = <span class="hljs-literal">NO</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>pumpScanner 方法里循环调用了 innerPumpScanner，我们先记住这个 while 循环。</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">// Returns true if did work</span><br>- (<span class="hljs-type">BOOL</span>)_innerPumpScanner &#123;<br>    <br>  	<span class="hljs-comment">// 这是个标志位  决定 pumpScanner 的循环是否持续</span><br>    <span class="hljs-type">BOOL</span> didWork = <span class="hljs-literal">NO</span>;<br>    <br>  	<span class="hljs-comment">// 状态不对  返回 NO</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.readyState &gt;= SR_CLOSED) &#123;<br>        <span class="hljs-keyword">return</span> didWork;<br>    &#125;<br>    <br>  	<span class="hljs-comment">// 消费者工作队列是空的   返回 NO</span><br>    <span class="hljs-keyword">if</span> (!_consumers.count) &#123;<br>        <span class="hljs-keyword">return</span> didWork;<br>    &#125;<br>    <br>  	<span class="hljs-comment">// 已读缓冲区没有新增可读数据  返回 NO</span><br>    size_t curSize = _readBuffer.length - _readBufferOffset;<br>    <span class="hljs-keyword">if</span> (!curSize) &#123;<br>        <span class="hljs-keyword">return</span> didWork;<br>    &#125;<br>    <br>  	<span class="hljs-comment">// 从消费者工作队列里取出第一个消费者</span><br>    SRIOConsumer *consumer = [_consumers objcAtIndex:<span class="hljs-number">0</span>];<br>    <br>    size_t bytesNeeded = consumer.bytesNeeded;<br>    <br>    size_t foundSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (consumer.consumer) &#123;<br>      	<span class="hljs-comment">// 如果消费者携带匹配规则的匿名函数，说明是 HTTP Header consumer，</span><br>        <span class="hljs-built_in">NSData</span> *tempView = [<span class="hljs-built_in">NSData</span> dataWithBytesNoCopy:(<span class="hljs-type">char</span> *)_readBuffer.bytes + _readBufferOffset length:_readBuffer.length - _readBufferOffset freeWhenDone:<span class="hljs-literal">NO</span>];  <br>      	<span class="hljs-comment">// 计算可读缓存中匹配 HTTP Header 的数据长度</span><br>        foundSize = consumer.consumer(tempView);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      	<span class="hljs-comment">// webSocket consumer</span><br>        assert(consumer.bytesNeeded);<br>        <span class="hljs-keyword">if</span> (curSize &gt;= bytesNeeded) &#123;<br>          	<span class="hljs-comment">// 可读的数据比需要的大，那么只读消费者需要的长度</span><br>            foundSize = bytesNeeded;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (consumer.readToCurrentFrame) &#123;<br>          	<span class="hljs-comment">// 可读的数据比需要的小，但这个消费者是读取数据类型的 Payload，那么能读多少读多少</span><br>            foundSize = curSize;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">NSData</span> *slice = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> (consumer.readToCurrentFrame || foundSize) &#123;<br>      	<span class="hljs-comment">// 将消费者需要的数据取出来</span><br>        <span class="hljs-built_in">NSRange</span> sliceRange = <span class="hljs-built_in">NSMakeRange</span>(_readBufferOffset, foundSize);<br>        slice = [_readBuffer subdataWithRange:sliceRange];<br>        <br>      	<span class="hljs-comment">// 更新偏移量</span><br>        _readBufferOffset += foundSize;<br>        <br>      	<span class="hljs-comment">// 这里是优化缓存使用大小</span><br>        <span class="hljs-keyword">if</span> (_readBufferOffset &gt; <span class="hljs-number">4096</span> &amp;&amp; _readBufferOffset &gt; (_readBuffer.length &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>            _readBuffer = [[<span class="hljs-built_in">NSMutableData</span> alloc] initWithBytes:(<span class="hljs-type">char</span> *)_readBuffer.bytes + _readBufferOffset length:_readBuffer.length - _readBufferOffset];            _readBufferOffset = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>      	<span class="hljs-comment">// 消费者的 unmaskBytes 属性，如果是 1，需要将 Payload 数据解掩码，而解掩码所需的 Masking Key，之前已经保存到 currentReadMaskKey 里了</span><br>        <span class="hljs-keyword">if</span> (consumer.unmaskBytes) &#123;<br>            <span class="hljs-built_in">NSMutableData</span> *mutableSlice = [slice mutableCopy];<br>            <br>            <span class="hljs-built_in">NSUInteger</span> len = mutableSlice.length;<br>            uint8_t *bytes = mutableSlice.mutableBytes;<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSUInteger</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>                bytes[i] = bytes[i] ^ _currentReadMaskKey[_currentReadMaskOffset % <span class="hljs-keyword">sizeof</span>(_currentReadMaskKey)];<br>                _currentReadMaskOffset += <span class="hljs-number">1</span>;<br>            &#125;<br>            <br>            slice = mutableSlice;<br>        &#125;<br>        <br>      	<span class="hljs-comment">// 消费者的 readToCurrentFrame 属性，如果是 1，说明是在读取数据帧的 Payload</span><br>        <span class="hljs-keyword">if</span> (consumer.readToCurrentFrame) &#123;<br>          	<span class="hljs-comment">// 将当前帧的 Payload 数据拼接到当前消息数据的缓存上</span><br>            [_currentFrameData appendData:slice];<br>            <br>          	<span class="hljs-comment">// 参数没用上</span><br>            _readOpCount += <span class="hljs-number">1</span>;<br>            <br>          	<span class="hljs-comment">// 如果当前帧类型是文本帧，需要对 Payload 数据做 UTF8 编码校验</span><br>            <span class="hljs-keyword">if</span> (_currentFrameOpcode == SROpCodeTextFrame) &#123;<br>                <span class="hljs-comment">// Validate UTF8 stuff.</span><br>                size_t currentDataSize = _currentFrameData.length;<br>                <span class="hljs-keyword">if</span> (_currentFrameOpcode == SROpCodeTextFrame &amp;&amp; currentDataSize &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Optimize the crap out of this.  Don&#x27;t really have to copy all the data each time</span><br>                    <br>                    size_t scanSize = currentDataSize - _currentStringScanPosition;<br>                    <br>                    <span class="hljs-built_in">NSData</span> *scan_data = [_currentFrameData subdataWithRange:<span class="hljs-built_in">NSMakeRange</span>(_currentStringScanPosition, scanSize)];<br>                    int32_t valid_utf8_size = validate_dispatch_data_partial_string(scan_data);<br>                    <br>                    <span class="hljs-keyword">if</span> (valid_utf8_size == <span class="hljs-number">-1</span>) &#123;<br>                        [<span class="hljs-keyword">self</span> closeWithCode:SRStatusCodeInvalidUTF8 reason:<span class="hljs-string">@&quot;Text frames must be valid UTF-8&quot;</span>];<br>                        <span class="hljs-built_in">dispatch_async</span>(_workQueue, ^&#123;<br>                            [<span class="hljs-keyword">self</span> closeConnection];<br>                        &#125;);<br>                        <span class="hljs-keyword">return</span> didWork;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                      	<span class="hljs-comment">// 更新已校验字符偏移</span><br>                        _currentStringScanPosition += valid_utf8_size;<br>                    &#125;<br>                &#125; <br>                <br>            &#125;<br>            <br>          	<span class="hljs-comment">// 更新消费者的 bytesNeeded</span><br>            consumer.bytesNeeded -= foundSize;<br>            <br>          	<span class="hljs-comment">// 如果 bytesNeeded 是 0，说明当前消费者杀青了，调用消费者的完成回调，把它还给缓存池</span><br>            <span class="hljs-keyword">if</span> (consumer.bytesNeeded == <span class="hljs-number">0</span>) &#123;<br>                [_consumers removeobjcAtIndex:<span class="hljs-number">0</span>];<br>                consumer.handler(<span class="hljs-keyword">self</span>, <span class="hljs-literal">nil</span>);<br>                [_consumerPool returnConsumer:consumer];<br>                didWork = <span class="hljs-literal">YES</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (foundSize) &#123;<br>          	<span class="hljs-comment">// 如果不是消费者不是读取数据帧 Payload 类型的 webSocket consumer</span><br>          	<span class="hljs-comment">// 并且已经拿到了想要的数据，调用消费者的完成回调，把它还给缓存池</span><br>            [_consumers removeobjcAtIndex:<span class="hljs-number">0</span>];<br>            consumer.handler(<span class="hljs-keyword">self</span>, slice);<br>            [_consumerPool returnConsumer:consumer];<br>            didWork = <span class="hljs-literal">YES</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> didWork;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这个方法里的 didWork 标志位需要跟上一个方法的 while 循环结合起来看，只有在消费者拿到了自己想要的数据完成使命后，才会将这个标志位设为 YES，进入下一次循环，因为此时可能可读缓存区还有一部分数据是可以读的。当前状态问题、工作队列没有消费者、可读缓存区没有数据可读 和消费者没有完整拿到数据，这些情况即使再跑一次 innerPumpScanner 也未必解决，不如停止循环，等待下一次 pumpScanner 的触发。</p>
<h3 id="数据写入">数据写入</h3>
<p>与读取相比，写入是一个反向组装的过程，代码相对比较简单。写入的驱动源于客户端调用 send()、sendPing()，之后会走到 sendFrameWithOpcode 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_sendFrameWithOpcode:(SROpCode)opcode data:(<span class="hljs-type">id</span>)data;<br>&#123;<br>    [<span class="hljs-keyword">self</span> assertOnWorkQueue];<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> == data) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  	<span class="hljs-comment">// 只支持字符和二进制类型</span><br>    <span class="hljs-built_in">NSAssert</span>([data isKindOfClass:[<span class="hljs-built_in">NSData</span> <span class="hljs-keyword">class</span>]] || [data isKindOfClass:[<span class="hljs-built_in">NSString</span> <span class="hljs-keyword">class</span>]], <span class="hljs-string">@&quot;NSString or NSData&quot;</span>);<br>    <br>  	<span class="hljs-comment">// 计算 Payload Length</span><br>    size_t payloadLength = [data isKindOfClass:[<span class="hljs-built_in">NSString</span> <span class="hljs-keyword">class</span>]] ? [(<span class="hljs-built_in">NSString</span> *)data lengthOfBytesUsingEncoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>] : [data length];<br>        <br>    <span class="hljs-built_in">NSMutableData</span> *frame = [[<span class="hljs-built_in">NSMutableData</span> alloc] initWithLength:payloadLength + SRFrameHeaderOverhead];<br>  	<span class="hljs-comment">// 这里是先粗略计算下是否还有能容下这个 webSocket 帧的内存大小</span><br>    <span class="hljs-keyword">if</span> (!frame) &#123;<br>        [<span class="hljs-keyword">self</span> closeWithCode:SRStatusCodeMessageTooBig reason:<span class="hljs-string">@&quot;Message too big&quot;</span>];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    uint8_t *frame_buffer = (uint8_t *)[frame mutableBytes];<br>    <br>    <span class="hljs-comment">// 写 FIN、RSV、Opcode 位</span><br>    frame_buffer[<span class="hljs-number">0</span>] = SRFinMask | opcode;<br>    <br>  	<span class="hljs-comment">// 协议规定  客户端发送的帧 Mask 需设置为 1</span><br>    <span class="hljs-type">BOOL</span> useMask = <span class="hljs-literal">YES</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> NOMASK</span><br>    useMask = <span class="hljs-literal">NO</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>  	<span class="hljs-comment">// 写 Mask 位</span><br>    <span class="hljs-keyword">if</span> (useMask) &#123;<br>    <span class="hljs-comment">// set the mask and header</span><br>        frame_buffer[<span class="hljs-number">1</span>] |= SRMaskMask;<br>    &#125;<br>    <br>    size_t frame_buffer_size = <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-keyword">const</span> uint8_t *unmasked_payload = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> ([data isKindOfClass:[<span class="hljs-built_in">NSData</span> <span class="hljs-keyword">class</span>]]) &#123;<br>        unmasked_payload = (uint8_t *)[data bytes];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([data isKindOfClass:[<span class="hljs-built_in">NSString</span> <span class="hljs-keyword">class</span>]]) &#123;<br>        unmasked_payload =  (<span class="hljs-keyword">const</span> uint8_t *)[data UTF8String];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  	<span class="hljs-comment">// 写 Payload Length / Extension Payload Length</span><br>    <span class="hljs-keyword">if</span> (payloadLength &lt; <span class="hljs-number">126</span>) &#123;<br>      	<span class="hljs-comment">// Payload Length 7位可以表示</span><br>        frame_buffer[<span class="hljs-number">1</span>] |= payloadLength;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (payloadLength &lt;= <span class="hljs-built_in">UINT16_MAX</span>) &#123;<br>      	<span class="hljs-comment">// Payload Length 需用16位表示</span><br>        frame_buffer[<span class="hljs-number">1</span>] |= <span class="hljs-number">126</span>;<br>        *((uint16_t *)(frame_buffer + frame_buffer_size)) = EndianU16_BtoN((uint16_t)payloadLength);<br>        frame_buffer_size += <span class="hljs-keyword">sizeof</span>(uint16_t);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      	<span class="hljs-comment">// Payload Length 需用64位表示</span><br>        frame_buffer[<span class="hljs-number">1</span>] |= <span class="hljs-number">127</span>;<br>        *((uint64_t *)(frame_buffer + frame_buffer_size)) = EndianU64_BtoN((uint64_t)payloadLength);<br>        frame_buffer_size += <span class="hljs-keyword">sizeof</span>(uint64_t);<br>    &#125;<br>        <br>    <span class="hljs-keyword">if</span> (!useMask) &#123;<br>      	<span class="hljs-comment">// 不使用掩码  直接写 Payload</span><br>        <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; payloadLength; i++) &#123;<br>            frame_buffer[frame_buffer_size] = unmasked_payload[i];<br>            frame_buffer_size += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      	<span class="hljs-comment">// 使用掩码  先写 Masking Key</span><br>        uint8_t *mask_key = frame_buffer + frame_buffer_size;<br>        SecRandomCopyBytes(kSecRandomDefault, <span class="hljs-keyword">sizeof</span>(uint32_t), (uint8_t *)mask_key);<br>        frame_buffer_size += <span class="hljs-keyword">sizeof</span>(uint32_t);<br>        <br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> could probably optimize this with SIMD</span><br>      	<span class="hljs-comment">// 写掩码后的 Payload</span><br>        <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; payloadLength; i++) &#123;<br>            frame_buffer[frame_buffer_size] = unmasked_payload[i] ^ mask_key[i % <span class="hljs-keyword">sizeof</span>(uint32_t)];<br>            frame_buffer_size += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    assert(frame_buffer_size &lt;= [frame length]);<br>  <br>  	<span class="hljs-comment">// 这里校正实际的帧大小</span><br>    frame.length = frame_buffer_size;<br>    <br>    [<span class="hljs-keyword">self</span> _writeData:frame];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>sendFrameWithOpcode 方法的作用是把 Payload 数据根据 Opcode 包装成 webSocket 帧，最后调用 writeData 将数据写到缓存区。</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_writeData:(<span class="hljs-built_in">NSData</span> *)data;<br>&#123;    <br>    [<span class="hljs-keyword">self</span> assertOnWorkQueue];<br><br>  	<span class="hljs-comment">// 用来表示是否是在完成写入后关闭连接</span><br>    <span class="hljs-keyword">if</span> (_closeWhenFinishedWriting) &#123;<br>            <span class="hljs-keyword">return</span>;<br>    &#125;<br>  <br>  	<span class="hljs-comment">// 将 webSocket 帧数据拼接到输出缓存区</span><br>    [_outputBuffer appendData:data];<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>到这里，我们已经将 webSocket 帧打包好拼接到了输出缓存区，下一步是需要将输出缓存区可输出的数据写入到输出流中，就是 pumpWriting。</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)_pumpWriting;<br>&#123;<br>    [<span class="hljs-keyword">self</span> assertOnWorkQueue];<br>    <br>    <span class="hljs-built_in">NSUInteger</span> dataLength = _outputBuffer.length;<br>  	<span class="hljs-comment">// 输出缓存区有新的数据内容输出，并且输出流有空间可以写</span><br>    <span class="hljs-keyword">if</span> (dataLength - _outputBufferOffset &gt; <span class="hljs-number">0</span> &amp;&amp; _outputStream.hasSpaceAvailable) &#123;<br>      	<span class="hljs-comment">// 写入到输出流中</span><br>        <span class="hljs-built_in">NSInteger</span> bytesWritten = [_outputStream write:_outputBuffer.bytes + _outputBufferOffset maxLength:dataLength - _outputBufferOffset];<br>        <span class="hljs-keyword">if</span> (bytesWritten == <span class="hljs-number">-1</span>) &#123;<br>            [<span class="hljs-keyword">self</span> _failWithError:[<span class="hljs-built_in">NSError</span> errorWithDomain:SRWebSocketErrorDomain code:<span class="hljs-number">2145</span> userInfo:[<span class="hljs-built_in">NSDictionary</span> dictionaryWithobjc:<span class="hljs-string">@&quot;Error writing to stream&quot;</span> forKey:<span class="hljs-built_in">NSLocalizedDescriptionKey</span>]]];<br>             <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>      	<span class="hljs-comment">// 更新已写偏移量</span><br>        _outputBufferOffset += bytesWritten;<br>        <br>      	<span class="hljs-comment">// 优化内存使用</span><br>        <span class="hljs-keyword">if</span> (_outputBufferOffset &gt; <span class="hljs-number">4096</span> &amp;&amp; _outputBufferOffset &gt; (_outputBuffer.length &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>            _outputBuffer = [[<span class="hljs-built_in">NSMutableData</span> alloc] initWithBytes:(<span class="hljs-type">char</span> *)_outputBuffer.bytes + _outputBufferOffset length:_outputBuffer.length - _outputBufferOffset];<br>            _outputBufferOffset = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <br>  	<span class="hljs-comment">// 这里如果 closeWhenFinishedWriting 被设置为 YES，并且所有数据都已完成写入，会主动关闭连接</span><br>    <span class="hljs-keyword">if</span> (_closeWhenFinishedWriting &amp;&amp; <br>        _outputBuffer.length - _outputBufferOffset == <span class="hljs-number">0</span> &amp;&amp; <br>        (_inputStream.streamStatus != <span class="hljs-built_in">NSStreamStatusNotOpen</span> &amp;&amp;<br>         _inputStream.streamStatus != <span class="hljs-built_in">NSStreamStatusClosed</span>) &amp;&amp;<br>        !_sentClose) &#123;<br>        _sentClose = <span class="hljs-literal">YES</span>;<br>        <br>        <span class="hljs-keyword">@synchronized</span>(<span class="hljs-keyword">self</span>) &#123;<br>          	<span class="hljs-comment">// 关闭输入输出流</span><br>            [_outputStream close];<br>            [_inputStream close];<br>            <br>            <span class="hljs-comment">// 移除 runloop</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSArray</span> *runLoop <span class="hljs-keyword">in</span> [_scheduledRunloops <span class="hljs-keyword">copy</span>]) &#123;<br>                [<span class="hljs-keyword">self</span> unscheduleFromRunLoop:[runLoop objcAtIndex:<span class="hljs-number">0</span>] forMode:[runLoop objcAtIndex:<span class="hljs-number">1</span>]];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (!_failed) &#123;<br>          	<span class="hljs-comment">// 回调上层</span><br>            [<span class="hljs-keyword">self</span> _performDelegateBlock:^&#123;<br>                <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(webSocket:didCloseWithCode:reason:wasClean:)]) &#123;<br>                    [<span class="hljs-keyword">self</span>.delegate webSocket:<span class="hljs-keyword">self</span> didCloseWithCode:_closeCode reason:_closeReason wasClean:<span class="hljs-literal">YES</span>];<br>                &#125;<br>            &#125;];<br>        &#125;<br>        <br>        [<span class="hljs-keyword">self</span> _scheduleCleanup];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>pumpWriting 完成了从输出缓存区到输出流的数据写入，剩下的就是输出流将数据发送到服务端的 Input，底层已经帮我们处理了。</p>
<h2 id="关闭连接-v2">关闭连接</h2>
<p>查看 SRWebSocket 的头文件会发现，监听 webSocket 异常关闭的方法有两个。</p>
<figure class="highlight objc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)webSocket:(SRWebSocket *)webSocket didFailWithError:(<span class="hljs-built_in">NSError</span> *)error;<br>- (<span class="hljs-type">void</span>)webSocket:(SRWebSocket *)webSocket didCloseWithCode:(<span class="hljs-built_in">NSInteger</span>)code reason:(<span class="hljs-built_in">NSString</span> *)reason wasClean:(<span class="hljs-type">BOOL</span>)wasClean;<br></code></pre></div></td></tr></table></figure>
<p>查看源码会发现 didCloseWithCode 一般处理的是部分协议规定的 webSocket 状态码，而 didFailWithError 一般处理 webSocket 在建连阶段的异常，比如 Header 解析异常、超时异常，以及一些输入输出流的异常报错。可以理解为常见的 webSocket 协议的状态异常由 didCloseWithCode 回调，其他情况则由 didFailWithError 覆盖。正如前面提到的，两端关闭 webSocket 连接不能只是单纯的断开 TCP，需两端在 webSocket 层面协商后再执行。SRWebSocket 在处理客户端主动断开时，只是向服务端发送 Close 帧，然后等待服务端返回 Close 后再清理资源断开连接。</p>
<h1>封装 SRWebSocket</h1>
<p>之前公司使用 SRWebSocket 有几个需求，一是需要在 TCP 连接前先做 DNS 预解析，二是需要给 webSocket 各阶段做行为打点统计耗时，三是添加重连功能。实现思路是在 SRWebSocket 层加入 DNS 预解析，调整建连顺序，添加几个 SR_ReadyState，虽然这不是按协议标准。重连和打点则单独封装一层来做，尽量少去修改 SRWebSocket 源码。最终的 Repo 地址：<a target="_blank" rel="noopener" href="https://github.com/XiaopingSun/XPWebSocket">XPWebSocket</a></p>
<h1>后记</h1>
<p>SRWebSocket 这篇博客算是一个心结吧，从我牛离职后，总感觉有什么事情没有做完，现在心结已了，很开心！之后要继续学习自己喜欢的音视频开发了，也会把学到的东西第一时间在这里更新，加油吧骚年！</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/webSocket/">webSocket</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/07/iOS-%E4%BD%BF%E7%94%A8-AVFoundation-%E9%87%87%E9%9B%86%E7%9B%B8%E6%9C%BA%E7%94%BB%E9%9D%A2/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">iOS 使用 AVFoundation 采集相机画面</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/16/Mac%E7%8E%AF%E5%A2%83%E7%BC%96%E8%AF%91rtmpdump/">
                        <span class="hidden-mobile">Mac环境编译rtmpdump</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://lib.baomitu.com/gitalk/1.7.2/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"f9864fbe3f26bf3e3fda","clientSecret":"340b5fef89b3fed001756139cf60d36fd4a8a599","repo":"XiaopingSun.github.io","owner":"XiaopingSun","admin":["XiaopingSun"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'e1e14fc7f4270780318c60fed29d7f07'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
      <div class="col-lg-7 mx-auto nopadding-x-md">
        <div class="container custom mx-auto">
           <link rel="stylesheet" href="/css/APlayer.min.css"> <div id="aplayer"></div> <script type="text/javascript" src="/js/APlayer.min.js"></script> <script type="text/javascript" src="/js/music.js"></script> 
        </div>
      </div>
    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        沪ICP备2023015573号-1
      </a>
    </span>
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js" ></script>
  
  
    <script  src="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js" ></script>
  
  
    <script defer src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
